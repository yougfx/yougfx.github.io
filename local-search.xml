<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Unity AssetBundle</title>
    <link href="/2021/12/24/%E8%B5%84%E6%BA%90%E6%89%93%E5%8C%85/"/>
    <url>/2021/12/24/%E8%B5%84%E6%BA%90%E6%89%93%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h4 id="AssetBundle的作用"><a href="#AssetBundle的作用" class="headerlink" title="AssetBundle的作用"></a>AssetBundle的作用</h4><ul><li>AssetBundle相当于是一个资源压缩包，里面的一个个对象，对象有两大类 一类是纯资源的对象，另外一个是Unity序列化的一些游戏对象。包含模型、贴图、预制体、声音、甚至整个场景。</li><li>AssetBundle自身保存着互相的依赖关系;<br>压缩包可以使用LZMA和LZ4压缩算法，减少包大小，更快的进行网络传输；</li><li>把一些可以下载内容放在AssetBundle里面，可以减少安装包的大小；</li><li>版本更新</li><li>减少运行时的内存压力</li><li>DownLoaddable Content（DLC）</li></ul><h4 id="AssetBundle的创建"><a href="#AssetBundle的创建" class="headerlink" title="AssetBundle的创建"></a>AssetBundle的创建</h4><p>设置 Asset Bundle Name</p><p><img src="https://cdn.jsdelivr.net/gh/ShyHeart/Photo/photo/image-20211224225401208.png" alt="image-20211224225401208"></p><p><strong>Build AssetBundle</strong></p><div class="code-wrapper"><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public class BuildTool &#123;    [MenuItem(&quot;BuildTool&#x2F;Clear AssetBundles&quot;)]    static void ClearAllAssetBundles()    &#123;        var allBundles &#x3D; AssetDatabase.GetAllAssetBundleNames();        foreach (var bundle in allBundles)        &#123;            AssetDatabase.RemoveAssetBundleName(bundle,true);            Debug.LogFormat(&quot;BuildTool:Remove Old Bundle:&#123;0&#125;&quot;,bundle);        &#125;    &#125;    [MenuItem(&quot;BuildTool&#x2F;Build AssetBundles&quot;)]    static void BuildAllAssetBundles()    &#123;        string assetBundleDirectory &#x3D; &quot;Assets&#x2F;AssetBundles&quot;;        if (!Directory.Exists(assetBundleDirectory))        &#123;            Directory.CreateDirectory(assetBundleDirectory);        &#125;        BuildPipeline.BuildAssetBundles(assetBundleDirectory,BuildAssetBundleOptions.None,BuildTarget.StandaloneWindows64);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h4 id="AssetBundle的加载"><a href="#AssetBundle的加载" class="headerlink" title="AssetBundle的加载"></a>AssetBundle的加载</h4><div class="code-wrapper"><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public class BundleTest : MonoBehaviour&#123;    void Start()    &#123;        StartCoroutine(LoadCharacter(&quot;Test&quot;));    &#125; IEnumerator LoadCharacter(string assetBundleName)    &#123;        string uri &#x3D; &quot;file:&#x2F;&#x2F;&#x2F;Assets&#x2F;AssetBundles&#x2F;Test&quot;+assetBundleName.ToLower()+&quot;.asset&quot;;        UnityWebRequest request &#x3D; UnityWebRequestAssetBundle.GetAssetBundle(uri);        yield return request.SendWebRequest();        AssetBundle bundle &#x3D; DownloadHandlerAssetBundle.GetContent(request);        GameObject gameObject&#x3D;bundle.LoadAsset&lt;GameObject&gt;(assetBundleName);        Instantiate(gameObject);     &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>AB加载方式：</p><ol><li><p>AssetBundle.LoadFromFile 从本地加载</p></li><li><p>AssetBundle.LoadFromMemory 从内存加载</p></li><li><p>WWW.LoadFromCacheOrDownload 下载后放在缓存中备用(该方法逐渐被弃用)</p></li><li><p>UnityWebRequest 从服务器下载</p></li></ol><p>从AB中加载资源：</p><ol><li><p>AssetBundle.LoadAsset(assetName)</p></li><li><p>AssetBundle.LoadAllAssets() 加载AB包中所有的对象，不包含依赖的包</p></li><li><p>AssetBundle.LoadAssetAsync() 异步加载，加载较大资源的时候</p></li><li><p>AssetBundle.LoadAllAssetsAsync() 异步加载全部资源</p></li><li><p>AssetBundle.LoadAssetWithSubAssets 加载资源及其子资源</p></li></ol><p>AB的卸载</p><ol><li>减少内存的使用</li><li>有可能导致丢失</li><li>在切换场景，或者确定不使用的时候卸载<br>AssetBundle.Unload(true) //卸载AB文件的内存镜像，且包含所有Load创建出来的对象<br>AssetBundle.Unload(false) //卸载AB文件的内存镜像，但是除了Load创建出来的对象<br>Reources.UnloadAsset(Object) //释放已加载的资源Object<br>Resources.UnloadUnusedAssets //卸载所有没有被场景引用的资源对象</li></ol><h4 id="AssetBundle的进阶"><a href="#AssetBundle的进阶" class="headerlink" title="AssetBundle的进阶"></a>AssetBundle的进阶</h4><h5 id="AssetBundle依赖关系"><a href="#AssetBundle依赖关系" class="headerlink" title="AssetBundle依赖关系"></a>AssetBundle依赖关系</h5><p>1.打包依赖</p><p><img src="https://cdn.jsdelivr.net/gh/ShyHeart/Photo/photo/20211224233504.png" alt=""></p><p><strong>原本只需要3M的内存，而打包后会发生冗余。</strong></p><p><strong>优化，将共享的资源单独打包一个Bundle</strong></p><p><img src="https://cdn.jsdelivr.net/gh/ShyHeart/Photo/photo/image-20211224234059208.png" alt="image-20211224234059208"></p><p>同时也要记得在加载Bundle的时候加上加载材质Bundle的代码</p><div class="code-wrapper"><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public class BundleTest : MonoBehaviour&#123;    void Start()    &#123;        StartCoroutine(LoadCharacter(&quot;Test&quot;));    &#125; IEnumerator LoadCharacter(string assetBundleName)    &#123;    &#x2F;&#x2F;Bundle 1        string uri &#x3D; &quot;file:&#x2F;&#x2F;&#x2F;Assets&#x2F;AssetBundles&#x2F;Test&quot;+assetBundleName.ToLower()+&quot;.asset&quot;;        UnityWebRequest request &#x3D; UnityWebRequestAssetBundle.GetAssetBundle(uri);        yield return request.SendWebRequest();        AssetBundle bundle &#x3D; DownloadHandlerAssetBundle.GetContent(request);                &#x2F;&#x2F;Bundle 2        string uri2 &#x3D; &quot;file:&#x2F;&#x2F;&#x2F;Assets&#x2F;AssetBundles&#x2F;Test&#x2F;Test.mat.asset&quot;;        UnityWebRequest request2 &#x3D; UnityWebRequestAssetBundle.GetAssetBundle(uri2);        yield return request2.SendWebRequest();        AssetBundle bundle2 &#x3D; DownloadHandlerAssetBundle.GetContent(request2);                GameObject gameObject&#x3D;bundle.LoadAsset&lt;GameObject&gt;(assetBundleName);        Instantiate(gameObject);     &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>2.加载依赖</p><p><img src="https://cdn.jsdelivr.net/gh/ShyHeart/Photo/photo/image-20211225104534276.png" alt="image-20211225104534276"></p><p>这种方式加载，会出现一个问题就是，加载一个model时要加载Bundle里所有的M 加载一个纹理也要加载包里所有的material 贴图也是，出现了资源冗余，那我们就需要一个好的分配</p><h5 id="分配策略"><a href="#分配策略" class="headerlink" title="分配策略"></a>分配策略</h5><p><strong>1.按类型分组</strong></p><ul><li>强类型关联，将相同的资源打包在一个Bundle</li><li>平台相关，将不同平台下的资源分别打包</li><li>本地化相关</li><li>无交叉依赖 不会对另外一个Bundle产生依赖</li><li>所有声音资源打成一个包，所有shader打成一个包，所有模型打成一个包，所有材质打成一个包</li></ul><p><strong>2.按并发分组</strong></p><ul><li>加载时机一致，在很短的时间内同时发生的资源都打包到一个Bundle</li><li>无交叉依赖</li></ul><p><strong>3.按逻辑单元分组</strong></p><ul><li>逻辑功能 如UI资源 相对独立</li><li>逻辑对象 一个角色或者所有角色一个包</li><li>共享对象 所有的场景所共享的部分一个包</li></ul><h4 id="其他建议"><a href="#其他建议" class="headerlink" title="其他建议"></a><strong>其他建议</strong></h4><ul><li>对频繁更新的对象进行拆分</li><li>同时加载的对象打包到一起</li><li>拆分加载时机不一致的Bundle</li><li>合并频繁加载的小粒度Bundle</li></ul><h4 id="Manifest文件"><a href="#Manifest文件" class="headerlink" title="Manifest文件"></a>Manifest文件</h4><p><img src="https://cdn.jsdelivr.net/gh/ShyHeart/Photo/photo/image-20211225112845781.png" alt="image-20211225112845781"></p><p>crc为校验码，通过其检查是否完整</p><p>Assets 表示包里包含多少资源</p><p>Dependencies 表示包有哪些依赖</p><p>注意：在加载这些包之前，也需要加载依赖的包，不然会丢失这部分内容，显示效果不正确</p><h4 id="通过Manifest文件得到某个包的依赖"><a href="#通过Manifest文件得到某个包的依赖" class="headerlink" title="通过Manifest文件得到某个包的依赖"></a>通过Manifest文件得到某个包的依赖</h4><p><img src="https://cdn.jsdelivr.net/gh/ShyHeart/Photo/photo/image-20211225112924258.png" alt="image-20211225112924258"></p><p>可以注意到scene/cube.jy依赖于material.jy，而material.jy依赖于texture.jy</p><div class="code-wrapper"><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">AssetBundle manifestAB &#x3D; AssetBundle.LoadFromFile(&quot;AssetBundles&#x2F;AssetBundles&quot;);AssetBundleManifest manifest &#x3D; manifestAB.LoadAsset&lt;AssetBundleManifest&gt;(&quot;AssetBundleManifest&quot;);&#x2F;&#x2F;GetAllDependencies获取到所有的依赖对象string[] strs &#x3D; manifest.GetAllDependencies(&quot;scene&#x2F;cube.jy&quot;);&#x2F;&#x2F;将所有依赖对象依次加载出来foreach (var item in strs)&#123;    Debug.Log(item);      AssetBundle.LoadFromFile(&quot;AssetBundles&#x2F;&quot; + item);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>CRC、MD5、SHA1都是通过对数据进行计算，来生成一个校验值，该校验值用来校验数据的完整性。</p><p>CRC一般用于通信数据的校验，MD5和SHA1用于安全领域，例如文件校验，密码加密等</p><h4 id="AssetBundles浏览工具"><a href="#AssetBundles浏览工具" class="headerlink" title="AssetBundles浏览工具"></a>AssetBundles浏览工具</h4><p><a href="https://github.com/Unity-Technologies/AssetBundles-Browser">工具地址</a></p><p><img src="https://cdn.jsdelivr.net/gh/ShyHeart/Photo/photo/image-20211225113245114.png" alt="image-20211225113245114"></p><p><img src="https://cdn.jsdelivr.net/gh/ShyHeart/Photo/photo/image-20211225113256705.png" alt="image-20211225113256705"></p><p>Build Target 用于设置AB包的目标平台</p><p>OutPut Path 设置AB的输出路径</p><p>Build 一键打包</p>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
      <tag>花里胡哨</tag>
      
      <tag>AssetBundle</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>游戏安全</title>
    <link href="/2021/12/24/%E6%B8%B8%E6%88%8F%E5%AE%89%E5%85%A8/"/>
    <url>/2021/12/24/%E6%B8%B8%E6%88%8F%E5%AE%89%E5%85%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="游戏安全"><a href="#游戏安全" class="headerlink" title="游戏安全"></a>游戏安全</h1><h3 id="常见威胁"><a href="#常见威胁" class="headerlink" title="常见威胁"></a>常见威胁</h3><p>1.<strong>外挂</strong></p><ul><li>加速挂 单机加速，修改本地计算机的时钟周期 网络加速 加快发包速度</li><li>协议挂 破解通讯协议 模拟游戏行为 功能丰富，支持脱机</li><li>内存挂 基于Hook（拦截系统对API的调用行为）和注入技术 功能强大</li><li>脚本辅助 键盘鼠标模拟 不易检测</li></ul><p>2.破解</p><p>3.数据篡改</p><ul><li>内存数据</li><li>存档数据</li><li>通讯数据</li></ul><h3 id="游戏安全的基础应对"><a href="#游戏安全的基础应对" class="headerlink" title="游戏安全的基础应对"></a>游戏安全的基础应对</h3><p><strong>通用方案</strong></p><ul><li><p>进程检测：获取电脑后台进程，对常见外挂的进程创建黑名单</p></li><li><p>窗口检测：因为很多外挂都有窗口的特性，对外挂窗口进行关闭</p></li><li><p>HOOK检测：自己创建一个Hook，通过对方攻击的手段，修复</p><p><strong>加密 混淆 加壳</strong></p></li></ul><p>对数据进行保护 内存及存档</p><p><strong>内存分析工具 WireShark</strong></p><p><strong>Cheat Engine</strong></p><p><img src="https://cdn.jsdelivr.net/gh/ShyHeart/Photo/photo/image-20211224211902025.png" alt="image-20211224211902025"></p><div class="code-wrapper"><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public class SateTest ：MonoBehaviour&#123;    int magic &#x3D; 0x1110004;        public Text hpText;    public Text mpText;        public int hp;    public int HP    &#123;        get&#123; return hp; &#125;        set&#123; hp &#x3D; value; &#125;    &#125;        public int mp;    public int MP    &#123;        get&#123; return mp; &#125;        set&#123; mp &#x3D; value; &#125;    &#125;        public void Add()    &#123;    this.HP +&#x3D; 1;        this.MP +&#x3D; 1;    &#125;        void Update()    &#123;    this.hpText.text &#x3D; HP.ToString();         this.mpText.text &#x3D; ((int)MP).ToString();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p> 开启<strong>Cheat Engine</strong>选择Unity的进程</p><p><img src="https://cdn.jsdelivr.net/gh/ShyHeart/Photo/photo/image-20211224212605532.png" alt="image-20211224212605532"></p><p>重复Add操作和数值扫描操作</p><p>随后选中一个地址将地址加入到地址列表，然后修改数值 如30改成300</p><p><img src="https://cdn.jsdelivr.net/gh/ShyHeart/Photo/photo/image-20211224212937708.png" alt="image-20211224212937708"></p><p>可以看见对进程内存进行修改后 Unity的值也同样修改了。</p><p>实现了对内存值的修改。</p><p>所以我们应该对进程进行加密，让别人找不到这些地址</p><p><strong>位运算异或</strong></p><p>修改的代码</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">public class SateTest ：MonoBehaviour&#123;    int magic &#x3D; 0x1110004;        public Text hpText;    public Text mpText;        public int hp;    public int HP    &#123;        get&#123; return hp ^ magic ; &#125;        set&#123; hp &#x3D; value ^ magic ; &#125;    &#125;        public Long mp;    public float MP;    &#123;        get&#123; return (float)System.BitConverter.Int64BitsToDouble(mp ^ magic); &#125;        set&#123; mp &#x3D; System.BitConverter. Int64BitsToDouble(value)^ magic; &#125;    &#125;        public void Add()    &#123;    this.HP +&#x3D; 1;        this.MP +&#x3D; 1;    &#125;        void Update()    &#123;    this.hpText.text &#x3D; HP.ToString();         this.mpText.text &#x3D; ((int)MP).ToString();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>一个简单的位运算操作。就会让别人找不到你的数值地址</p><p><img src="https://cdn.jsdelivr.net/gh/ShyHeart/Photo/photo/image-20211224214207625.png" alt="image-20211224214207625"></p><p>对于常规的数值修改很有效</p>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
      <tag>花里胡哨</tag>
      
      <tag>技巧</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多线程和线程安全</title>
    <link href="/2021/12/23/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
    <url>/2021/12/23/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="多线程和线程安全"><a href="#多线程和线程安全" class="headerlink" title="多线程和线程安全"></a>多线程和线程安全</h1><p><strong>多线程解决什么问题：多任务，提升计算性能</strong></p><h5 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h5><ul><li>单线程单任务 (Task1 =&gt; Task2 =&gt; Task3)</li><li>单线程多任务 (Task1 =&gt; Task2 =&gt; Task3 =&gt; Task1 =&gt; Task2 =&gt; Task3 =&gt; Task1 =&gt; Task2 =&gt; Task3)</li><li>多线程单任务 (任务Task 开启多线程 Task1-1 Task1-2 Task1-3 Task1-4)</li><li>多任务多线程 （Task1-1 Task1-2 Task1-3 Task1-4)(Task2-1 Task2-2)(Task3)(Task4)</li></ul><p><strong>线程的数量最好是CPU核的倍数</strong></p><h5 id="如何安全的使用多线程"><a href="#如何安全的使用多线程" class="headerlink" title="如何安全的使用多线程"></a>如何安全的使用多线程</h5><p><strong>多线程的问题：线程安全和非线程安全</strong></p><p><strong>1、线程与数据/资源</strong></p><p>因为每一个线程都会访问到数据，而数据不做手段保护，就有可能会出现数据混乱(因为数据是在多个线程中共享的)，而在Unity中把所有于逻辑相关的东西，强制必须都是在单线程内，其他线程不访问，在底层做了一层防范，保证所有的事情是在一个线程内发生，就不会出现这种情况。</p><p><strong>同步与锁</strong></p><p>用于同步的对象 当你考虑好你的线程方案后，会有各种锁选择</p><h6 id="1-lock"><a href="#1-lock" class="headerlink" title="1.lock"></a>1.<strong>lock</strong></h6><p>最暴力简单，使用起来没什么成本，但加锁后可能会有性能问题。使后进入的线程不会中断当前的线程，而是等待当前线程结束后再继续执行。</p><h6 id="2-Monitor（对象）"><a href="#2-Monitor（对象）" class="headerlink" title="2.Monitor（对象）"></a>2.<strong>Monitor（对象）</strong></h6><p>属于lock的底层 更加开放 lock是对Monitor的Enter和Exit的一个封装，因此Monitor类的Enter()和Exit()方法的组合使用可以用lock关键字替代。</p><p>Monitor类除了具有lock的功能外，还有以下功能：</p><p>TryEnter()解决长期死等的问题，如果一个并发经常发生，并且持续时间很长，使用TryEnter，可以有效防止死锁或者长时间 的等待。  </p><p>Wait()释放对象上的锁，以便允许其他线程锁定和访问该对象。在其他线程访问对象时，调用线程将等待。脉冲信号用于通知等待线程有关对象状态的更改。</p><p>Pulse(),PulseAll()向一个或多个等待线程发送信号。该信号通知等待线程锁定对象的状态已更改，并且锁的所有者准备释放该锁。等待线程被放置在对象的就绪队列中以便它可以最后接收对象锁。一旦线程拥有了锁，它就可以检查对象的新状态以查看是否达到所需状态。</p><p>注意：Pulse、PulseAll和Wait方法必须从同步的代码块内调用。</p><h6 id="3-Mutex-（互斥）"><a href="#3-Mutex-（互斥）" class="headerlink" title="3.Mutex （互斥）"></a>3.<strong>Mutex （互斥）</strong></h6><p>Mutex的突出特点是可以跨应用程序域边界对资源进行独占访问，即可以用于同步不同进程中的线程，这种功能是以牺牲更多的系统资源为代价的。  </p><p>互斥体Mutex和事件对象EventWaitHandler属于内核对象，利用内核对象进行线程同步，线程必须要在用户模式和内核模式间切换，所以一般效率很低，但利用互斥对象和事件对象这样的内核对象，可以在多个进程中的各个线程间进行同步。</p><p>互斥体Mutex类似于一个接力棒，拿到接力棒的线程才可以开始跑，当然接力棒一次只属于一个线程(Thread Affinity)，如果这个线程不释放接力棒(Mutex.ReleaseMutex)，那么其他所有需要接力棒运行的线程只能等着看热闹</p><h6 id="4、ReaderWriterLockSlim（多线程读单线程写）"><a href="#4、ReaderWriterLockSlim（多线程读单线程写）" class="headerlink" title="4、ReaderWriterLockSlim（多线程读单线程写）**"></a>4、ReaderWriterLockSlim（多线程读单线程写）**</h6><p>当线程A已经获取到ReaderWriterLockSlim实例的读锁（RedLock,UpgradeableReaLock）后，其它线程只能再获取到该ReaderWriterLockSlim实例的读锁，再申请获取写锁会被阻塞</p><p>当线程A已获取到ReaderWriterLockSlim实例的写锁后，其它线程再申请获取到该ReaderWriterLockSlim实例的写锁和读锁时会被阻塞，直到线程A释放写锁</p><p>注意事项</p><p>（1）线程A如果通过EnterReadLock获取到读锁（ReadLock）后，不能在持有读锁的情况下再申请获取写锁（WriteLock）</p><p>如果违反了这个规定就报如下错：<br>Write lock may not be acquired with read lock held. This pattern is prone to deadlocks. Please ensure that read locks are released before taking a write lock. If an upgrade is necessary, use an upgrade lock in place of the read lock.</p><p>（2）线程A如果通过EnterReadLock获取到读锁（ReadLock）后，不能在持有读锁的情况下再申请获取可升级读锁（UpgradeableReadLock）</p><p>如果违反了这个规定就报如下错：<br>Upgradeable lock may not be acquired with read lock held</p><p>（3）线程A如果通过EnterUpgradeableReadLock获取到可升级读锁（UpgradeableReadLockk）后，可以再持有可升级读锁的情况通过EnterWriteLock获取写锁</p><h6 id="5-Semaphore（信号量）"><a href="#5-Semaphore（信号量）" class="headerlink" title="5.Semaphore（信号量）"></a>5.<strong>Semaphore</strong>（信号量）</h6><p>可理解为允许线程执行信号的池子，池子中放入多少个信号就允许多少线程同时执行。</p><p>说明：</p><p>1、如果semaphore.Release(n)，n&gt;semaphore最大容纳信号量，将出异常。<br>2、当semaphore拥有的信号量为1时，Semaphore相当于Mutex<br>3、当semaphore拥有的信号量&gt;1时，信号量的数量即可供多个线程同时获取的个数，此时可认为获取到信号量的线程将同时执行（实际情况可能与CPU核心数、CPU同时支出线程数有关）</p><p>在调控线程的资源方面更加的灵活</p><h6 id="6、Interlocked（原子锁）"><a href="#6、Interlocked（原子锁）" class="headerlink" title="6、Interlocked（原子锁）"></a>6、Interlocked（原子锁）</h6><p>提供对变量快速操作的一种方式 从而实现线程的同步</p><p><img src="https://cdn.jsdelivr.net/gh/ShyHeart/Photo/photo/2018102683411413.png" alt="2018102683411413.png"></p><h5 id="同步的范围"><a href="#同步的范围" class="headerlink" title="同步的范围"></a>同步的范围</h5><p>对象 如：对列表加锁，列表所有的增删改都等待。</p><p>操作 如：只写读操作和写操作</p><p>变量 如：原子锁 锁定的级别越小 影响的范围越小</p><p><strong>只在必要时候加锁，加锁的力度越小越好</strong></p>]]></content>
    
    
    <categories>
      
      <category>CSharp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSharp</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity InstantOC</title>
    <link href="/2021/12/23/Unity-InstantOC/"/>
    <url>/2021/12/23/Unity-InstantOC/</url>
    
    <content type="html"><![CDATA[<h1 id="Unity-InstantOC"><a href="#Unity-InstantOC" class="headerlink" title="Unity InstantOC"></a>Unity InstantOC</h1><p>InstantOC：一个插件，包括occlusion culling 和 LOD</p><h2 id="一、渲染管线"><a href="#一、渲染管线" class="headerlink" title="一、渲染管线"></a>一、渲染管线</h2><p><strong>渲染管线</strong>：图形数据在GPU上经过运算处理，最后输出到屏幕的过程。                    绘制调用Draw Call：每次引擎（CPU）准备数据并通知GPU的过程。    通俗讲：每帧调用显卡渲染物体的次数。（在starts里Batches后边显示的数字）</p><p>CPU准备数据                 顶点处理：中间有坐标系的转换</p><p>游戏=&gt;图形API=&gt;CPU（决定视锥以内哪些物体需要渲染）=&gt;GPU(显卡）=&gt;顶点处理=&gt;图元装配（连接相邻的点组成三角面）=&gt;光栅化（计算三角面上的像素）=&gt;像素处理（对每个像素区域进行着色）=&gt;缓存（一个存储像素数据的内存块，最重要的是帧缓存（常在显卡中）与深度缓存z-buffer（物体距离摄像机的距离）。）</p><p><img src="https://cdn.jsdelivr.net/gh/xichujn/image/img/image-20210428090432734.png" alt="InstantOC"></p><p>一个物体不渲染，CPU与GPU性能都会提高。物体越多、物体精度越高，CPU与GPU性能越低。</p><h2 id="二、occlusion-culling"><a href="#二、occlusion-culling" class="headerlink" title="二、occlusion culling"></a>二、occlusion culling</h2><p>​    <strong>即时遮挡剔除occlusion culling：在物体被渲染前，将摄像机视角内看不见的物体进行剔除，从而减少了每帧渲染数据量，提高渲染性能。（笔试考）</strong></p><p>  默认：摄像机视锥内物体都会被渲染，即使看不见也会被渲染。</p><p>插件samples：每帧摄像机发射的射线数目，数量多会导致CPU性能降低，通常在150-500之间。</p><p>FOV ：视场&lt;—&gt;摄像机中filed of view      View视野&lt;—&gt;摄像机中far  </p><p>hide delay延迟隐藏：射线发射次数。建议50帧-100帧之间。  PreCull Check，建议勾选。</p><p>遮挡剔除同时，要为物体设置一个<strong>盒子碰撞器</strong>（绿色物理边界）。为物体加一个组件—&gt;<strong>box collider</strong>。</p><p><em>注意：不设置碰撞器射线射不到。</em></p><p><strong><em>遮挡剔除优点：减少渲染量。  （功能上没有损失）  缺点：CPU（射线）需要消耗额外性能</em></strong></p><p><strong><em>场景里物体较多且分布较密集（被遮挡的物体多）时使用遮挡剔除。</em></strong></p><h2 id="三、LOD"><a href="#三、LOD" class="headerlink" title="三、LOD"></a><em>三、</em>LOD</h2><p>  LOD（<strong>Level of Detail</strong>多细节层次）：指根据物体模型的节点在显示环境中所处的位置和重要度，决定物体渲染的资源分配，降低非重要物体的面数和细节度，从而获得高效率的渲染运算。 不会降低draw call</p><p><strong>优点：降低非重要物体的面数与精度，从而获得高效率的渲染运算</strong>  </p><p> 缺点：CPU总需要判断距离，变换模型</p><p>适用性：1场景中需要存在高精度模型  2.距离需要变化</p><p>步骤：1.创建层</p><p>  2.创建空物体并将模型添加到其中，模型命名：Lod_0,Lod_1,Lod_2(精度由高到低）</p><p>  3.为父物体指定层与标签</p><p>  4.父物体或子物体添加碰撞器组件</p><p>  5.摄像机附加脚本IOCcam</p><p>Lod1 distance：摄像机到物体距离小于当前距离时，使用Lod_0模型。</p><p>Lod2 distance：摄像机到物体距离大于Lod1且小于当前距离时，使用Lod_1模型，大于当前值使用Lod_2模型</p>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
      <tag>花里胡哨</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSharp高级</title>
    <link href="/2021/12/23/CSharp%E9%AB%98%E7%BA%A7/"/>
    <url>/2021/12/23/CSharp%E9%AB%98%E7%BA%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="C-高级"><a href="#C-高级" class="headerlink" title="C#高级"></a>C#高级</h2><h3 id="一-简单的数据结构类"><a href="#一-简单的数据结构类" class="headerlink" title="一.简单的数据结构类"></a>一.简单的数据结构类</h3><h4 id="1-Arrarylist"><a href="#1-Arrarylist" class="headerlink" title="1.Arrarylist"></a>1.Arrarylist</h4><h5 id="1-1-ArrayList的本质"><a href="#1-1-ArrayList的本质" class="headerlink" title="1.1.ArrayList的本质"></a>1.1.ArrayList的本质</h5><p>ArrayList是一个C#为我们封装好的类，它的本质是一个object类型的数组，ArrayList类帮助我们实现了很多方法，比如数组的增删改查。</p><h5 id="1-2-ArrayList的申明"><a href="#1-2-ArrayList的申明" class="headerlink" title="1.2.ArrayList的申明"></a>1.2.ArrayList的申明</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C#">// ArrayList在System.Collection命名空间里面，使用之前需要引用命名空间<br>ArrayList array = new ArrayList();<br></code></pre></td></tr></table></figure><h5 id="1-3-ArrayList的增删改查"><a href="#1-3-ArrayList的增删改查" class="headerlink" title="1.3.ArrayList的增删改查"></a>1.3.ArrayList的增删改查</h5><p>增：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C#">ArrayList array = new ArrayList();<br>array.Add(1);<br>array.Add(&quot;12s1&quot;);<br>array.Add(true);<br>array.Add(new Object());<br>// 我们还可以使用两个ArrayList拼接，让一个ArrayList内部的所有值追加到另一个ArrayList的后面<br>ArrayList = array2 = new ArrayList(&quot;123&quot;);<br>// 这里我们原本的array里面会在它之前的尾部把新的“123”存进去<br>array.AddRange(array2);<br><br>// 如果我们想要从中间某一个位置插入元素<br>// 参数1 插入的位置, 参数2 插入的值 <br>array.Insert(1, &quot;13331&quot;);<br>Console.WriteLine(array[1]);<br><br></code></pre></td></tr></table></figure><p>首先，ArrayList的优势是可以存储不同类型的值，因为它的本质就是万物之父（Object）类型的数组，所以它的本质使得它可以存储所有类型的值。</p><p>删：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C#">ArrayList array = new ArrayList(1);<br>// 移除指定元素，从头找，找到就删除，如果ArrayList里面存储了两个相同的值，会删除第一个<br>array.Remove(1);<br>// 移除指定位置的元素<br>array.RemoveAt(2);<br>// 清空<br>array.Clear();<br></code></pre></td></tr></table></figure><p>改：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C#">ArrayList array = new ArrayList(1);<br>Console.WriteLine(arrayp[0]);<br>array[0] = &quot;999&quot;;<br>Console.WriteLine(array[0]);<br></code></pre></td></tr></table></figure><p>查：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C#">ArrayList array = new ArrayList(1);<br>// 得到指定位置的元素<br>Console.WriteLine(array[0]);<br>// 查看元素是否存在，如果存在返回true,不存在返回false<br>if(array.Contain(&quot;123&quot;))&#123;<br>    Console.WriteLine(&quot;存在&quot;);<br>&#125;<br>// 正向(从头开始找)查找元素位置<br>// 如果找到，那么返回值是位置，如果没有找到，返回值是-1<br>int index = array.IndexOf(true);<br>Console.WriteLine(index);<br>Console.WriteLine(array.IndexOf(1));<br>// 返向(从尾开始找)查找元素位置<br>// 如果找到，那么返回值是位置(从头开始找的计数)，如果没有找到，返回值是-1<br>Console.WriteLine(array.LastIndexOf(1));<br></code></pre></td></tr></table></figure><h5 id="1-4-遍历"><a href="#1-4-遍历" class="headerlink" title="1.4.遍历"></a>1.4.遍历</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C#">ArrayList array = new ArrayList();<br>array.Add(1);<br>array.Add(&quot;12s1&quot;);<br>array.Add(true);<br>array.Add(new Object());<br>// 长度<br>// ***注意：我们封装的数据结构类里面获取元素长度都是用Count,而不是普通Array.Length方法<br>// 并且我们也点.不出Length方法，因为在数据结构中容量的定义上就是Length的意思，属于被保护的属性,我们不因该使用Length或者Capacity去遍历我们的数据结构的元素。<br>Console.WriteLine(array.Count);<br>// 容量(相当于我们普通类里的Array.Length)<br>// ***为了避免产生过多的垃圾<br>Console.WriteLine(array.Capacity);<br>for(int i = 0;i&lt;array.Count;i++)&#123;<br>    Console.WriteLine(array[i]);<br>&#125;<br><br>// 迭代器遍历<br>foreach(var item in array)&#123;<br>    Console.WriteLine(item);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="1-5-装箱拆箱"><a href="#1-5-装箱拆箱" class="headerlink" title="1.5.装箱拆箱"></a>1.5.装箱拆箱</h5><p>因为ArrayList本质上是一个可以自动扩容的object数组，由于用万物之父来存储数据，自然存在装箱拆箱的问题。当往其中进行值类型存储时就是在装箱，当将值类型对象取出来转换使用时，就存在拆箱。所以ArrayList尽量少用，但是不是不用它，它是有着自己独特的特点的，因为它是Object类型的，所以所有类型的东西都可以装，这是其他数据结构所不存在的特点。</p><h5 id="1-6-ArrayList和数组的区别"><a href="#1-6-ArrayList和数组的区别" class="headerlink" title="1.6.ArrayList和数组的区别"></a>1.6.ArrayList和数组的区别</h5><p>1.ArrayList本质上是一个object类型的数组的封装</p><p>2.ArrayList可以不用一开始就定长，单独使用数组是定长的。</p><p>3.数组的增删我们需要自己取实现，ArrayList帮我们封装了方便的API来使用</p><p>4.ArrayList使用时可能存在装箱拆箱的问题，数组使用时只要不是object数组那就不存在这个问题 </p><p>5.数组长度为Length，ArrayList长度为Count(这里的长度只存储了元素位置的长度，而非数组的容量大小)</p><h4 id="2-Stack"><a href="#2-Stack" class="headerlink" title="2.Stack"></a>2.Stack</h4><h5 id="2-1-Stack的本质"><a href="#2-1-Stack的本质" class="headerlink" title="2.1.Stack的本质"></a>2.1.Stack的本质</h5><p>Stack(栈)是一个C#为什么封装好的类，它的本质也是object[]数组，只是封装了特殊的存储规则。</p><p>Stack是栈存储容器，栈是一种先进后出的数据结构，先存入的数据后获取，后存入的数据先获取。</p><p>Stack(栈)的特点<em>*</em>：先进后出</p><h5 id="2-2-Stack的申明"><a href="#2-2-Stack的申明" class="headerlink" title="2.2.Stack的申明"></a>2.2.Stack的申明</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C#">// 使用Stack之前需要引入它的命名空间 System.Collections<br>Stack stack = new Stack();<br></code></pre></td></tr></table></figure><h5 id="2-3-Stack的增取查清空"><a href="#2-3-Stack的增取查清空" class="headerlink" title="2.3.Stack的增取查清空"></a>2.3.Stack的增取查清空</h5><p>增（压栈）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C#">// 压栈<br>Stack stack = new Stack();<br>stack.Push(1);<br>stack.Push(&quot;123&quot;);<br>stack.Push(true);<br>stack.Push(new Object());<br></code></pre></td></tr></table></figure><p>取（弹栈）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C#">// 栈中不存在删除的概念，只有取的概念<br>// 弹栈<br>var v = stack.Pop();<br>// 弹栈也是遵循先进后出，后进先出<br>Console.WriteLine(v);<br></code></pre></td></tr></table></figure><p>查：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C#">// ***注意：栈是无法查看指定位置的元素(因为栈是没有实现索引器的功能)，只能查看栈顶的内容<br>// 只是查看栈顶的内容，却不取出来<br>v = stack.Peek();<br><br>// 查看元素是否存在于栈中<br>if(stack.Contains(1.2f))&#123;<br>    Console.WriteLine(&quot;存在1.2f&quot;);<br>&#125;<br></code></pre></td></tr></table></figure><p>清空：(栈是无法改变其中的元素的，因为它本身是没有实现对索引器的功能)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#">stack.Clear();<br></code></pre></td></tr></table></figure><h5 id="2-4-Stack的遍历"><a href="#2-4-Stack的遍历" class="headerlink" title="2.4.Stack的遍历"></a>2.4.Stack的遍历</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C#">// Stack也一样没有Length的功能，对于获取其元素长度的就只有Count字段<br>// 长度<br>Console.WriteLine(stack.Count);<br><br>// ***由于我们的栈是没有提供索引器，所以我们是无法通过中括号“[]”的方式获取我们的成员的<br>// 第一种方法：用foreach遍历，而且遍历出来的顺序也是从栈顶到栈底的<br>foreach(object item in stack)&#123;<br>    Console.WriteLine(item);<br>&#125;<br><br>// 但是由于我们的栈提供一个转为数组的方法，所以如果我们实在是想用for循环遍历也是可以的。但是要配合下面的方式使用。<br>// 第二种方法：将栈转换为object数组，再用for循环遍历出来的顺序也从栈顶到栈底的<br>object[] array = stack.ToArray();<br>for(int i = 0; i &lt; array.Length; i++)&#123;<br>    Console.WriteLine(array[i]);<br>&#125;<br><br>// 第三种方法：循环弹栈<br>while(stack.Count&gt;0)&#123;<br>    objetc o = stack.Pop();<br>    Console.WirteLine(o);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-5-装箱拆箱"><a href="#2-5-装箱拆箱" class="headerlink" title="2.5.装箱拆箱"></a>2.5.装箱拆箱</h5><p>由于是用万物之父来存储数据，自然存在装箱拆箱；当往其中进行值类型存储时候就是在装箱；当将值类型对象取出来转换使用时候，就存在拆箱。</p><h4 id="3-Queue"><a href="#3-Queue" class="headerlink" title="3.Queue"></a>3.Queue</h4><h5 id="3-1-Queue的本质"><a href="#3-1-Queue的本质" class="headerlink" title="3.1.Queue的本质"></a>3.1.Queue的本质</h5><p>Queue是一个C#为我们封装好的类，它的本质也是object[]数组，只是封装了特殊的存储规则。</p><p>Queue是队列存储容器，队列是一种先进先出的数据结构，先存入的数据先获取，后存入的数据后获取。</p><p>Queue(队列)的特点<em>*</em>：先进先出，后进后出</p><h5 id="3-2-Queue的申明"><a href="#3-2-Queue的申明" class="headerlink" title="3.2.Queue的申明"></a>3.2.Queue的申明</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C#">// 使用Queue队列需要引用其命名空间 System.Collections<br>Queue queue = new Queue();<br></code></pre></td></tr></table></figure><h5 id="3-3-Queue的增删查清空"><a href="#3-3-Queue的增删查清空" class="headerlink" title="3.3.Queue的增删查清空"></a>3.3.Queue的增删查清空</h5><p>增：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C#">// 进队<br>Queue queue = new Queue();<br>queue.Enqueue(1);<br>queue.Enqueue(&quot;123&quot;);<br>quueue.Enqueue(1.4f);<br>queue.Enqueue(new Test());<br></code></pre></td></tr></table></figure><p>取：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C#">// 出队<br>// 队列中不存在删除的概念<br>// 队列中只存在取的概念，取出先加入的对象<br>object v =queue.Dequeue();<br>Console.WriteLine(v);<br>v = queue.Dequeue();<br>Console.WriteLine(v);<br></code></pre></td></tr></table></figure><p>查：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C#">// 1.查看队列头部元素但是不会移除<br>v = queue.Peek();<br>Console.WriteLine(v);<br><br>// 2.查看元素是否存在于队列当中,如果存在返回true,不存在返回false<br>if(queue.Contains(1.4f))&#123;<br>    Console.WriteLine(&quot;存在&quot;);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>清空：（队列和栈一样，因为没有实现索引器的功能，是无法删除指定元素和修改元素的，如果想要修改，只能先清空之后，再重新存入修改后的值）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#">queue.Clear();<br></code></pre></td></tr></table></figure><h5 id="3-4-Queue的遍历"><a href="#3-4-Queue的遍历" class="headerlink" title="3.4.Queue的遍历"></a>3.4.Queue的遍历</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C#">// Queue(队列)和Stack(栈)很相似，而且因为Queue没有索引器，所以我们是无法通过for循环直接用中括号“[]”的方式遍历得到其元素的。<br>// 第一种遍历方式：用foreach遍历<br>foreach(object item in queue)&#123;<br>    Console.WriteLine(item);<br>&#125;<br><br>// 第二种遍历方式：将队列转换为object数组<br>object[] array = queue.ToArray();<br>for(int i = 0;i&lt;array.Length;i++)&#123;<br>    Console.WriteLine(array[i]);<br>&#125;<br><br>// 循环出列<br>while(queue.Count&gt;0)&#123;<br>    object o = queue.Dequeue();<br>    Console.WriteLine(o);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3-5-Queue的装箱拆箱"><a href="#3-5-Queue的装箱拆箱" class="headerlink" title="3.5.Queue的装箱拆箱"></a>3.5.Queue的装箱拆箱</h5><p>由于是用万物之父来存储数据，自然存在装箱拆箱；当往其中进行值类型存储时候就是在装箱；当将值类型对象取出来转换使用时候，就存在拆箱。</p><h4 id="4-Hashtable"><a href="#4-Hashtable" class="headerlink" title="4.Hashtable"></a>4.Hashtable</h4><h5 id="4-1-Hashtable的本质"><a href="#4-1-Hashtable的本质" class="headerlink" title="4.1.Hashtable的本质"></a>4.1.Hashtable的本质</h5><p>Hashtable（又称散列表）是基于键的哈希代码组织起来的键/值对，它的主要作用是提高数据查询的效率，使用键来访问集合中的元素</p><h5 id="4-2-Hashtable的申明"><a href="#4-2-Hashtable的申明" class="headerlink" title="4.2.Hashtable的申明"></a>4.2.Hashtable的申明</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C#">// 使用Hashtable需要引入其命名空间 Sysytem.Collections<br>Hashtable hashtable = new Hashtable();<br></code></pre></td></tr></table></figure><h5 id="4-3-Hashtable的增删查改"><a href="#4-3-Hashtable的增删查改" class="headerlink" title="4.3.Hashtable的增删查改"></a>4.3.Hashtable的增删查改</h5><p>增：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C#">// 参数1 键, 参数2 值<br>// 下面的语句意思：整型 1 代表键, &quot;123&quot;代表值<br>hashtable.Add(1, &quot;123&quot;);<br>// 下面的语句意思：“123”代表键, 整型 2 代表值<br>hashtable.Add(&quot;123&quot;, 2);<br>// 下面的语句意思：true代表键, false代表值<br>hashtable.Add(true, false);<br>// 下面的语句意思：false代表键, false代表值<br>hashtable.Add(false, false);<br>// ***注意：不能出现相同的键，但是可以是相同的值(也就是不同的键存储了相同的值)<br></code></pre></td></tr></table></figure><p>删（散列表的删除只能通过键去删除，无法通过值去删除，即使传入了一个值也会被当成传入键去操作）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C#">// 1.只能通过键删除<br>// ***注意：通过键移除，不代表只移除键对应的值，而且一对键值对一起被移除了<br>// 把原本hashtable.Add(1, &quot;123&quot;);这对键值对”一起“移除<br>hashtable.Remove(1);<br><br>// 2.删除不存在的键——没反应<br>// ***注意：我们删除不存在的键是不会报错的，也不会有任何的操作反馈<br>hashtable.Remove(123123);<br><br>// 3.清空<br>hashtable.Clear();<br></code></pre></td></tr></table></figure><p>查：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C#">// 1.通过键查看值，找不到会返回空(不会报错,返回值为空)<br>// ***注意：散列表里面是不存在下标概念的，”[]“里面写入的是代表键<br>Console.WriteLine(hashtable[1]);<br>Console.WriteLine(hashtable[&quot;123123&quot;]);<br>Console.WriteLine(hashtable[true]);<br><br>// 2.查看是否存在<br>// 通过键去查找是否存在，存在返回值为true，不存在返回false,两个方法的作用都是一样的<br>if(hashtable.Contains(&quot;2&quot;))&#123;<br>    Console.WriteLine(&quot;存在键位2的键值对&quot;);<br>&#125;<br>if(hashtable.ContainsKey(&quot;2&quot;))&#123;<br>    Console.WriteLine(&quot;存在键为2的键值对&quot;);<br>&#125;<br>// 通过值去查找是否存在，存在返回true，不存在返回false<br>if(hashtable.ContainsValue(12))&#123;<br>    Console.WriteLine(&quot;存在值为12的键值对&quot;);<br>&#125;<br></code></pre></td></tr></table></figure><p>改（改只能改键对应的值内容，无法修改键）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C#">hashtable[1] = 100.5f<br>Console.WriteLine(hashtable[1]);<br></code></pre></td></tr></table></figure><h5 id="4-4-Hashtable的遍历"><a href="#4-4-Hashtable的遍历" class="headerlink" title="4.4.Hashtable的遍历"></a>4.4.Hashtable的遍历</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C#">// 得到散列表里面存储元素的数量<br>// ***注意：这个得到是键值对的对数<br>Console.WriteLine(hashtable.Count);<br><br>// 第一种遍历方法：遍历所有键<br>foreach(object item in hashtable.Keys)&#123;<br>    // 打印它的键<br>    Console.WriteLine(item);<br>    // 打印键对应的值<br>    Console.WriteLine(hashtable[item]);<br>&#125;<br><br>// 第二种遍历方法：遍历所有的值<br>foreach(object item in hashtable.Values)&#123;<br>    Console.WriteLine(item);<br>&#125;<br><br>// 第三种遍历方法：键值对一起遍历<br>// DictionaryEmtry按F12进去就会发现是一个结构体，结构体里面存了一个键，一个值<br>foreach(DictionaryEntry item in hashtable)&#123;<br>    Console.WriteLine(&quot;键：&quot; + item.Key + &quot; 值：&quot; + item.Value);<br>&#125;<br><br>// 第四种遍历方法：迭代器遍历法<br>IDictionaryEnumerator myEnumerator = hashtable.GetEnumerator();<br>bool flag = myEnumerator.MoveNext();<br>while(flag)&#123;<br>    Console.WriteLine(&quot;键：&quot; + myEnumerator.Key + &quot;值：&quot; + myEnumerator.Value);<br>    flag = myEnumerator.MoveNext();<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="4-5-装箱拆箱"><a href="#4-5-装箱拆箱" class="headerlink" title="4.5.装箱拆箱"></a>4.5.装箱拆箱</h5><p>由于是用万物之父来存储数据，自然存在装箱拆箱；当往其中进行值类型存储时候就是在装箱；当将值类型对象取出来转换使用时候，就存在拆箱。</p><h3 id="二-泛型"><a href="#二-泛型" class="headerlink" title="二.泛型"></a>二.泛型</h3><h4 id="1-泛型的知识"><a href="#1-泛型的知识" class="headerlink" title="1.泛型的知识"></a>1.泛型的知识</h4><h5 id="1-1-什么是泛型"><a href="#1-1-什么是泛型" class="headerlink" title="1.1.什么是泛型"></a>1.1.什么是泛型</h5><p>泛型实现了类型参数化，达到代码重用的目的，通过类型参数化来实现同一份代码上的多种类型操作。</p><p>泛型相当于类型占位符，定义类或方法时候使用替代符代表变量类型，当真正使用类或者方法时候再具体指定类型。</p><h5 id="1-2-泛型的分类"><a href="#1-2-泛型的分类" class="headerlink" title="1.2.泛型的分类"></a>1.2.泛型的分类</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs C#">// 泛型的分类就两种 泛型类和泛型接口<br>// 基本语法<br>class 类名&lt;泛型占位字母&gt;<br>// 举例：下面就是一个泛型类<br>class Test1&lt;T&gt;&#123;<br>    public T value;<br>&#125;<br>// 当我们要用这个类的时候，我们需要在申明跟初始化的时候去告诉我们的编译器它的泛型是什么类型<br>// 举例：下面就是一个泛型类的使用<br>// 我们把泛型指定为了int类型，这时候我们Test里面的成员value就是一个int类型的字段了<br>Test&lt;int&gt; test = new Test&lt;int&gt;();<br><br>// 我们把泛型指定为了string类型，这时候我们Test里面的成员value就是一个string类型的字段了<br>Test&lt;string&gt; test = new Test&lt;string&gt;();<br>// ***总结：我们可以很明显的看到了，我们声明的泛型类可以满足我们的不同需求，一份代码可以多次重用，这是泛型类最大的特点<br><br>interface 接口名&lt;泛型占位字母&gt;<br>// 举例：下面就是一个泛型接口的使用<br>interface TestInterface&lt;T&gt;&#123;<br>    T value&#123;<br>        get;<br>        set;<br>    &#125;<br>&#125;<br>// 接着我们再让我们的Test2类继承这个接口<br>// 我们可以看到，当我们继承了某个泛型接口的时候，这时候我们是需要指定这个泛型的具体类型的<br>class Test2:TestInterface&lt;int&gt;&#123;<br>    <br>&#125;<br>// *注意：泛型接口一样可以拥有多个泛型占位字母<br><br>// 泛型函数<br>// 基本语法：函数名&lt;泛型占位字母&gt;(参数列表)<br>// 举例：下面就是一个有一个参数的泛型函数<br>public void Func&lt;T&gt;(T t1)&#123;<br>    <br>&#125;<br>// ***注意：泛型占位字母可以有多个，用逗号分开<br>// 举例：下面这个泛型方法<br>public void Func2&lt;K, V&gt;(K k1, V v1)&#123;<br>    <br>&#125;<br>// 类和接口也是一样的<br>class Test3&lt;T1, T2, K, M LL, Key Value&gt;&#123;<br>    public T1 value;<br>    public T2 value;<br>    public K value;<br>    public MM value;<br>    public LL value;<br>    public Key value;<br>    public Value value;<br>&#125;<br><br>// *注意：泛型占位字母/泛型占位符不单单只是“T”，还可以是任意的字母，只要是写在尖括号“&lt;&gt;”里面的字母，都算是泛型占位符<br></code></pre></td></tr></table></figure><h5 id="1-3-泛型方法"><a href="#1-3-泛型方法" class="headerlink" title="1.3.泛型方法"></a>1.3.泛型方法</h5><h6 id="1-普通类中的泛型方法"><a href="#1-普通类中的泛型方法" class="headerlink" title="1.普通类中的泛型方法"></a>1.普通类中的泛型方法</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs C#">class Test2&#123;<br>    // 下面是普通类中泛型方法的申明<br>    public void TestFun&lt;T&gt;(T value)&#123;<br>        Console.WriteLine(value);<br>    &#125;<br>    <br>    // 你也可以使用我们的无参泛型方法<br>    // ***注意：泛型方法也是方法，所以它是支持函数重载的。<br>    public void TestFunc&lt;T&gt;()&#123;<br>        // 泛型方法的内部去处理一些逻辑<br>        // 例如得到我们类型的默认值<br>        T t = default(T);<br>    &#125;<br>    <br>    // 我们还可以利用泛型做一些特殊的返回值<br>    public T TestFunc&lt;T&gt;(string value)&#123;<br>        return default(T);<br>    &#125;<br>    <br>    // 同理泛型方法也是可以有多个泛型占位符的<br>public void Func3&lt;T1, T2, T3&gt;(T1 t1, T2 t2, T3 t3)&#123;<br>        <br>    &#125;<br>&#125;<br><br>// 接下来看如何使用我们申明的泛型方法<br>class Program&#123;<br>    static void Main(string[] args)&#123;<br>        // 第一步，先申明跟实例化我们的类<br>        Test2 test2 = new Test2();<br>        // 第二部，使用我们的泛型方法，先把泛型占位符指定为具体的类型，然后再填写函数参数<br>        test2.TestFun&lt;string&gt;(“123”);<br>       <br>        // ***注意:当我们有多个泛型方法的时候，我们是可以省略尖括号“&lt;&gt;”的方式，以直接传参数的方式，让编辑器自己去根据我们的参数类型确认调用哪个泛型方法，例如我们的函数重载一样。<br>        // 举例子：我们的类中有一个是泛型方法但是参数是string类型的TestFunc&lt;T&gt;(string value)，还有一个是TestFunc&lt;T&gt;(T t1)<br>        // 我们直接调用方法，并且传入一个字符串，这时候编辑器会默认调用我们的TestFunc&lt;T&gt;(string value)方法<br>        // 我可以运行后，把鼠标放在下面这个语句上，然后按F12定位到它调用的函数，这样也可以找到我们调用了哪个泛型函数<br>        test2.TestFunc(&quot;123&quot;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="2-泛型类中的泛型方法"><a href="#2-泛型类中的泛型方法" class="headerlink" title="2.泛型类中的泛型方法"></a>2.泛型类中的泛型方法</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C#">// ***注意：class Test&#123;&#125;和class Test&lt;T&gt;虽然看似是同名类，但是他们是不一样的类，你可以把&lt;T&gt;也看作类名的一部分来看。<br>// class Test&#123;&#125;是普通类，class Test&lt;T&gt;&#123;&#125;是泛型类，功能是也是不同的，所以是不一样的两个类，互不相关。<br>class Test&lt;T&gt;&#123;<br>    public T value;<br>    <br>    // ***注意：这个不叫泛型方法，因为T是泛型类申明的时候就指定，在使用这个函数的时候，我们就不能再去动态的变化了<br>    // 那么什么是泛型方法？简单的说就是函数名后面带着一对尖括号“&lt;&gt;”的我们就可以当作是泛型方法<br>public void TestFun(T t)&#123;<br>    <br>&#125;<br>&#125;<br><br>// 使用<br>class Program&#123;<br>    static void Main(stringp[] args)&#123;<br>        // 泛型类，我们再申明和实例化的时候就需要指定我们的具体类型了<br>        Test&lt;int&gt; test = new Test&lt;int&gt;();<br>        // 调用泛型类中的方法的时候就不需要去指定了，直接调用。<br>        test.TestFun();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="1-4-总结"><a href="#1-4-总结" class="headerlink" title="1.4.总结"></a>1.4.总结</h5><p>1.申明泛型时，它只是一个类型的占位符</p><p>2.泛型真正起作用的时候，是在使用它的时候</p><p>3.泛型占位字母可以有n个用逗号分开</p><p>4.泛型占位字母一般是大写字母</p><p>5.不确定泛型类型时获取默认值可以使用default(占位字母)</p><p>6.看到&lt;&gt;的字母那肯定是泛型</p><h6 id="泛型的选择和作用"><a href="#泛型的选择和作用" class="headerlink" title="*泛型的选择和作用"></a>*泛型的选择和作用</h6><p>1.让不同类型对象的相同逻辑处理就可以选择泛型</p><p>2.使用泛型可以一定程度上避免装箱拆箱</p><h6 id="举例：优化我们的ArrayList"><a href="#举例：优化我们的ArrayList" class="headerlink" title="举例：优化我们的ArrayList"></a>举例：优化我们的ArrayList</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C#">// 我们知道，ArrayList是一个object类型的数组组成，所以它是存在装箱拆箱的问题了，但是如果我们自己利用泛型重新一个ArrayList就可以达到我们优化的效果<br>class ArrayList&lt;T&gt;&#123;<br>    private T[] array;<br>    public void Add(T value)&#123;<br>        <br>    &#125;<br>    public void Remove(T value)&#123;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-泛型的约束"><a href="#2-泛型的约束" class="headerlink" title="2.泛型的约束"></a>2.泛型的约束</h4><h5 id="2-1-什么是泛型约束"><a href="#2-1-什么是泛型约束" class="headerlink" title="2.1.什么是泛型约束"></a>2.1.什么是泛型约束</h5><p>让泛型的类型有一定的限制</p><p>关键字：where</p><p>泛型约束一共有6种</p><p>1.值类型                                                            where 泛型字母：struct</p><p>2.引用类型                                                        where 泛型字母：class</p><p>3.存在无参公共构造函数                                 where 泛型字母：new()</p><p>4.某个类本身或者其派生类                             where 泛型字母：类名</p><p>5.某个接口的派生类型                                     where 泛型字母：接口名</p><p>6.另一个泛型类型本身或者派生类型              where 泛型字母：另一个泛型字母</p><p>基本语法：where 泛型字母：约束的类型</p><h5 id="2-2-各种泛型的约束讲解"><a href="#2-2-各种泛型的约束讲解" class="headerlink" title="2.2.各种泛型的约束讲解"></a>2.2.各种泛型的约束讲解</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C#">// 1.值类型约束<br>// 这样就代表了T一定是一个结构体，因为结构体是值类型(这里肯定会有疑问，那如果不是结构体呢？我传入int、float这类值类型还可以吗？下面的使用案例会有解释)<br>class Test&lt;T&gt; where T:struct&#123;<br>    public T value;<br>    // 这样代表泛型方法的泛型字母K也是一个值类型类型<br>    public void TestFunc&lt;K&gt; where K:struct&#123;<br>        <br>&#125;<br>&#125;<br>// 使用<br>class Program&#123;<br>    static void Main(string[] args)&#123;<br>        // 使用案例<br>        // 大家会发现只要是值类型的都可以，那为什么上面我会说是T一定是一个结构体呢？我们可以把光标点一下int或者float然后按F12进入看看int和float的实现源码<br>        // 当我们对int按下F12进去的时候，我们进入了<br>        // public readonly struct Int32 : IComparable, IComparable&lt;Int32&gt;, IConvertible, IEquatable&lt;Int32&gt;, IFormattable&#123;.....&#125;<br>        // 说明int真正的名字是int32，int只是int32的别名，它前面struct表示了int32是一个结构体，说明int类型本身就是一个结构体，同理的，也可以对float进行同样的操作，float的真正名字是Single,float是别名，它也是一个结构体类型。<br>        // 为了避免产生疑问，我们之前学的结构体，算是自定义结构体的统称，其实只要是是值类型的实现，它的本身就是一个结构体。<br>        Test&lt;int&gt; test = new Test&lt;int&gt;();<br>        Test&lt;float&gt; test2 = new Test&lt;&gt;(float);<br>        test.TestFunc&lt;int&gt;();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C#">// 2.引用类型约束<br>// 泛型必须是引用类型<br>class Test2&lt;T&gt; where T:class&#123;<br>    public T value;<br>    public void TestFun&lt;K&gt;(K k) where K:class&#123;<br>        <br>    &#125;<br>&#125;<br>class Program<br>    &#123;<br>        static void Main(string[] args)<br>        &#123;<br>            // 使用案例<br>            Test2&lt;Random&gt; test = new Test2&lt;Random&gt;();<br>            test.TestFun&lt;object&gt;();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C#">// 3.公共无参构造约束<br>// 这个表示我们的泛型指定类型必须一个具有“公共”“无参”构造函数，两个条件缺一不可<br>// ***注意：结构体也满足此条件，如果有疑问可以接着往下看<br>class Test3&lt;T&gt; where T:new()&#123;<br>    public T value;<br>    public void TestFun&lt;K&gt;() where K:new()&#123;<br>        <br>&#125;<br>&#125;<br>// 为了方便测试，我们再写一个用于测试的类<br>class Test4&#123;<br>  // 当我们没有写任何构造函数的时候，会默认调用自带的公共无参构造函数<br>  // 一定不能是私有类型或者保护类型！必须是public类型<br>  // ***注意：当我们自己写了一个构造函数的时候，会顶掉我们的默认构造函数；如果我们写了一个无参的构造函数，其实意义不大就跟默认的公共构造函数的作用是一样的。但是一定记住，只要写了我们自己的构造函数之后，该类就会失去其原有的默认的公共无参构造函数。<br>&#125;<br>// 使用案例<br>class Program<br>    &#123;<br>        static void Main(string[] args)<br>        &#123;<br>            // 因为我们Test4里面自带了默认的公共无参构造函数，所以下面这条语句没问题<br>            // ***注意：当是我们不可以传入一个抽象类，因为抽象类是无法被实例化创建的。<br>            Test3&lt;Test4&gt; test = new Test3&lt;Test4&gt;();<br>            <br>            <br>            // ***注意：我们学过结构体也明白，结构体也是可以写构造函数的<br>            // 我们是可以写入一个结构体类型的，因为结构体也具有无参构造函数<br>            Test3&lt;int&gt; test3 = new Test3&lt;&gt;(int);<br>            <br>            // ***注意：再提醒一下，结构体和类不一样，类中我们是可以写显式的无参构造函数的，但是在结构体中，我们是无法在其中写一个不带参数的无参公共构造函数的，这是因为编译器不允许的(为什么不被允许，可以自行Google，因为解释起来麻烦，具体的为什么在Unity中结构体无法作为等式的左值进行赋值修改，例如:this.transform.position.x = 10f，为什么不被允许，也是跟结构体和编辑器有关，可以自行Google。)，其次，注意一点，如果我们一定想在结构体中写构造函数的化，我们是必须实现其全部成员的带参构造函数，也就是说，我们的必须对其所有成员变量进行初始化。说到这里，再提醒一点，结构中声明的字段是不允许被初始化的(自行Google).<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C#">// 4.某个类本身或者其派生类<br>class Test1&#123;<br>    <br>&#125;<br><br>class Test2:Test1&#123;<br>    <br>&#125;<br>// where T:类名约束的内容是该类型必须是该类名本身或者其派生类<br>// 下面约束的就是该类型必须是Test1本身这个类或者其子类Test2<br>class Test&lt;T&gt; where T:Test1&#123;<br>    <br>&#125;<br>class Program<br>    &#123;<br>        static void Main(string[] args)<br>        &#123;<br>            // 使用案例<br>Test&lt;Test1&gt; test1 = new Test&lt;Test1&gt;();<br>        Test&lt;Test2&gt; test2 = new Test&lt;&gt;(Test2);<br>        // 注意传入的必须是这个类或者其子类，如果是这个类的父类是不允许的，会报错的，例如我们传入万物之父Object类，编辑器是会报错误的。<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs C#">// 5.接口约束<br>interface IFly&#123;<br>    void Fly();<br>&#125;<br><br>interface IJump:IFly&#123;<br>    <br>&#125;<br><br>class Test2:IFly&#123;<br>    // 这一行不需要管，因为我们继承了接口就需要实现接口的方法<br>    public void Fly()<br>    &#123;<br>        // 这一行不需要管，这里是抛出没有逻辑内容错处<br>        throw new NotImplementedException();<br>    &#125;<br>&#125;<br>// 接口约束，是指定类型是某个接口的派生类型<br>class Test&lt;T&gt; where T:IFly&#123;<br>    <br>&#125;<br>// 使用案例            <br>class Program<br>    &#123;<br>        static void Main(string[] args)<br>        &#123;<br>            // 只要是接口本身或者其派生接口或者是继承至接口的普通类都可以传入<br>            Test&lt;Test2&gt; test = new test&lt;Test2&gt;();<br>            Test&lt;IFly&gt; test2 = new Test4&lt;IFly&gt;();<br>            Test&lt;IJump&gt; test3 = new Test4&lt;IJump&gt;();<br>        <br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C#">// 6.另一个泛型约束<br>class Test1&#123;<br>    <br>&#125;<br><br>class Test2 : Test1&#123;<br>    <br>&#125;<br><br>class Test&lt;T, U&gt; where T:U&#123;<br>  <br>&#125;<br><br>class Program<br>    &#123;<br>        static void Main(string[] args)<br>        &#123;<br>            // 这里有点绕，我们拆开来看<br>            // 我们把U先替换成Test1，这时候原本的class Test&lt;T, Test1&gt;where T : Test1&#123;&#125;是不是变成了，我们对类名的约束，也就是说，这时候剩下的泛型占位字母T要么是这个Test1类，要么是其子类<br>            Test&lt;Test2, Test1&gt; test = new Test&lt;Test2, Test1&gt;();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h5 id="2-3-约束的组合使用"><a href="#2-3-约束的组合使用" class="headerlink" title="2.3.约束的组合使用"></a>2.3.约束的组合使用</h5><p>举个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C#">// 这里相当于我们约束了泛型占位字母T的类型必须是引用类型且拥有公共无参的构造函数<br>// ***注意：这里的class和new()两个约束条件是能倒过来，先写new()再写class的，因为，我们是现先有了类，才能有构造函数的<br>class Test&lt;T&gt; where T:class, new()&#123;<br>    <br>&#125;<br>// 给个建议：泛型约束的组合使用根据排列组合可以拥有很多种组合方式，这里不一一的列举，我们可以在编辑器是自行尝试，只要是编辑器不报错误都算是一种约束的组合。<br></code></pre></td></tr></table></figure><h5 id="2-4-多个泛型有约束"><a href="#2-4-多个泛型有约束" class="headerlink" title="2.4.多个泛型有约束"></a>2.4.多个泛型有约束</h5><p>举个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C#">// 注意：多个泛型的约束是一个空格隔开，几个泛型字母就写几个where关键字，不要乱加逗号、冒号<br>class Test&lt;T, K&gt; where T:class, new() where K:struct&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>泛型约束：让类型有一定限制</p><p>泛型约束的分类：class、struct、new()、类名、接口名、另一个泛型字母</p><p>注意：</p><p>1.可以组合使用</p><p>2.多个泛型约束用where连接即可</p><h5 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h5><p>(以下内容，是我学习之余，收藏总结前人与网络上各大神分享再去结合我个人对单例模式的理解与思考做出来的结果，如果需要了解原文，附链接：<a href="https://www.cnblogs.com/zszh/p/10755256.html；https://blog.csdn.net/weixin_38531633/article/details/108975868，感谢各大大佬的分享才有开源的环境">https://www.cnblogs.com/zszh/p/10755256.html；https://blog.csdn.net/weixin_38531633/article/details/108975868，感谢各大大佬的分享才有开源的环境</a>)</p><h6 id="1-如何利用泛型写一个简单普通的单例基类？"><a href="#1-如何利用泛型写一个简单普通的单例基类？" class="headerlink" title="1.*如何利用泛型写一个简单普通的单例基类？"></a>1.*如何利用泛型写一个简单普通的单例基类？</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs C#">//以下代码是 不支持私有的无参构造函数的单例泛型(总结的时候会说明)<br>using System;<br>/// &lt;summary&gt;<br>/// 简单的单例模式基类<br>/// &lt;/summary&gt;<br>/// &lt;typeparam name=&quot;T&quot;&gt;待指定的泛型类型，该类型约束了必须是带有公共无参构造函数的&lt;/typeparam&gt;<br>public class SingleBase&lt;T&gt; where T : new()<br>&#123;<br>    // 把单例模式私有化，不允许外面修改<br>    private static T instance = new T();<br><br>    // 写一个私有的构造无参构造函数，防止外面实例化单例基类<br>    private SingleBase()<br>    &#123; <br><br>    &#125;<br><br>    // 通过属性中的get方法得到单例<br>    public static T GetInstance<br>    &#123;<br>        get<br>        &#123;<br>            return instance;<br>        &#125;<br>    &#125;<br>&#125;<br>// 总结<br>// 注意该单例是有缺陷的，因为继承了这个单例基类的子类是必须带有公共无参构造函数的，因为是public的，所以可以在外部实例化这个单例，但是众所周知，单例是不因该被初始化的，所以这里还可以进行进一步的优化。<br>// 总结该单例基类特点：<br>// 1：where 约束：引用类型/值类型<br>// where T:class 是 引用类型约束，使用class关键字<br>// 引用类型约束将一个类型形参限定为引用类型。<br>// 引用类型一般是用户定义的类型,包含类/接口/委托/字符串和数组类型。<br>// 在这个where子句中,class关键字是指定T必须是引用类型。因此,尝试对T使用值类型,将会导致编译错误。<br>// where T:struct 是 值类型约束，使用struct关键字<br>// 值类型约束将一个类型形参限定为值类型。<br>// 值类型派生于System.ValueType类型。基元和结构都是值类型。<br>// 在该形式中,struct关键字指定T必须是值类型。因此,尝试对T使用引用类型,将导致编译错误。<br><br>// 2：where 约束：new()注意：*【new不支持私有的无参构造函数】(这里也是我们第一种该单例的缺陷，后面会讲如何优化)<br>// 使用new()约束时应当注意:<br>// 1.new()约束可以与其他约束一起使用,但必须位于约束列表的末端<br>// 2.new()约束仅允许开发人员使用无参数的构造函数构造一个对象,<br>//即使同时存在其他的构造函数也是如此。即不允许给类型形参的构造<br>// 函数传递实参。<br>// 3.不可以同时使用new()约束和值类型约束。因为值类型都隐式的提<br>// 供了一个无参公共构造函数。<br>// 就如同定义接口时指定访问类型为public一样,编译器会报错,因为接口一定是public的。<br></code></pre></td></tr></table></figure><h6 id="2-如何利用泛型写一个多线程的泛型单例基类-带锁线程可释放-？"><a href="#2-如何利用泛型写一个多线程的泛型单例基类-带锁线程可释放-？" class="headerlink" title="2.*如何利用泛型写一个多线程的泛型单例基类(带锁线程可释放)？"></a>2.*如何利用泛型写一个多线程的泛型单例基类(带锁线程可释放)？</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs C#">// 以下代码是 不支持私有的无参构造函数的单例泛型(总结的时候会说明)<br>class Singleton&lt;T&gt; where T: class,new()  <br>&#123;  <br>    // 定义一个静态变量来保存类的实例<br>    private static T _instance; <br>    // 定义一个标识确保线程同步<br>    private static readonly object syslock=new object();  <br>  <br>    /// &lt;summary&gt;<br>    /// 定义公有方法提供一个全局访问点,<br>    /// 同时你也可以定义公有属性来提供全局访问点<br>    /// &lt;/summary&gt;<br>    /// &lt;returns&gt;&lt;/returns&gt;<br>    public static T getInstance()   <br>    &#123;  <br>        // 当第一个线程运行到这里时，此时会对locker对象 &quot;加锁&quot;，<br>        // 当第二个线程运行该方法时，<br>        /// 首先检测到locker对象为&quot;加锁&quot;状态，<br>        /// 该线程就会挂起等待第一个线程解锁<br>        /// lock语句运行完之后（即线程运行完之后）<br>        /// 会对该对象&quot;解锁&quot;<br>        // 双重锁定只需要一句判断就可以了<br>        if (_instance == null)  <br>        &#123;  <br>            lock (syslock) &#123;  <br>                // 如果类的实例不存在则创建，否则直接返回<br>                if (_instance == null)  <br>                &#123;  <br>                //T如果没有约束new() 这里是不允许new的<br>                    _instance = new T();  <br>                &#125;  <br>            &#125;  <br>        &#125;  <br>       return _instance;  <br>    &#125;  <br>&#125; <br>// 总结<br>// 该单例父类的具有第一种的所有特点，且双重线程锁，更加安全<br></code></pre></td></tr></table></figure><h6 id="3-如何写出一个“完美的”单例基类-支持私有的无参构造函数的单例泛型-？"><a href="#3-如何写出一个“完美的”单例基类-支持私有的无参构造函数的单例泛型-？" class="headerlink" title="3.如何写出一个“完美的”单例基类(支持私有的无参构造函数的单例泛型)？"></a>3.如何写出一个“完美的”单例基类(支持私有的无参构造函数的单例泛型)？</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C#">public class BaseInstance&lt;T&gt; where T : class//new()，new不支持非公共的无参构造函数 <br>    &#123;<br>        /*<br>         * 单线程测试通过！<br>         * 多线程测试通过！<br>         * 根据需要在调用的时候才实例化单例类！<br>          */<br>        private static T _instance;<br>        private static readonly object SyncObject = new object();<br>        public static T Instance<br>        &#123;<br>            get<br>            &#123;<br>                if (_instance == null)//没有第一重 singleton == null 的话，每一次有线程进入 GetInstance()时，均会执行锁定操作来实现线程同步，<br>                //非常耗费性能 增加第一重singleton ==null 成立时的情况下执行一次锁定以实现线程同步<br>                &#123;<br>                    lock (SyncObject)<br>                    &#123;<br>                        if (_instance == null)//Double-Check Locking 双重检查锁定<br>                        &#123;<br>                            //_instance = new T();<br>                            //需要非公共的无参构造函数，<br>                            //不能使用new T() ,new不支持非公共的无参构造函数 <br>                            _instance = (T)Activator.CreateInstance(typeof(T), true); <br>                            //第二个参数防止异常：“没有为该对象定义无参数的构造函数。”<br>                        &#125;<br>                    &#125;<br>                &#125;<br>                return _instance;<br>            &#125;<br>        &#125;<br>        public static void SetInstance(T value)<br>        &#123;<br>            _instance = value;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h6 id="4-C-在Unity中的写一个完善的单例基类"><a href="#4-C-在Unity中的写一个完善的单例基类" class="headerlink" title="4.*C#在Unity中的写一个完善的单例基类"></a>4.*C#在Unity中的写一个完善的单例基类</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C#">using System;<br>using UnityEngine;<br><br>public class SingletonProvider&lt;T&gt; where T : class ,new()<br>&#123;<br>    private SingletonProvider()<br>    &#123;<br>    &#125;<br><br>    private static T _instance;<br>    // 用于lock块的对象<br>    private static readonly object _synclock = new object();<br><br>    public static T Instance<br>    &#123;<br>        get<br>        &#123;<br>            if (_instance == null)<br>            &#123;<br>                lock (_synclock)<br>                &#123;<br>                    if (_instance == null)<br>                    &#123;<br>                        // 若T class具有私有构造函数,那么则无法使用SingletonProvider&lt;T&gt;来实例化new T();<br>                        _instance = new T();<br>                        //测试用，如果T类型创建了实例，则输出它的类型名称<br>                        Debug.Log(&quot;&#123;0&#125;：创建了单例对象&quot; + typeof(T).Name);<br>                    &#125;<br>                &#125;<br>            &#125;<br>            return _instance;<br>        &#125;<br>        set &#123; _instance = value; &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="5-如何写出一个性能上更好，更人性化更完善的ArrayList或者我们其他的自定义的数据结构"><a href="#5-如何写出一个性能上更好，更人性化更完善的ArrayList或者我们其他的自定义的数据结构" class="headerlink" title="5.*如何写出一个性能上更好，更人性化更完善的ArrayList或者我们其他的自定义的数据结构?"></a>5.*如何写出一个性能上更好，更人性化更完善的ArrayList或者我们其他的自定义的数据结构?</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#"><br></code></pre></td></tr></table></figure><h3 id="三-常用泛型数据结构类"><a href="#三-常用泛型数据结构类" class="headerlink" title="三.常用泛型数据结构类"></a>三.常用泛型数据结构类</h3><h4 id="数据结构的概念"><a href="#数据结构的概念" class="headerlink" title="数据结构的概念"></a>数据结构的概念</h4><p>数据结构是计算机存储、组织数据的方式(规则)，数据结构是指相互之间存在一种或者多种特定关系的数据元素的集合，比如自定义的一个类也可以称为一种数据结构，自己定义其数据组合规则</p><p>常用的数据结构：数组、栈、队列、链表、树、图、堆、散列表(哈希表)</p><h4 id="1-List"><a href="#1-List" class="headerlink" title="1.List"></a>1.List</h4><h4 id="2-Dictionary"><a href="#2-Dictionary" class="headerlink" title="2.Dictionary"></a>2.Dictionary</h4><h4 id="3-顺序存储和链式存储"><a href="#3-顺序存储和链式存储" class="headerlink" title="3.顺序存储和链式存储"></a>3.顺序存储和链式存储</h4><h5 id="3-1线性表"><a href="#3-1线性表" class="headerlink" title="3.1线性表"></a>3.1线性表</h5><p>线性表是一种数据结构，是由n个具有相同特性的数据元素以有限且有序的连接起来的序列，例如：数组、ArrayList、Stack、Queue、链表等等。</p><p>顺序存储和链式存储是数据结构中两种存储结构</p><h5 id="3-2顺序存储"><a href="#3-2顺序存储" class="headerlink" title="3.2顺序存储"></a>3.2顺序存储</h5><p>常见的顺序存储：数组、Stack、Queue、List、ArrayList</p><p>顺序存储的特点：用一组地址连续的存储单元依次存储线性表的各个数据元素。（所以我们是无法动态扩容的，只能声明与初始化一个比原来更大的数据结构，然后改变原来的引用）</p><h5 id="3-3链式存储"><a href="#3-3链式存储" class="headerlink" title="3.3链式存储"></a>3.3链式存储</h5><p>常见的链式存储：单向链表、双向链表、循环链表</p><p>链式存储(连接存储)：用一组任意的存储单元存储线性表中的各个数据元素</p><h5 id="3-4实现我们自己的链表"><a href="#3-4实现我们自己的链表" class="headerlink" title="3.4实现我们自己的链表"></a>3.4实现我们自己的链表</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#">// 简单的单向链表<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#">// 简单的双向链表<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#">// 循环链表<br></code></pre></td></tr></table></figure><h5 id="3-5顺序存储和链式存储的优缺点"><a href="#3-5顺序存储和链式存储的优缺点" class="headerlink" title="3.5顺序存储和链式存储的优缺点"></a>3.5顺序存储和链式存储的优缺点</h5><p>增：链式存储计算上优于顺序存储（中间插入时链式不用像顺序一样去移动位置）</p><p>删：链式存储计算上优于顺序存储（中间删除时链式不用像顺序一样去移动位置）</p><p>查：顺序存储使用上优于链式存储（数组可以直接通过下标得到元素，链式需要遍历）</p><p>改：顺序存储使用上优于链式存储（数组可以直接通过下标得到元素，链式需要遍历）</p><h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><p>顺序存储：内存中用一组连续的存储单元存储的线性表</p><p>链式存储：内存中用一组不连续的存储单元存储的线性表</p><h4 id="4-LinkedList"><a href="#4-LinkedList" class="headerlink" title="4.LinkedList"></a>4.LinkedList</h4><h5 id="4-1LinkedList概念"><a href="#4-1LinkedList概念" class="headerlink" title="4.1LinkedList概念"></a>4.1LinkedList概念</h5><p>LinkedList是一个C#为我们封装好的类，它的本质是一个可变类型的泛型双向链表。</p><h5 id="4-2LinkedList的申明"><a href="#4-2LinkedList的申明" class="headerlink" title="4.2LinkedList的申明"></a>4.2LinkedList的申明</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C#">// 需要引入命名空间 using System.Collections.Generic<br>LinkedList&lt;int&gt; linkedList = new LinkedList&lt;int&gt;();<br>// 掌握LinkedList类链表对象需要掌握两个类，一个是链表本身LinkedList，还有一个是链表节点类LinkedNode<br></code></pre></td></tr></table></figure><h5 id="4-3LinkedList的增删查改"><a href="#4-3LinkedList的增删查改" class="headerlink" title="4.3LinkedList的增删查改"></a>4.3LinkedList的增删查改</h5><p>增：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C#">// 1.在链表尾部添加元素<br>linkedList.AddLast(10);<br><br>// 2.在链表头部添加元素<br>linkedList.AddFirst(20);<br><br>// 3.在某一个节点之后添加一个节点<br>// 我们需要指定节点之前要先得到一个节点<br>// 举例：我们要在20的后面插入一个15，那么，我门要先找到我们存储了20的节点，然后再添加进去<br>LinkedListNode&lt;int&gt; n = linkedList.Find(20);<br>// 参数1 查找的指定节点位置， 参数2 要存储的节点的值(这里我们不需要自己new 一个新节点，我们直接传入我们需要的值就行)<br>linkedList.AddAfter(n, 15);<br><br>// 4.在某一个节点之前添加一个节点<br>// 我们需要在指定节点之前先得到一个节点<br>// 与3同理<br>LinkedListNode&lt;int&gt; n = linkedList.Find(20);<br>linkedList.AddAfter(n, 11);<br></code></pre></td></tr></table></figure><p>删：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C#">// 1.移除头节点<br>linkedList.RemoveFirst();<br><br>// 2.移除尾节点<br>linkedList.RemoveLast();<br><br>// 3.移除指定节点(但是我们是无法通过下标位置直接移除的)<br>linkedList.Remove(20);<br><br>// 4.清空<br>linkedList.Clear();<br></code></pre></td></tr></table></figure><p>查：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C#">// 1.头节点<br>LinkedListNode&lt;int&gt; first = linkedList.First;<br><br>// 2.尾节点<br>LinkedListNode&lt;int&gt; last = linkedList.Last;<br><br>// 3.找到指定值的节点(无法直接通过下标位置获取中间元素，只有遍历查找指定位置元素)<br>LinkedListNode&lt;int&gt; node = linkedList.Find(3);<br>node = linkedList.Find(5);<br><br>// 4.判断是否存在<br>if(linkedList.Contains(1))&#123;<br>    Console.WriteLine(&quot;链表中存在1&quot;);<br>&#125;<br></code></pre></td></tr></table></figure><p>改：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C#">// 需要先得到要改的节点，再去改变其中的值<br>// 举例：我们要改头节点的值<br>linkedList.First.Value = 10;<br></code></pre></td></tr></table></figure><h5 id="4-4LinkedList的遍历"><a href="#4-4LinkedList的遍历" class="headerlink" title="4.4LinkedList的遍历"></a>4.4LinkedList的遍历</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C#">// 1.foreach遍历<br>// 这里做一些解释，为什么我们不需要声明节点而是直接声明int就可以得到链表的值。因为在底层编辑器用迭代器的方式帮我处理了，所以我们可以直接访问到其中的值。(迭代器具体后面有迭代器讲解)<br>foreach(int item in linkedList)&#123;<br>    Console.WriteLine(item);<br>&#125;<br><br>// 2.通过节点遍历<br>// 从头到尾遍历<br>LinkedListNode&lt;int&gt; headNode = linkedList.First;<br>while(headNode != null)&#123;<br>   Console.WriteLine(headNode.Value);<br>   headNode = headNode.Next;<br>&#125;<br>// 从尾到头遍历<br>LinkedListNode&lt;int&gt; headNode = linkedList.Last;<br>while(headNode != null)&#123;<br>   Console.WriteLine(headNode.Value);<br>   headNode = headNode.Previous;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-泛型栈和队列"><a href="#5-泛型栈和队列" class="headerlink" title="5.泛型栈和队列"></a>5.泛型栈和队列</h4><h5 id="5-1回顾数据容器"><a href="#5-1回顾数据容器" class="headerlink" title="5.1回顾数据容器"></a>5.1回顾数据容器</h5><h6 id="变量："><a href="#变量：" class="headerlink" title="变量："></a>变量：</h6><p>无符号</p><p>byte ushort uint ulong</p><p>有符号</p><p>sbyte short int long</p><p>浮点数</p><p>float double decimal</p><p>特殊</p><p>char(<em>*</em>注意：C#中char类型是占两个字节，C与C++中是占一个字节) bool string</p><h6 id="复杂数据容器："><a href="#复杂数据容器：" class="headerlink" title="复杂数据容器："></a>复杂数据容器：</h6><p>枚举 enum，结构体 struct， 数组(一维[]，二维[,]， 交错”[] []”[][])，类</p><h6 id="数据集合："><a href="#数据集合：" class="headerlink" title="数据集合："></a>数据集合：</h6><p>using System.Collections下的数据结构：</p><p>ArrayList(object数据列表)，Stack(栈，先进后出)，Queue(先进先出)，Hash table(哈希表，键值对)</p><p>这类特殊数据结构的优点：它们都是Object基类的数组，说明它们任何引用类型都可以存储(除了自定义类且不继承object或者其派生类)，相当于一个大杂烩的容器，我们不需要指定特定的类型。</p><p>这类特殊数据结构的缺点：可能存在装箱拆箱的问题(核心有做解释)。</p><h6 id="泛型数据集合："><a href="#泛型数据集合：" class="headerlink" title="泛型数据集合："></a>泛型数据集合：</h6><p>using System.Collections.Generic下的泛型数据集合：</p><p>List(列表，泛型队列)，Dictionary(字典，泛型哈希表)，LinkedList(双向链表)，Stack(泛型栈)，Queue(泛型队列)。</p><p><em>*</em>注意：Object的数据集合(数据结构)我们会很少去使用，一般常用都是泛型数据集合，根据需求选择合适的泛型数据结构。</p><h5 id="5-2泛型栈和队列"><a href="#5-2泛型栈和队列" class="headerlink" title="5.2泛型栈和队列"></a>5.2泛型栈和队列</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C#">// 命名空间 using System.Collections.Generic;<br>// 使用上和之前学习过的栈和队列是一模一样的，所以这里就只做基本语法<br>Stack&lt;int&gt; stack  = new Stack&lt;int&gt;();<br>// 增(压栈)<br>stack.Push();<br>// 删(弹栈)<br>stack.Pop();<br>// 查<br>// ***注意：栈是无法查看指定位置的元素(因为栈是没有实现索引器的功能)，只能查看栈顶的内容<br>// 只是查看栈顶的内容，却不取出来<br>// 第一种：查看栈顶的值，无法取出<br>stack.Peek();<br>// 第二种：查看元素是否存在于队列当中,如果存在返回true,不存在返回false<br>stack.Contains();<br>// 清空<br>stack.Clear();<br>Queue&lt;int&gt; queue = new Queue&lt;int&gt;();<br>// 增(进队)<br>queue.Enqueue();<br>// 删(出队)<br>// 队列中不存在删除的概念<br>// 队列中只存在取的概念，取出先加入的对象<br>queue.Dequeue();<br>// 查<br>// 第一种：查看头部元素是否存在其值<br>queue.Peek();<br>// 第二种：查看元素是否存在于队列当中,如果存在返回true,不存在返回false<br>queue.Contains();<br>// 清空<br>queue.Clear();<br></code></pre></td></tr></table></figure><h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p>简单的总结一下我们常见存储容器如何选择使用：</p><h6 id="普通线性表："><a href="#普通线性表：" class="headerlink" title="普通线性表："></a>普通线性表：</h6><p>数组，List，LinkedList;</p><p>数组：固定的不变的一组数据</p><p>List：经常改变，经常通过下标查找</p><p>LinkedList：不确定长度的，经常临时插入改变，查找不多</p><h6 id="先进后出："><a href="#先进后出：" class="headerlink" title="先进后出："></a>先进后出：</h6><p>Stack：对于一些可以利用先进后出存储特定的逻辑</p><p>比如：UI面板显隐规则</p><h6 id="先进先出："><a href="#先进先出：" class="headerlink" title="先进先出："></a>先进先出：</h6><p>Queue：对于一些可以利用先进先出存储特点的逻辑</p><p>比如：消息队列</p><h6 id="键值对："><a href="#键值对：" class="headerlink" title="键值对："></a>键值对：</h6><p>Dictionary：需要频繁查找的，有对应关系的数据</p><p>比如：一些数据存储，id对应数据内容</p><p>道具ID ——-&gt; 道具信息</p><p>怪物ID ——-&gt; 怪物对象</p><p><em>*</em>注意：我们的Dictionary还常常用于对象池子的使用。</p><h3 id="四-委托和事件"><a href="#四-委托和事件" class="headerlink" title="四.委托和事件"></a>四.委托和事件</h3><h4 id="1-委托"><a href="#1-委托" class="headerlink" title="1.委托"></a>1.委托</h4><h5 id="1-1委托是什么？"><a href="#1-1委托是什么？" class="headerlink" title="1.1委托是什么？"></a>1.1委托是什么？</h5><p>委托是函数(方法)的容器，可以理解为表示函数(方法)的变量类型，用来存储、传递函数(方法)。委托的本质是一个类，用来定义函数(方法)的类型(返回值和参数的类型)，不同的函数(方法)必须对应和各自”格式”一致的委托。</p><p><em>*</em>注意：我们时刻要记住委托变量是函数的容器！！！！</p><h5 id="1-2基本语法"><a href="#1-2基本语法" class="headerlink" title="1.2基本语法"></a>1.2基本语法</h5><p>关键字：delegate</p><p>语法：访问修饰符 delefate 返回值 委托名(参数列表)；(我们可以抽象记忆，委托就是函数的命名方法再加上一个delegate的关键字)</p><p>写在哪里？</p><p>一般可以什么在namespace和class语句块中，但是更多的是写在namespace中。</p><h5 id="1-3如何定义自定义委托"><a href="#1-3如何定义自定义委托" class="headerlink" title="1.3如何定义自定义委托?"></a>1.3如何定义自定义委托?</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C#">// 访问修饰默认不写，则为public，中别的命名空间中也可以使用<br>// private 其他命名空间就不能用了，一般使用public<br>//这里申明了一个可以用来存储无参无返回值函数的容器<br>// 现在这里只是定义了规则，并没有使用<br>delegate void Fun();<br>// ***注意：(在同一语句块中)委托不存在同名的两个委托，编辑器会报错误的，它不是函数不能重载<br>delegate int Fun2(int a);// 表示用来装载或者传递返回值为int 有一个int参数的函数的委托容器规则<br></code></pre></td></tr></table></figure><h5 id="1-4如何使用定义好的委托？"><a href="#1-4如何使用定义好的委托？" class="headerlink" title="1.4如何使用定义好的委托？"></a>1.4如何使用定义好的委托？</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs C#">// ***注意：委托变量是函数的容器<br>// 首先先说明一点，委托的本质是一个类，下面的示例会是完整的可以运行代码<br>namespace Csharp进阶笔记<br>&#123;<br>    <br>// 委托的本质是一个类，直接声明在namespace与class之间，当然也可以在namespace之外或者class之内声明委托<br>    delegate void Func();<br>    // 申明了一个带int类型参数且返回值类型为int的委托<br>    delegate int void Func2(int i);<br>    class Program<br>    &#123;<br>        static void Main(string[] args)<br>        &#123;<br>            // 委托的存储函数<br>            // 第一种：委托的实例化(***注意：委托不具有0个参数的构造函数，所以我们的实例化必须传入参数)<br>            // 专门用来装载函数的容器，这时候我们只是装载了还没有调用函数<br>            // ***注意：我们存储的函数不需要加&quot;()&quot;，加(表示取调用它了)，我们这里只是需要存起来，不是需要取调用它的<br>            Func fun = new Func(Fun);<br>            <br>            // 第二种<br>            // 我们可以直接用赋值的方式给委托赋值<br>            // 这里我们也是只需要函数名，不需要&quot;()&quot;，加了&quot;()&quot;就表示调用这个函数了。<br>            Func fun2 = Fun;<br>            // ***注意：只有符合规则的函数才可以存进我们申明好了的委托中，例如我们上面申明了一个无参无返回值的委托，那么存储的函数就必须也是无参无返回值的函数 <br>            <br>            // 委托的调用(相当于函数的调用)<br>            // 第一种<br>            fun.Invoke();<br>            // 第二种<br>            fun();<br>            <br>            // 演示带参数带返回值的委托怎么存储和调用<br>            Func2 func3 = Func3;<br>            func3(10);<br>            func3.Invoke(20);<br>        &#125;<br>        static void Fun()<br>        &#123;<br>Console.WriteLine(&quot;Fun&quot;);<br>        &#125;<br>        static void Fun2()&#123;<br>            Console.WriteLine(&quot;Fun2&quot;);<br>        &#125;<br>        static int Fun3(int value)&#123;<br>            return value;<br>        &#125;<br>    &#125;<br>    <br>    // 委托以经常用在：<br>    // 1.作为类的成员<br>    // 2.作为函数的参数<br>    class Test&#123;<br>        public Func fun;<br>        public Func2 fun2;<br>        <br>        public void TestFun(Func func, Func2 func2)&#123;<br>            // 我们会在调用委托之前处理许多的游戏有逻辑<br>            // ......（处理的逻辑）<br>            // 然后调用我们的委托<br>            fun();<br>            fun2();<br>            <br>            // 当然我们也可以存进来，然后自己选择执行<br>            // this.fun = func<br>            // this.fun2 = func2<br>        &#125;<br>    &#125;<br>&#125;<br>// 注意：我们在使用的时候是传入我们的函数名字，不要!不要！不要!加括号。<br>// 举例：<br>// Test t = new Test();<br>// t.TestFun(函数名，函数名);一定不要加括号！！！！<br></code></pre></td></tr></table></figure><h5 id="1-5委托变量可以存储多个函数-多播委托"><a href="#1-5委托变量可以存储多个函数-多播委托" class="headerlink" title="1.5委托变量可以存储多个函数(多播委托)"></a>1.5委托变量可以存储多个函数(多播委托)</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C#">// 记住：委托是函数的容器<br>// 我们的委托是可以存储多个符合委托规则的函数<br>// 增加<br>Func fun = new fun(Fun);<br>fun += Fun2;<br>// 这时候两个函数都会被调用<br>fun.Invoke();<br>public void Fun()&#123;<br>    <br>&#125;<br>public void Fun2()&#123;<br>    <br>&#125;<br>// 我们也可以先让委托容器为空，再有+=方式添加<br>// Func fun = null;<br>// fun += Fun;<br>// fun += Fun2;<br><br>// 删除<br>// 删除的方式很简单，原理跟加是相似的，只是区别是把“+”换成“-”<br>// ***注意：多减是不会报错的，无非是找不到然后不做任何处理<br>fun -= Fun;<br><br>// 清空委托容器<br>fun = null;<br>// ***注意：委托为空的时候，我们是不能去调用的，如果运行了，是控制台会闪退，然后编辑器报错。所以我们委托调用之前最好的方式是进行判空。<br>if(fun != null)&#123;<br>    fun.Invoke();<br>&#125;<br>// 这里介绍一种语法糖 fun?.Invoke();（自行Google）<br></code></pre></td></tr></table></figure><h5 id="1-6系统定义好的委托"><a href="#1-6系统定义好的委托" class="headerlink" title="1.6系统定义好的委托"></a>1.6系统定义好的委托</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C#">// 需要引入命名空间 using System;<br>// 1. Action-----无参无返回值的委托<br>Action action = null;<br><br>// 2.Func&lt;T&gt;-----泛型委托(一个可以根据泛型指定返回值类型的泛型无参委托)<br>Fction func = null;<br>// 我们也可以定义我们自己的泛型委托<br>delegate T MyFunc&lt;T, K&gt;(T t, K k);<br><br>// 3.Action&lt;&gt;-----这是一个可以传最少1个最多16个不同类型参数的无返回值委托<br>Action&lt;int, string, bool&gt; action2 = null;<br><br>// 4.Func&lt;&gt;-----可以传n(1-15)个参数的并且有返回值的委托，系统提供了16种重载<br>// 这个委托就表示了带有一个int类型参数的返回值为int类型的委托容器<br>Func&lt;int, int&gt; func2 = null;<br><br>// 系统也会提供其他的委托，但是这里这四类足够我们日常的使用了<br></code></pre></td></tr></table></figure><h4 id="2-事件"><a href="#2-事件" class="headerlink" title="2.事件"></a>2.事件</h4><h5 id="2-1事件是什么"><a href="#2-1事件是什么" class="headerlink" title="2.1事件是什么?"></a>2.1事件是什么?</h5><p>事件是基于委托的存在，事件是委托的安全包裹，让委托的使用更具有安全性</p><p>事件是一种特殊的变量类型;</p><h5 id="2-2事件的使用"><a href="#2-2事件的使用" class="headerlink" title="2.2事件的使用"></a>2.2事件的使用</h5><p>申明语法：</p><p>访问修饰符 event 委托类型 事件名；</p><p>事件的使用:</p><p>1.事件是作为成员变量存在于类中</p><p>2.委托是怎么用,事件就怎么用</p><p>事件相对于委托的区别：</p><p>1.不能在类的外部赋值</p><p>2.不能在类外部调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs C#">class Test&#123;<br>    // 委托成员变量用于存储函数的<br>    public Action myFun;<br>    // 事件成员变量用于存储函数的<br>    public event Action myEvent;<br>    <br>    public Test()&#123;<br>        // 事件的使用和委托一模一样只是有些细微的区别<br>        myFun = TestFun;<br>        myFun += TestFun;<br>        myFun -= TestFun;<br>        myFun = null;<br>        myFun();<br>        MyFun.Invoke();<br>        <br>        myEvent = TestFun;<br>        myEvent += TestFun;<br>        myEvent -= TestFun;<br>        myEvent();<br>        myEvent.Invoke();<br>     meEvent = null;<br> <br>    &#125;<br>    public void TestFun()&#123;<br>        <br>    &#125;<br>&#125;<br><br>// 那么我们为什么还要学习事件Event呢?<br>// 首先我们要记住:<br>// 事件相对于委托的区别：<br>// 1.不能在类的外部赋值<br>// 2.不能在类外部调用<br><br>// 举例:<br>class Test2&#123;<br>    static void Main()&#123;<br>        Test t = new Test();<br>        // 我们会发现,我们的委托是可以在类的外部被点(.)出来使用的<br>        t.myFun = null;<br>        // 但是我们的Event不行,尽管它是Public的访问修饰符<br>        // Event能做的只能是在类的外部执行增(+=)和删(-=),不允许赋值操作<br>    <br>        <br>// 我们的委托是可以在类的外部被调用的<br>        t.myFun();<br>        t.myFun.Invoke();<br>        <br>        // 但是我们的事件Event是做不到的,如果我们需要调用Event是需要在类的内部进行封装方法的<br>// ***注意:事件是不能作为临时变量在函数中使用的,也就是我们在函数中是无法申明事件的,它只能作为成员存在于类\接口\结构体中,但是委托是可以的        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-3为什么有事件"><a href="#2-3为什么有事件" class="headerlink" title="2.3为什么有事件"></a>2.3为什么有事件</h5><p>1.防止外部随意置空委托</p><p>2.防止外部随意调用委托</p><p>3.事件相当于对委托进行了一次封装让其更安全</p><h4 id="3-匿名函数"><a href="#3-匿名函数" class="headerlink" title="3.匿名函数"></a>3.匿名函数</h4><h5 id="3-1什么是匿名函数"><a href="#3-1什么是匿名函数" class="headerlink" title="3.1什么是匿名函数"></a>3.1什么是匿名函数</h5><p>顾名思义,匿名函数就是没有名字的函数;匿名函数的使用主要是配合委托和事件进行使用的;脱离委托和事件是不会使用匿名函数的.</p><h5 id="3-2基本语法"><a href="#3-2基本语法" class="headerlink" title="3.2基本语法"></a>3.2基本语法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C#">delegate (参数列表)&#123;<br>    // 函数逻辑<br>&#125;;<br>// 何时使用?<br>// 1.函数中传递委托参数时<br>// 2.委托或者事件赋值时<br></code></pre></td></tr></table></figure><h5 id="3-3匿名函数的使用"><a href="#3-3匿名函数的使用" class="headerlink" title="3.3匿名函数的使用"></a>3.3匿名函数的使用</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs C#">// 1.无参无返回<br>// ***注意:我们是无法申明匿名函数的,匿名函数是无法脱离了委托和事件存在的,所以匿名函数申明必须作为委托或者事件的右值赋值给委托或者事件,而无法单独存在.<br>Action ac = delegate ()&#123;<br>Console.WriteLine(&quot;123&quot;);<br>&#125;;<br>// 执行匿名函数<br>ac();<br><br>//2.有参数<br>Action&lt;int ,string&gt; b = delegate (int a, string b)&#123;<br>    Console.WriteLine(a);<br>    Console.WriteLine(b);<br>&#125;;<br><br>//3.有返回值<br>Func&lt;string&gt; func = delegate ()&#123;<br>  return &quot;123123&quot;;  <br>&#125;;<br>// 执行<br>Console.WriteLine(func());<br><br>//4.一般情况会作为函数参数传递或者作为函数返回值<br>// 作为参数传递时<br>class Test&#123;<br>    public Action action;<br>    public void DoSomething(int a, Action fun)&#123;<br>       Console.WriteLine(a);<br>        fun();<br>    &#125;<br>    <br>    public Action GetFun()&#123;<br>        return delegate ()&#123;&#125;;<br>    &#125;<br>&#125;<br><br>class Test2&#123;<br>    static void Main()&#123;<br>        // 参数传递<br>        Test t = new Test();<br>        t.DoSomething(100, delegate ()&#123;<br>           Console.WriteLine(&quot;随着参数传入的匿名函数&quot;); <br>        &#125;);<br>        <br>        // 返回值<br>        Action ac = t.GetFun();<br>ac();<br>// 我们也可以直接一步到位<br>        // 我们先看前一半ac()返回了一个函数名,函数名＋后一半&quot;()&quot;相当于调用这个 函数<br>        ac()();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="3-4匿名函数的缺点"><a href="#3-4匿名函数的缺点" class="headerlink" title="3.4匿名函数的缺点"></a>3.4匿名函数的缺点</h5><p>添加到委托或者事件容器后,不记录下来的话,我们无法单独移除,因为我们的匿名函数没有函数名,所以唯一的方法是把委托或者事件容器全部清空才行.</p><h4 id="4-Lambda表达式"><a href="#4-Lambda表达式" class="headerlink" title="4.Lambda表达式"></a>4.Lambda表达式</h4><h5 id="4-1什么是Lambda表达式"><a href="#4-1什么是Lambda表达式" class="headerlink" title="4.1什么是Lambda表达式"></a>4.1什么是Lambda表达式</h5><p>Lambda表达式可以理解为匿名函数的简写形式，它除了写法上的不同外，使用上和功能上完全与匿名函数一模一样，优缺点也是一模一样的，同理，它也是需要配合委托或者事件使用的。</p><h5 id="4-2lambda表达式语法"><a href="#4-2lambda表达式语法" class="headerlink" title="4.2lambda表达式语法"></a>4.2lambda表达式语法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C#">(参数列表)=&gt;&#123;<br>    // 函数体<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="4-3lambda表达式的使用"><a href="#4-3lambda表达式的使用" class="headerlink" title="4.3lambda表达式的使用"></a>4.3lambda表达式的使用</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C#">// 1.无参无返回值<br>// ***注意：Lambda表达式是无法单独使用的，是需要配合委托或者事件使用的<br>Action ac = ()=&gt;&#123;<br>    <br>&#125;;<br><br>// 2.有参数无返回值<br>Action ac = (int value)=&gt;&#123;<br>    Console.WriteLine(value);<br>&#125;;<br><br>// 3.甚至参数类型都可以省略，只要参数类型和委托或事件容器一致的就行<br>// 因为我们通过泛型占位字母指定了我们的类型，所以我们可以省略参数类型<br>Action&lt;int&gt; ac = (value)=&gt;&#123;<br>    Console.WriteLine(value);<br>&#125;;<br><br>// 4.有返回值的<br>Func&lt;string, int&gt; ac = (value)=&gt;&#123;<br>  return &quot;123&quot;;  <br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="4-4-闭包"><a href="#4-4-闭包" class="headerlink" title="4.4 *闭包"></a>4.4 *闭包</h5><p>内层的函数可以引用包含在它外层的函数变量，即使外层函数的执行已经终止。</p><p>注意：该变量提供的值并非变量创建时的值，而是在父类函数范围内的最终值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C#">class Test&#123;<br>    public event Action action;<br>    public Test()&#123;<br>        int value = 10;<br>        // 这里我们就形成了一个闭包<br>        // 解释：因为value按道理它的生命周期就是构造函数被调用时候存在，一旦构造函数执行完，作为栈上的value会立马被回收，但是因为它现在是存储在了事件里面，所以这时候value的生命周期已经被改变了，它永远都不会被回收其内存(除非，当我们清空我们的事件容器的时候，也就是把event = null，否则它永远存在于内存中)。<br>        action = ()=&gt;&#123;<br>          Console.WriteLine(value);  <br>        &#125;;<br>    &#125;<br>    <br>    // 接下来我们需要理解这句话：“注意：该变量提供的值并非变量创建时的值，而是在父类函数范围内的最终值。”<br>    // 我们看一下以下代码：<br>    for(int i = 0; i&lt;10 ;i++)&#123;<br>        action += ()=&gt;&#123;<br>          Console.WriteLine(i);  <br>        &#125;;<br>    &#125;<br>    // 这时候，如果我们去action()，执行我们的事件，我们的控制台会出现哪种情况？是打印0-9还是打印10次9？<br>    // 打印会是打印10次9，为什么呢？理解一下我们的这句话“注意：该变量提供的值并非变量创建时的值，而是在父类函数范围内的最终值。”；<br>    // 解释：因为我们存储的是变量i,i在for循环中其值是改变的，也就是说我们事件中存储的i的值就是在变量的，那么它最终下来的值就是循环最后一次的i的值。<br>    // 接着问：如果我们想要打印0-9怎么办呢？<br>    // 下面代码：<br>    for(int i = 0; i&lt;10 ;i++)&#123;<br>        // int index = i;很关键！这是很关键的一句代码，因为我们在每次循环的时候，都在申明一个新的index,它于上一个for语句块的逻辑不一样，这里的index每一次循环都是新的index，每个index之间互无影响，没有联系，所以，我们事件中存储的index就是相当于申明了10个index变量存储每次循环过后i的值。这时候打印的结果就会是0-9。<br>        int index = i;<br>        action += ()=&gt;&#123;<br>          Console.WriteLine(index);  <br>        &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="五-List排序"><a href="#五-List排序" class="headerlink" title="五.List排序"></a>五.List排序</h3><h4 id="1-List排序"><a href="#1-List排序" class="headerlink" title="1.List排序"></a>1.List排序</h4><h5 id="1-1List自带排序方法"><a href="#1-1List自带排序方法" class="headerlink" title="1.1List自带排序方法"></a>1.1List自带排序方法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c#">// 需要引用命名空间 using System.Collections.Generic;<br>List&lt;int&gt; list = new List&lt;int&gt;();<br>// 如果我们不调用List自带的排序API那么就会按添加的顺序<br>list.Add(3);<br>list.Add(1);<br>list.Add(5);<br>for(int i = 0; i &lt; list.Count; i++)&#123;<br>    Console.WriteLine(list[i]);<br>&#125;<br><br>// 默认是升序排序<br>list.Sort();<br></code></pre></td></tr></table></figure><h5 id="1-2自定义类的排序"><a href="#1-2自定义类的排序" class="headerlink" title="1.2自定义类的排序"></a>1.2自定义类的排序</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs C#">class Item&#123;<br>    pirvate int money;<br>    public Item(int money)&#123;<br>        this.money = money;<br>    &#125;<br>&#125;<br><br>class Program&#123;<br>    static void Main()&#123;<br>        List&lt;Item&gt; itemList = new List&lt;Item&gt;();<br>    itemList.Add(new Item(45));<br>        itemList.Add(new Item(55));<br>        itemList.Add(new Item(10));<br>        itemList.Add(new Item(459));<br>// 首先，可以把下面这行代码的注释去了，大家运行一下，然后猜测一下，我会的List会帮我们排好顺序还是不会呢？<br>        // 答案是不会的，甚至我们一运行就报错了，对于自定义类，我们是无法通过List自带的API进行排序的。那为什么我们在上一个知识点上存储单独的int类型，我们却可以对int类型进行排序呢?我们可以把鼠标的光标点击一下int,再按下F12进去，我们发现，int类型是继承了IComparable&lt;Int32&gt;的泛型接口和IComparable非泛型接口，之所以int类型可以进行排序，就是它继承了这两个接口，实现了接口中的排序方法---int CompareTo();我们的Lits.Sort()就是通过调用这个方法进行的排序。<br>        // itemList.Sort();<br>         for(int i = 0; i&lt; itemList.Count; i++)&#123;<br> Console.WriteLine(itemList[i].money);<br>         &#125;<br>    &#125;<br>&#125;<br><br>// 实例：实现我们自定义类的排序<br>class Item : IComparable&lt;int&gt;&#123;<br>    public int money;<br>    public Item(int money)&#123;<br>        this.money = money;<br>    &#125;<br>    public int CompareTo(Item other)&#123;<br>        // 返回值的含义：<br>        // 1.果小于0：放在传入对象的前面<br>        // 2.等于0：保持当前位置不变<br>        // 3.大于0：放在传入对象后面<br>        <br>        // 我们先把传入对象的位置理解为就是零，如果返回 为负数就放在它左边，也就是前面；如果返回正数，就放在它的右边，也就是后面<br>        // 代码：<br>        if(this.money &gt; other.monet(<br>         return 1;<br>        )<br>        else&#123;<br>            return -1;<br>        &#125;<br>    &#125;<br>&#125;<br><br>class Program&#123;<br>    static void Main()&#123;<br>         List&lt;Item&gt; itemList = new List&lt;Item&gt;();<br>    itemList.Add(new Item(45));<br>        itemList.Add(new Item(55));<br>        itemList.Add(new Item(10));<br>        itemList.Add(new Item(459));<br>// 因为我们的Item类继承了比较的接口，我们也实现了接口的方法，这时候我们再执行排序的方法就不会报错了，而且会出现升序排列。<br>        // *注意：这里提醒一下，我们的Sort()排序不是说只要有CompareTo()方法然后不继承IComparabe就可以调用的，注意！我们的Sort()调用的基准是根据是否继承了IComparable来判断的，而非只是ComparareTo()方法。<br>        // 提醒一下：我们常用的接口都是用泛型接口，就像这个例子有两个接口一个是泛型的IComparable&lt;&gt;一个是IComparable，前者是泛型我们可以指定自己类型可以解决装箱拆箱的问题，后者的参数是一个object，我们如果需要调用参数中的某个成员就需要用里氏替换原则进行转换as成我们的类型再点(.)出我们的成员，很不方便，而且存在装箱拆箱的问题。<br>        itemList.Sort();<br>         for(int i = 0; i&lt; itemList.Count; i++)&#123;<br> Console.WriteLine(itemList[i].money);<br>         &#125;<br>    &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="1-3通过委托函数进行排序"><a href="#1-3通过委托函数进行排序" class="headerlink" title="1.3通过委托函数进行排序"></a>1.3通过委托函数进行排序</h5><p>如果我有一个自定义的类，但是我不希望我的类都需要去继承IComparable&lt;&gt;泛型接口实现CompareTo方法怎么办？</p><p>List.Sort();自身是提供了三种重载方法的，我们把鼠标的光标点击List然后按下F12，我们可以看见以下三种重载方法：</p><pre><code>      1. public void Sort(Comparison&lt;T&gt; comparison);      2. public void Sort(int index, int count, IComparer&lt;T&gt;? comparer);      3. public void Sort();</code></pre><p>我们对第一种进行重载，我们可以把鼠标光标定位到Comparison<T>上按下F12进去看看，我们会发现其实它的本质是一个委托，那么我们接下来就用我们自己的委托函数来重载我们的Sort()方法达到升序排列的目的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs C#">// 实例：<br>class ItemShop&#123;<br>    public int money;<br>    <br>    public ItemShop(int money)&#123;<br>        this.money = money;<br>    &#125;<br>&#125;<br><br>class Program&#123;<br>    void static Main()&#123;<br>        List&lt;ItemShop&gt; list = new List&lt;ItemShop&gt;();<br>    list.Add(new ItemShop(10));<br>        list.Add(new ItemShop(20));<br>        list.Add(new ItemShop(1));<br>        list.Add(new ItemShop(100));<br>// 这里我们如果不传入我们的委托函数是会报错的，运行直接奔溃        <br>        list.Sort(SortShopItem);<br>        // 我们也可以使用我们学过的匿名函数的方式<br>        // list.Sort(delegate SortShopItem(ItemShop a, ItemShop b)&#123;<br>        //  if(a.money &gt; b.money)&#123;<br>        //      return -1; <br>        //  &#125;<br>//  else&#123;<br>        //     return 1;<br>        //  &#125;        <br>   //  &#125;);<br>        <br>        // 同理，我们也可以使用Lambda表达式<br>        // list.Sort((a, b)=&gt;&#123;<br>        //  return a.money &gt; b.money ? -1 : 1;<br>   //  &#125;);<br>        <br>    &#125;<br>    <br>    public staic int SortShopItem(ItemShop a, ItemShop b)&#123;<br>        // 传入的两个对象为列表的中的两个对象<br>        // 进行两两的比较，用左边的和右边的条件比较<br>        // 返回值规则和上一个例子一样，0做标准，负数在左(前)正数在右(后)，最后结果成升序排序。<br>        if(a.money &gt; b.money)&#123;<br>           return -1; <br>        &#125;<br>else&#123;<br>            return 1;<br>        &#125;        <br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="六-协变逆变"><a href="#六-协变逆变" class="headerlink" title="六.协变逆变"></a>六.协变逆变</h3><h4 id="1-协变逆变"><a href="#1-协变逆变" class="headerlink" title="1.协变逆变"></a>1.协变逆变</h4><h5 id="1-1什么是协变逆变？"><a href="#1-1什么是协变逆变？" class="headerlink" title="1.1什么是协变逆变？"></a>1.1什么是协变逆变？</h5><p>协变：</p><p>简单的总结：协变就是和谐的变化，自然的变化。因为里氏替换原则父类可以装子类，所以子类变父类比如string变object是合理的和谐的。</p><p>逆变：</p><p>逆常规的变化，不正常的变化。因为里氏替换原则父类可以装子类，但是子类不能装父类的，所以父类变子类比如object 变成 string 感受是不和谐的。</p><p>协变和逆变是用来修饰泛型的</p><p>协变：out</p><p>逆变：in</p><p>用于在泛型中修饰泛型字母的，只有泛型接口和泛型委托能使用。</p><h5 id="1-2使用"><a href="#1-2使用" class="headerlink" title="1.2使用"></a>1.2使用</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C#">// 1.返回值和参数<br>// 用out修饰的泛型只能作为返回值<br>delegate T TestOut&lt;out T&gt;();<br><br>// 用in修饰的泛型只能作为参数<br>delegate T TestIn&lt;in T&gt;(T t);<br>// ***注意：协变out和逆变是只能在泛型接口和泛型委托中使用的<br><br>//  2.结合里氏替换原则理解<br>class Father&#123;<br>    <br>&#125;<br>class Son : Father&#123;<br>    <br>&#125;<br>class Program&#123;<br>    static void Main()&#123;<br>        // 协变<br>        TestOut&lt;Son&gt; os = ()=&gt;&#123;<br>          return new Son();  <br>        &#125;;<br>        // ***注意：如果我们把TestOut类中的out修饰符去掉，会报错误的，说明当我们加上了out之后，编译器会帮我们判断，这里是否符合里氏替换原则，符合就进行里氏替换原则进行了转换。<br>        TestOut&lt;Father&gt; of = os;// 这里我们相当于是用一个父类TestOut&lt;Father&gt;装载了一个子类TestOut&lt;Son&gt;，符合里氏替换原则的，是协变。<br>        // 这一行代码就证实了我们的os确实是转换为了Father，发生了里氏替换原则<br>        Father f = of();// 实际上返回的是os里面装的函数，返回的是Son<br>        <br>// 逆变<br>        TestIn&lt;Father&gt; iF = (value)=&gt;&#123;<br>            <br>        &#125;;<br>        TestIn&lt;Son&gt; iS = IF;// 这里我们相当于是用一个子类TestOut&lt;Son&gt;装载了一个父类TestOut&lt;父类&gt;，是不符合里氏替换原则的，是逆变。<br>        // 我们TestIn&lt;Son&gt;指定了泛型类型是一个Son类型，所以这里我们必须传入的是一个new Son()，如果我们传入的是一个Father()是会报错误的。<br>        iS(new Son());//实际上调用的是iF,而iF里面是一个TestIn&lt;Father&gt;，是个Father类型的，也就是说我们因该是要传入一个Father类型的。<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h5><p>协变：out</p><p>逆变：in</p><p>协变out和逆变in是用来修饰泛型替代符的，只能修饰接口和委托中的泛型</p><p>作用：</p><p>1.out修饰的泛型类型只能作为返回值类型，in修饰的泛型修饰符只能作为参数类型</p><p>2.遵循里氏替换原则，用out和in修饰的泛型委托可以相互装载（有父子关系的泛型）</p><p>协变：父类泛型委托装子类泛型委托</p><p>逆变：子类泛型委托装父类泛型委托</p><h3 id="七-多线程"><a href="#七-多线程" class="headerlink" title="七.多线程"></a>七.多线程</h3><h4 id="1-多线程"><a href="#1-多线程" class="headerlink" title="1.多线程"></a>1.多线程</h4><h5 id="1-1了解线程前先了解进程"><a href="#1-1了解线程前先了解进程" class="headerlink" title="1.1了解线程前先了解进程"></a>1.1了解线程前先了解进程</h5><p>进程(Process)是计算机中程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基本。</p><p>说人话：打开一个应用程序就是在操作系统上开启了一个进程，进程之间可以相互独立运行，互不干扰，进程之间也可以相互访问、操作。</p><h5 id="1-2什么是线程？"><a href="#1-2什么是线程？" class="headerlink" title="1.2什么是线程？"></a>1.2什么是线程？</h5><p>操作系统能够进行运算调度的最小单位。</p><p>它被包含在进程之中，是进程中的实际运作单位。</p><p>一条线程指的是一个进程中一个单一顺序的控制流，一个进程中可以并发多个线程，我们目前写的程序都在主线程中。</p><p>简单理解线程：就是代码从上到下运行的一条“管道”。</p><h5 id="1-3什么是多线程？"><a href="#1-3什么是多线程？" class="headerlink" title="1.3什么是多线程？"></a>1.3什么是多线程？</h5><p>我们可以通过代码开启新的线程，可以同时运行代码的多条“管道”就叫多线程。</p><h5 id="1-4语法相关"><a href="#1-4语法相关" class="headerlink" title="1.4语法相关"></a>1.4语法相关</h5><p>C#专门为我们提供了线程类 Thread</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs C#">// 我们需要引用命名空间 using System.Threading;<br>// 1.首先申明一个新的线程<br>// 注意：线程执行的代码需要封装到一个函数中<br>// 新线程将要执行的代码逻辑被封装到了一个函数语句块中<br>Thread t = new Thread(NewThreadLogic);<br>static void NewThreadLogic()&#123;<br>    // 新开线程执行的代码逻辑在该函数语句块内<br>    Console.WriteLine(&quot;新开的线程代码逻辑&quot;);<br>&#125;<br><br>// 2.启动线程<br>// 如果我们不启动线程，是不会执行我们封装好的函数内部的逻辑的<br>// 线程的开启<br>t.Start();<br><br>// 3.设置为后台线程<br>// 当前台线程都结束了的时候，整个程序也就结束了，即使还有后台线程正在运行。<br>// 后台线程不会防止应用程序的进程被终止掉，如果不设置为后台线程，可能导致进程无法正常关闭。<br>// ***解释一下：我们的主线程是我们的Main()函数，当我们Main()函数内部逻辑执行完了之后，我们的程序也因该就结束了，但是我们新开了一个新的线程它默认是前台线程，那么它是不会受我们的主线程控制的。<br>// 举例子：我们把我们新线程的封装函数改一下，改成下面这个<br>static void NewThreadLogic()&#123;<br>    while(true)&#123;<br>    // 新开线程执行的代码逻辑在该函数语句块内<br>    Console.WriteLine(&quot;新开的线程代码逻辑&quot;);<br>    &#125;<br>&#125;<br>// 这时候如果我们运行程序，我们会发现控制台会一直打印。看似是不是没有问题，毕竟我们写了一个死循环，但是请细细的思考，我们的主线程(main()函数)就两句代码语句，一句是新开一个新线程new Thread();另一句是启动线程t.Start();,到这里程序的生命周期就结束了，程序因该要结束了并且关闭了，但是我们却一直还在执行我们新线程的逻辑，导致阻塞了我们主线程的正常关闭。<br><br>// 那么如何设置成后台线程呢?<br>t.IsBackground = true;<br>// 这时候我们在运行一下，会发现控制台不在无限循环打印了，当主线程结束，新开的后台线程也结束了。<br>// 注意：两个线程是同时运行的，是互不干扰的，所以主线程运行的时候，我们的新线程也会运行。<br><br>// 4.关闭释放一个线程<br>// 如果开启的线程中不是死循环，是能够结束的逻辑，那么不用刻意的去关闭它。<br>// 如果开启的线程是死循环，想要中止这个线程，有两种方式<br>// 4.1.死循环中bool标识<br>我们可以在主线程中声明一个bool类型标识符，在执行的第一句为false,执行完了主线程的逻辑后，为true，作为新开线程处理死循环中的判断的条件。<br><br>// 4.2.通过线程提供的方法(注意在.Net core版本中无法中止，会报错误)<br>// 中止线程<br>t.Abort();<br>t = null;<br><br>// 5.线程休眠<br>// 让线程休眠多少毫秒<br>// 注意：在哪个线程里执行就休眠哪个线程<br>Thread.Sleep();// 里面传入的是毫秒<br></code></pre></td></tr></table></figure><h5 id="1-5线程之间共享数据"><a href="#1-5线程之间共享数据" class="headerlink" title="1.5线程之间共享数据"></a>1.5线程之间共享数据</h5><p>多个线程使用的内存是共享的，都属于该程序(进程)，所以要注意，当多线程同时操作同一片内存区域时候可能会出现问题，可以通过加锁的方式避免问题。</p><p>lock</p><p>当我们在多个线程当中想要访问同样的东西进行逻辑处理时候，为了避免不必要的逻辑顺序执行的差错。</p><p>lock(引用类型对象);</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs C#">// 例如我们在主线程中执行这样的代码：<br>While(true)&#123;<br>    Console.SetCursorPosition(0,0);<br>    Console.ForegroundColor = ConsoleColor.Red;<br>    Console.Write(&quot;a&quot;);<br>&#125;<br>// 然后我们在附属线程中执行这样的代码<br>While(true)&#123;<br>    Console.SetCursorPosition(15,15);<br>    Console.ForegroundColor = ConsoleColor.Red;<br>    Console.Write(&quot;c&quot;);<br>&#125;<br><br>// 如果我们不加锁的运行的话，那那么就可能造成当主线程运行到了第二条的语句的时候，附属线程执行了第三条语句，然后就在本该打印“a”的地方打印了“c”，在本该打印“c”的地方打印了“a”。因为线程是共享一片内存空间的，对于Console也是可以一起同时访问的。<br><br>//那么如何加锁呢?<br>我们的lock需要一个引用类型的参数，我们可以随便传入一个<br>Object o = new Object();<br>// 主线程中加锁：<br>While(true)&#123;<br>    lock(o)&#123;<br>    Console.SetCursorPosition(0,0);<br>    Console.ForegroundColor = ConsoleColor.Red;<br>    Console.Write(&quot;a&quot;);<br>&#125;    <br>&#125;<br>    <br>// 附属线程中加锁<br>While(true)&#123;<br>    lock(o)&#123;<br>    Console.SetCursorPosition(15,15);<br>    Console.ForegroundColor = ConsoleColor.Red;<br>    Console.Write(&quot;c&quot;);<br>    &#125;<br>    <br> // 解释一下：我们相当于对主线程和附属线程同时锁住了同一个引用类型object，那么当我们主线程先执行到lock()的时候，就会给object加锁，这时候附属线程执行到lock()的时候发现object已经上锁了，就会等到主线程的lock()内部逻辑执行完后，把object的锁释放了，才会再去执行附属线程的lock()内部的逻辑。<br>    <br> // 加锁的缺点：影响线程的效率，当我们的线程执行很快的时候，如果存在了锁，那要等到另一个线程把锁释放了，才能继续执行。<br> // 加锁的优点：解决了不同线程之间的共享一片内存，并对同一个区域操作时候会出现的问题。<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="1-6多线程对于我们的意义"><a href="#1-6多线程对于我们的意义" class="headerlink" title="1.6多线程对于我们的意义"></a>1.6多线程对于我们的意义</h5><p>可以用多线程专门处理一些复杂耗时的逻辑，例如：寻路、网络通信等等。</p><h3 id="八-预处理器指令"><a href="#八-预处理器指令" class="headerlink" title="八.预处理器指令"></a>八.预处理器指令</h3><h4 id="1-预处理器指令"><a href="#1-预处理器指令" class="headerlink" title="1.预处理器指令"></a>1.预处理器指令</h4><h5 id="1-1什么是编译器"><a href="#1-1什么是编译器" class="headerlink" title="1.1什么是编译器"></a>1.1什么是编译器</h5><p>编译器是一种翻译程序，它用于将源语言程序翻译为目标语言程序。</p><p>源语言程序：某种程序设计语言写成的，比如C#、C、C++、Java等语言写的程序。</p><p>目标语言程序：二进制数表示的伪机器代码写的程序。</p><h5 id="1-2什么是预处理器指令"><a href="#1-2什么是预处理器指令" class="headerlink" title="1.2什么是预处理器指令"></a>1.2什么是预处理器指令</h5><p>预处理器指令制导编译器在实际编译开始之前对信息进行预处理；</p><p>预处理器指令都是以#开始；</p><p>预处理器指令不是语句，所以它们不以分号；结束；</p><h5 id="1-3常见的预处理器指令"><a href="#1-3常见的预处理器指令" class="headerlink" title="1.3常见的预处理器指令"></a>1.3常见的预处理器指令</h5><p>一.</p><h1 id="define：定义一个符号，类似一个没有值的变量。"><a href="#define：定义一个符号，类似一个没有值的变量。" class="headerlink" title="define：定义一个符号，类似一个没有值的变量。"></a>define：定义一个符号，类似一个没有值的变量。</h1><h1 id="undef：取消define定义的符号，让其失效。"><a href="#undef：取消define定义的符号，让其失效。" class="headerlink" title="undef：取消define定义的符号，让其失效。"></a>undef：取消define定义的符号，让其失效。</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C#">// 预编译指令是写在我们using的上面<br>// 定义一个符号<br>#define Unity4<br>#define Unity5<br>#define Unity2017<br>#define Unity2018<br>#define Unity2019<br>// 取消定义一个符号<br>#undef Unity4<br></code></pre></td></tr></table></figure><p>二.</p><h1 id="if、-elif、-else、-endif和if语句规则一样，一般配合-define定义的符号进行使用，用于告诉编译器进行编译代码的流程控制。我们还可以通过逻辑“或”和逻辑“与”进行多种符号的组合判断。"><a href="#if、-elif、-else、-endif和if语句规则一样，一般配合-define定义的符号进行使用，用于告诉编译器进行编译代码的流程控制。我们还可以通过逻辑“或”和逻辑“与”进行多种符号的组合判断。" class="headerlink" title="if、#elif、#else、#endif和if语句规则一样，一般配合#define定义的符号进行使用，用于告诉编译器进行编译代码的流程控制。我们还可以通过逻辑“或”和逻辑“与”进行多种符号的组合判断。"></a>if、#elif、#else、#endif和if语句规则一样，一般配合#define定义的符号进行使用，用于告诉编译器进行编译代码的流程控制。我们还可以通过逻辑“或”和逻辑“与”进行多种符号的组合判断。</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C#">// 这里的意思是，如果发现我们定义了Unity4这个符号的话，那么其中包含的代码就会被编译器翻译<br>// 注意：如果我先定义了一个符号，然后又在下面用#undef取消定义的话也不会执行下面语句的<br>#if Unity4<br> Console.WriteLine(&quot;Unity4&quot;);<br>#endif<br><br>// 语法上基本是与if-else if- else是一样的<br>#if Unity4<br>    Console.WriteLine(&quot;Unity4&quot;);<br>#elif Unity2019<br>    Console.WriteLine(&quot;Unity2019&quot;);<br>#else<br>    Console.WriteLine(&quot;没有Unity&quot;);<br>#endif<br><br>// 配合逻辑“或”或者“与”的组合判断<br>#if Unity2018 &amp;&amp; IOS<br>    Console.WriteLine(&quot;符合要求的开发环境&quot;);<br>#else<br>    Console.WriteLine(&quot;不符合要求的开发环境&quot;);<br></code></pre></td></tr></table></figure><p>三.</p><h1 id="warning、-error：用于告诉编译器是报警告还是报错误，一般还是配合if使用。"><a href="#warning、-error：用于告诉编译器是报警告还是报错误，一般还是配合if使用。" class="headerlink" title="warning、#error：用于告诉编译器是报警告还是报错误，一般还是配合if使用。"></a>warning、#error：用于告诉编译器是报警告还是报错误，一般还是配合if使用。</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C#">#if Unity4<br>    Console.WriteLine(&quot;Unity4&quot;);<br>// 如果我们代码通过了我们的if逻辑判断的话，我们就会执行下面这个警告(注意：我们不需要按F11进入调式模式下就会报警告)<br>#warning 这个版本不合法<br>#elif Unity2019<br>    Console.WriteLine(&quot;Unity2019&quot;);<br>#else<br>    Console.WriteLine(&quot;没有Unity&quot;);<br>// 如果我们代码执行了最后的else的话，我们就会执行下面这个错误(注意：我们不需要按F11进入调式模式下就会报错误，这个时候的错误不是我们的语法错误也不是代码逻辑错误，就是我们的预处理指令报了一个错误，错误的内容就是我们写的内容)<br>#error 没有安装Unity！<br>#endif<br></code></pre></td></tr></table></figure><h5 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h5><p>预处理是让编译器在编译之前预先处理我们的预处理判断，我们常常用于Unity的版本，或者不同移动端的代码，例如IOS、Andorid、PC。</p><h3 id="九-反射和特性"><a href="#九-反射和特性" class="headerlink" title="九.反射和特性"></a>九.反射和特性</h3><h4 id="1-反射"><a href="#1-反射" class="headerlink" title="1.反射"></a>1.反射</h4><h5 id="1-1什么是程序集"><a href="#1-1什么是程序集" class="headerlink" title="1.1什么是程序集"></a>1.1什么是程序集</h5><p>程序集是经由编译器编译得到的，供进一步编译执行的之间产物。在WINDOWS系统中，它一般表现为后缀为.dll(库文件)或者.exe(可执行文件)的格式。</p><p>简单理解：程序集就是我们写的一个代码集合，我们现在写的所有代码最终都会被编译器翻译为一个程序集供给他人使用，比如一个代码库文件(dll)或者一个可执行文件(exe)。</p><h5 id="1-2元数据"><a href="#1-2元数据" class="headerlink" title="1.2元数据"></a>1.2元数据</h5><p>元数据就是用来描述数据的数据。这个概念不仅仅用于程序，在别的领域也有元数据。</p><p>简单理解：程序中的类，类中的函数，变量等等信息就是程序的元数据，有关程序以及类型的数据被称为元数据，它们保存在程序集中。</p><h5 id="1-3反射的概念"><a href="#1-3反射的概念" class="headerlink" title="1.3反射的概念"></a>1.3反射的概念</h5><p>程序正在运行时，可以查看其他程序集或者自身的元数据。一个正在运行的程序查看本身或者其他程序的元数据的行为就叫反射。</p><p>简单理解：在程序运行时候，通过反射可以得到其他程序集或者自己程序集代码的各种信息，例如：类、函数、变量、对象等等，实例化它们，执行它们，操作它们。</p><h5 id="1-4反射的作用"><a href="#1-4反射的作用" class="headerlink" title="1.4反射的作用"></a>1.4反射的作用</h5><p>因为反射可以在程序编译后获得，所以它提高了程序的拓展性和灵活性。</p><p>1.程序运行时得到所有元数据，包括元数据的特性</p><p>2.程序运行时，实例化对象，操作对象</p><p>3.程序运行时创建新对象，用这些对象执行任务</p><h5 id="1-5语法相关"><a href="#1-5语法相关" class="headerlink" title="1.5语法相关"></a>1.5语法相关</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><code class="hljs C#">class Test&#123;<br>    private int i = 1;<br>    public int j = 0;<br>    public string str = &quot;123&quot;;<br>    public Test()&#123;<br>        <br>    &#125;<br>    public Test(int i)&#123;<br>        this.i = i;<br>    &#125;<br>    public Test(int i, string str):this(i)&#123;<br>        this.str = str;<br>    &#125;<br>    public void Speak()&#123;<br>        Console.WriteLine(i);<br>    &#125;<br>&#125;<br><br>class Program&#123;<br>    static void Main()&#123;<br>        // 1.Type<br>        // Type(类的信息类)，它是反射功能的基础!它是访问元数据的主要方式。使用Type的成员获取有关类型声明的信息，有关类型的成员(如构造函数、方法、字段、属性和类的事件)<br>        <br>        // 2.获取Type<br>        //   2.1万物之父object中的GetType()可以获取对象的Type(对象的类型)<br>        int a = 42;<br>        Type type = a.GetType();<br>        Console.WriteLine(type);// 会打印System.Int32<br>        <br>        //   2.2通过typeof关键字传入类名也可以得到对象的Type<br>        Type type2 = typeof(int);<br>        Console.WriteLine(type2);// 会打印System.Int32<br>        //   2.3通过类或结构体的名字也可以获取类型<br>        //   注意：类名或者结构体名字必须包含命名空间，不然找不到<br>        //   如果这里我们不加命名空间的话：Type type3 = Type.GetType(&quot;Int32&quot;);只会打印空。<br>        Type type3 = Type.GetType(&quot;System.Int32&quot;);<br>        Console.WriteLine(type3);<br>        //   注意：虽然我们上面申明了三个Type类型的变量，但是它们的地址都是一样的，都指向了同一片内存空间，我们可以理解为我们的每个类都是唯一的，地址也是唯一的，所以每个Type指向的地址都是同一个地址。<br>        <br>        // 3.得到类的程序集信息<br>        Console.WriteLine(type.Assembly);<br>        <br>        // 4.获取类中的所有公共成员<br>        // 第一步：首先得到Type<br>        Type t = typeof(Test);<br>        // 第二步：得到所有公共公开的成员<br>        // 补充：需要引入命名空间 using System.Reflection;<br>        MemberInfo[] infos = t.GetMembers();<br>        for(int i = 0; i &lt; infos.Length; i++)&#123;<br>        // 最后：打印出反射内存储的公共公开的信息(包括我们的万物之父object中的基类的公开公共方法)<br>            Console.WriteLine(infos[i]);<br>        &#125;<br>        <br>        // 5.获取类的公共构造函数并调用<br>        // 5.1获取所有构造函数<br>        ConstructorInfo-= ctors = t.GetConstructors();<br>        for(int i = 0; i &lt; ctors.Length; i++)&#123;<br>            Console.WriteLine(ctor[i]);<br>        &#125;<br>        // 5.2获取其中一个构造函数并执行<br>        // 得到构造函数传入Type数组，数组中内容按顺序是参数类型<br>        // 执行构造函数传入object数组表示按顺序传入的参数<br>        // 5.2.1得到无参构造函数<br>ConstructorInfo info = t.GetConstructor(new Type[0]); // 这相当于得到了一个无参数的构造函数        <br>        info.Invoke(null); // 执行构造函数<br>        // 我们也可以通过里氏替换原则转换为Test<br>        Test obj = info.Invoke(null) as Test;<br>        // 5.2.2得到有参构造函数<br>ConstructorInfo info2 = t.GetConstructor(new Type[]&#123;typeof(int)&#125;);// 这里相当于得到了一个有一个参数，参数类型为int的构造函数<br>        obj = info2.Invoke(new object[]&#123;2&#125;) as Test;// 执行我们的构造函数；<br>        ConstructorInfo info3 = t.GetConstructor(new Type[]&#123;typeof(int), typeof(string)&#125;);// 这里相当于我们得到了一个带有两个参数，参数类型分别为int类型和string类型的构造函数<br>        obj = info3.Invoke(new object[]&#123;4, &quot;444444&quot;&#125;) as Test;<br>        <br>        // 6.获取类的公共成员变量<br>        // 6.1得到所有成员变量<br>        FieldInfo[] fieldInfos = t.GetFields();<br>        for(int i = 0; i &lt; fieldInfos.Length; i++)&#123;<br>            Console.WriteLine(fieldInfos[i]);<br>        &#125;<br>        // 6.2得到指定名称的公开公共成员变量<br>        FieldInfo infoJ = t.GetField(&quot;j&quot;);// 这里传入的字符串是代表我们的变量名字<br>        // 6.3 通过反射获取和设置对象的值<br>  Test test = new Test();// 这里我们新创建一个Test用于测试<br>        test.j = 99;<br>        test.str = &quot;1111&quot;;<br>        // 6.3.1通过反射获取对象的某个变量的值<br>Console.WriteLine(infoJ.GetValue(test));// 传入的参数是我们的类名<br>        // 6.3.2通过反射设置指定对象的某个变量的值<br>        infoJ.SetValue(test, 100);<br>        Console.WriteLine(infoJ.GetValue(test));<br>       <br>        <br>        <br>        // 7.获取类的公共成员方法<br>        // 通过Type类中的GetMethod方法得到类中的方法，MethodInfo是方法的反射信息<br>        Type strType = typeof(string);// 我们用string类型做实例<br>   // 1.如果存在方法重载，用Type数组表示参数类型<br>        MethodInfo[] methods = strType.GetMethods();<br>        for(int i = 0; i &lt; methods.Length; i++)&#123;<br>            Console.WriteLine(methods[i]);<br>        &#125;<br>        MethodInfo subStr = strType.GetMethod(&quot;Substring&quot;, new Type[]&#123;typeof(int), typeof(int)&#125;);<br>        // 2.调用该方法<br>        // 注意：如果是静态方法，Invoke中的第一个参数传null即可<br>        string str = &quot;Hello,World&quot;;<br>        // 第一个参数相当于是哪个对象要执行这个成员方法<br>        // 因为截取的方法是不会改变原有字符串的，所以这里我们必须新创建一个来接收新的字符串<br>        object result = subStr.Invoke(str, new object[]&#123;7,5&#125;);<br>        Console.WriteLine(result);<br>        <br>        // 8.其它<br>    // Type:<br>        // 得枚举：GetEnumName,GetEnumNames<br>        // 得事件：GetEvent,GetEvents<br>        // 得接口：GetInterface,GetInterfaces<br>        // 得属性：GetProperty,GetPropertys<br>        // 等等<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id=""><a href="#" class="headerlink" title=" "></a> </h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C#">// 首先，我们先写一个用于测试的类<br>class Test&#123;<br>    private int i = 1;<br>    public int j = 0;<br>    public string str = &quot;123&quot;;<br>    public Test()&#123;<br>        <br>    &#125;<br>    public Test(int i)&#123;<br>        this.i = i;<br>    &#125;<br>    public Test(int i, string str):this(i)&#123;<br>        this.str = str;<br>    &#125;<br>    public void Speak()&#123;<br>        Console.WriteLine(i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-Assembly"><a href="#2-Assembly" class="headerlink" title="2.Assembly"></a>2.Assembly</h4><p>程序集类，主要用于加载其他程序集，加载后才能用Type来使用其他程序集中的信息，如果想要使用不是自己程序集中的内容，需要先加载程序集，比如：dll文件（库文件）。简单的把库文件看成一种代码仓库，它提供给使用者一些可以直接拿来用的变量、函数或者类。</p><p>三种加载程序集的函数：</p><p>1.一般用来加载在同一文件下的其他程序集：Assembly asembly2 = Assembly.LoadFrom(“包含程序集清单的文件的名称或者路径”);</p><p>2.一般用来加载不在同一文件下的其他程序集：</p><p>Assembly asembly = Assembly.LoadFrom(“包含程序集清单的文件的名称或者路径”);</p><p>Assembly asembly3 = Assembly.LoadFile(“要加载的文件的完全限定路径”);</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C#">// 1.先加载一个指定程序集<br>// 需要引用命名空间 System.Reflection;<br>Assembly asembly = Assembly.LoadFrom(@&quot;xxx\xxx\xxx\xxx\xxx.dll&quot;);<br>Type[] types = asembly.GetTypes();// 获取我们程序集中的所有类型<br>for(int i = 0; i &lt; types.Length; i++)&#123;<br>    Console.WriteLine(types[i]); // 打印我们反射中存储的所有的类型<br>&#125;<br><br>// 2.再加载程序集中的一个类对象，之后才能使用反射<br>Type icon = asembly.GetType(&quot;XXXX.类对象名字&quot;);<br>MemberInfo[] members = icon.GetMembers();// 得到我们icon中存储的所有成员<br>for(int i = 0; i&lt; members.Length; i++)&#123;<br>    Console.WriteLine(members[i]);<br>&#125;<br><br>// 3.类库(dll库文件)工程创建<br>解决方案资源管理器-&gt;随便一个项目右键-&gt;添加-&gt;新建项目-&gt;选择类库(C# .Net FrameWork)<br><br>作用：我们的类库文件一般是运行不了的，一般是用于给我们纯写逻辑代码和算法代码供给他人所用的，它内部不需要Main()方法的，我们一般写好之后，在解决方案资源管理器-&gt;点击项目名-&gt;右键-&gt;生成，然后我们就可以在我们的项目的文件夹下面找到我们的项目文件夹-&gt;bin-&gt;Debug就可以看到外面的两个文件一个是.dll，还有一个是.pdb。然后我们就可以用我们反射的知识去引用我们的dll文件。<br><br></code></pre></td></tr></table></figure><p>用于快速实例化对象的类，用于将Type对象快捷实例化为对象，先得到Type，然后快速实例化出一个对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C#">Type testType = typeof(Test);<br>// 1.无参构造<br>Test testObj = Activator.CreateInstance(testType) as Test;<br>Console.WriteLine(testObj.str);<br>// 2.有参数构造<br>// 得到一个参数的构造函数的实例<br>// 参数1 反射， 参数2 我们的构造函数参数列表<br>testObj = Activator.CreateInstance(testType, 99) as Test;<br>Console.WriteLine(testObj.j);<br>// 我们再试试获取两个参数构造函数的实例<br>testObj = Activator.CreateInstance(testType, 55, &quot;111222&quot;) as Test;<br>Console.WriteLine(testObj.j);<br>// 注意：我们不能传入我们没有实现的构造函数，如果我们传入了我们没有实现的构造函数，运行后会直接报错。<br></code></pre></td></tr></table></figure><h4 id="反射总结"><a href="#反射总结" class="headerlink" title="反射总结"></a>反射总结</h4><p>反射：在程序运行时，通过反射可以得到其他程序集或者自己的程序集代码的各种信息，类、函数、变量、对象等等，实例化它们，执行它们，操作它们。</p><p>关键类：Type、Assembly、Activator。</p><p>为什么学习反射？Unity引擎的基本工作机制就是建立在反射的基础上的，学习反射是为了之后学习Unity引擎的基本工作原理做铺垫。</p><h4 id="3-特性"><a href="#3-特性" class="headerlink" title="3.特性"></a>3.特性</h4><h5 id="3-1特性是什么？"><a href="#3-1特性是什么？" class="headerlink" title="3.1特性是什么？"></a>3.1特性是什么？</h5><p>特性是一种允许我们向程序的程序集添加元数据的语言结构，它是用于保存程序结构信息的某种特殊类型的类。</p><p>特性提供功能强大的方法以将声明信息与C#代码（类型、方法、属性等）相关联。</p><p>特性与程序实体关联后，即可在运行时使用反射查询特性信息。</p><p>特性的目的是告诉编译器把程序结构的某组元数据嵌入程序集中，它可以放置在几乎所有的声明中（类、变量、函数等等申明）。</p><p>简单理解：特性本质是一个类，我们可以利用特性类为元数据添加额外信息，比如一个类、成员变量、成员方法等等为他们添加更多的额外信息，之后可以通过反射来获取得到这些额外信息。</p><h5 id="3-2自定义特性"><a href="#3-2自定义特性" class="headerlink" title="3.2自定义特性"></a>3.2自定义特性</h5><p>在上面我们讲解了特性的本质就是一个类，那么我们只需要先去申明一个类，然后让这个类基础至特性基类Attribute就可以了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C#">class MyCustomAttribute : Attribute&#123;<br>    // 这个类的内容其实就是让你最后变成一个元数据的，方便外部利用反射引用的。<br>// 特性中的成员<br>    public string info;<br>    public MyCustomAttribute(string info)&#123;<br>        this.info = info;<br>    &#125;<br>    public void TestFun()&#123;<br>        Console.WriteLine(&quot;特性的方法&quot;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3-3特性的使用"><a href="#3-3特性的使用" class="headerlink" title="3.3特性的使用"></a>3.3特性的使用</h5><p>基本语法：[特性名（参数列表）]，本质上就是在调用特性类的构造函数。</p><p>写在哪里?类、函数、变量上一行，表示他们具有该特性信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C#">// 我们使用我们上一个知识点申明的特性<br>// 注意：系统会默认帮我们省略了类名后面的Attribute<br>// 参数列表里面根据我们的构造函数的参数列表传入参数<br>[MyCustom(&quot;这是我自己写的一个用于计算的类&quot;)]<br>class MyClass&#123;<br>    [MyCustom(&quot;这是一个成员变量&quot;)]<br>    public int value;<br>    [MyCustom(&quot;这是一个用于计算加法的函数&quot;)]<br>    public void TestFun([MyCustom(&quot;函数参数&quot;int a)])&#123;<br>        <br>    &#125;<br>&#125;<br><br>// 特性的作用就是添加额外的信息，当我们通过反射得到这些成员的时候，我们可以获取到特性的信息来知道成员的用法。<br>// 举例：<br>class Program&#123;<br>    static void Main()&#123;<br>        // 特性的使用<br>        MyClass mc = new MyClass();<br>        // 得到Type的三种方法<br>        // 1.Type t = mc.GetType();<br>        // 2.t = typeof(MyClass);<br>        // 3.t = Type.GetType(命名空间名字.MyClass)<br>        Type t = mc.GetType();<br>        <br>        // 判断是否使用了某个特性<br>        // 参数一：特性的类型<br>        // 参数二：代表是否搜索继承链（属性和事件忽略此参数）<br>        // 注意这个方法只是判断类是否使用了特性，类里面的成员是该方法无法判断<br>        if(t.IsDefined(typeof(MyCustomAtrribute)), false)&#123;<br>            Console.WriteLine(&quot;该类型应用了MyCustom特性&quot;);<br>        &#125;<br>        <br>        // 获取Type元数据中的所有特性<br>        object[] array = t.GetCustomAttribute(true);<br>        for(int i = 0; i &lt; array.Length; i++)&#123;<br>if(array[i] is MyCustomAttribute)&#123;<br>Console.WriteLine((array[i] as MyCustomAttribute).info);<br>                // 因为特性的本质就是一个类，所以我们甚至可以调用其中的方法<br>                (array[i] as MyCustomAttribute).TestFun();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3-4限制自定义特性的使用范围"><a href="#3-4限制自定义特性的使用范围" class="headerlink" title="3.4限制自定义特性的使用范围"></a>3.4限制自定义特性的使用范围</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C#">// 通过为特性类加特性限制其使用范围<br>[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct, AllowMultiple = true, Inherited = true)]<br>// 参数一：AttributeTargets-----特性能够用在哪些地方<br>// 参数二：AllowMultiple-----是否允许多个特性实例用在同一个目标上<br>// 参数三：Inherited-----特性是否能被派生类和重写成员继承<br>public class MyCustom2Attribute : Attribute&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3-5系统自带特性——过时特性"><a href="#3-5系统自带特性——过时特性" class="headerlink" title="3.5系统自带特性——过时特性"></a>3.5系统自带特性——过时特性</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C#">// 过时特性-----Obsolete，用于提示用户使用的方法等成员已经过时，建议使用新方法，一般加在函数前的特性<br>Class TestClass&#123;<br>    // 参数一：调用过时方法时提升的内容<br>    // 参数二：true-使用该方法会报错(编译之前就会报错)，false-使用该方法自己报警告<br>    [Obsolete(&quot;OldSpeak方法已经过时了，请使用Speak方法&quot;), false]<br>    public void OldSpeak(string str)&#123;<br>        <br>    &#125;<br>    public void Speak()&#123;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3-6系统自带特性——调用者信息特性"><a href="#3-6系统自带特性——调用者信息特性" class="headerlink" title="3.6系统自带特性——调用者信息特性"></a>3.6系统自带特性——调用者信息特性</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C#">// 哪个文件调用?<br>CallerFilePath特性<br>// 哪一行调用？<br>CallerLineNumber特性<br>// 哪一个函数调用？<br>CallerMemberName特性<br><br>// 需要引用命名空间 using System.Runtime.CompilerServices;<br>// 一般作为函数参数的特性<br>// 举例：<br>class Test&#123;<br>    // 注意：我们的调用者信息特性后面是需要有一个默认值的，不然会报错误<br>    // 特性的默认值也可以让用户在调用函数的时候，指定传入，一般如果没有在调用函数的时候传值，系统会帮我们传入默认值：该文件的路径、该语句的行数、哪个函数在调用该函数。<br>    public void TestFun(string str, [CallerFilePath]string fileName = &quot;&quot;, [CallerLineNumber]int line = 0, [CallerMemberName]string target = &quot;&quot;)&#123;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3-7系统自带特性——条件编译特性"><a href="#3-7系统自带特性——条件编译特性" class="headerlink" title="3.7系统自带特性——条件编译特性"></a>3.7系统自带特性——条件编译特性</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C#">// 条件编译特性-----Conditional <br>// 它会和预处理指令 #define配合使用，使用之前需要引用命名空间 using System.Diagnostics;<br>// 主要可以用在一些调式代码上，有时想执行有时不想执行的代码<br>class Program&#123;<br>    // 注意：一旦我们加了条件编译特性，那么下面这个静态方法Fun()就需要我们预先定义了#define Fun才可以使用，或者说Main()里面的Fun();才会被执行<br>    [Conditional(&quot;Fun&quot;)]<br>    void Static Fun()&#123;<br>        Console.WriteLine(&quot;Fun&quot;);<br>    &#125;<br>    void static Main()&#123;<br>        Fun();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3-8系统自带特性——外部Dll包函数特性"><a href="#3-8系统自带特性——外部Dll包函数特性" class="headerlink" title="3.8系统自带特性——外部Dll包函数特性"></a>3.8系统自带特性——外部Dll包函数特性</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C#">// DllImport<br>// 用来标记非.Net(C#)的函数，表明该函数在一个外部的DLL中定义。<br>// 一般用来调用C或者C++的Dll包写好的方法，需要引用命名空间 using System.Runtime.InteropServices;<br>class Program&#123;<br>    void static Main()&#123;<br>        [DllImport(&quot;Test.dll&quot;)]<br>        // 这句代码是把我们Test.dll包中与下面这个函数一定是存在着一模一样的函数，把C\C++中这个一模一样的函数映射到这个函数中<br>        public static extern int Add(int a, int b);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="特性总结"><a href="#特性总结" class="headerlink" title="特性总结"></a>特性总结</h5><p>特性是用于为元数据再添加更多的额外信息（变量、方法等等），我们可以通过反射获取这些额外的数据来进行一些特殊的处理。</p><p>自定义特性—继承Attribute类</p><p>系统自带特性：过时特性</p><p>反射和特性的学习是为了之后Unity引擎学习的，因为Unity引擎中很多地方都用到了特性来进行一些特殊处理。</p><h3 id="十-迭代器"><a href="#十-迭代器" class="headerlink" title="十.迭代器"></a>十.迭代器</h3><h4 id="1-迭代器是什么？"><a href="#1-迭代器是什么？" class="headerlink" title="1.迭代器是什么？"></a>1.迭代器是什么？</h4><p>迭代器（iterator）有时候又被称为光标（cursor），是程序设计的软件设计模式，迭代器模式提供了一个方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的标识。在表现效果上看，是可以在容器对象（例如：链表或者数组）上遍历访问的接口，设计人员无需关心容器对象的内存分配的实现细节，可以用foreach遍历的类，都是实现了迭代器的。</p><h4 id="2-标准迭代器的实现方法"><a href="#2-标准迭代器的实现方法" class="headerlink" title="2.标准迭代器的实现方法"></a>2.标准迭代器的实现方法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs C#">// 关键接口：IEnumerator,IEnumerable;<br>// 命名空间：using System.Collections;<br>// 可以通过同时继承IEnumerable和IEnumerator实现其中的方法<br><br>// 首先写个测试类<br>class CustomList : IEnumerable, IEnumerator&#123;<br>    private int[] list;<br>    // 这里是指我们的光标位置，默认为-1(可以简单的理解为我们数组的下标)<br>    private int position = -1;<br>    public CustomList()&#123;<br>        list = new int[]&#123;1, 2, 3, 4, 5, 6, 7, 8&#125;;<br>    &#125;<br>    <br>    // 实现IEnumerable接口的成员<br>    public IEnumerator GetEnumerator()&#123;<br>        Reset();<br>    return this;<br>    &#125;<br>    <br>    // 实现IEnumerator接口的成员<br>    public object Current&#123;<br>        get&#123;<br>            return list[position];<br>        &#125;<br>    &#125;<br>    <br>    public bool MoveNext()&#123;<br>        ++position;<br>        // 是否溢出，溢出就不合法<br>        return position &lt; lits.Length;<br>    &#125;<br>    <br>    // reset是重置光标位置，一般写在获取IEnumerator对象这个函数中，用于第一次重置光标位置，这个函数十分重要!!!<br>    public void Reset()&#123;<br>        position = -1;<br>    &#125;<br>&#125;<br><br>class Program&#123;<br>    static void Main()&#123;<br>        CustomList list = new CustomList();<br>    // foreach本质<br>        // 1.先获取in后面这个对象的IEnumerator,然后会调用对象其中的GetEnumerator方法来获取。<br>        // 2.执行得到这个IEnumerator对象中的MoveNext方法<br>        // 3.只要MoveNext方法的返回值为true时候，就会去得到Current,然后复制给item。<br>        // 注意：我们可以不用一定要继承IEnumerable这个接口，只要我们的类中实现了public IEnumerator GetEnumerator()；也是可以使用foreach语句的。<br>        foreach(int item in list)<br>            Console.WriteLine(item);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-用yield-return语法糖实现迭代器"><a href="#3-用yield-return语法糖实现迭代器" class="headerlink" title="3.用yield return语法糖实现迭代器"></a>3.用yield return语法糖实现迭代器</h4><p>yield return 是C#提供给我们的语法糖，所谓语法糖，也称为糖衣语法。</p><p>主要作用就是将复杂逻辑简单化，可以增加程序的可读性，从而减少程序代码出错的机会。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs C#">// 关键接口：IEnumerable<br>// 命名空间：using System.Collections;<br>// 让想要通过foreach遍历的自定义类实现接口中的方法GetEnumerator即可。<br>class CustomList2 : IEnumerable&#123;<br>    private int[] list;<br>    <br>    public CustomList2()&#123;<br>        list = new int[]&#123;1, 2, 3, 4, 5, 6, 7, 8&#125;;<br>    &#125;<br>    <br>    public IEnumerator GetEnumerator()&#123;<br>        for(int i = 0; i &lt; list,Length; i++)&#123;<br>            // yield关键字,配合迭代器使用<br>            // yield return其实就是实现IEnumerator接口中的成员一种简单写法，我们可以不必再去继承IEnumertor并且实现Current(),MoveNext(),Reset()这三个方法还有object属性。当编译器执行到这一句的时候，会默认的帮我实现以上的成员的，让我们自己省了自己去书写。<br>            yield return list[i];<br>            <br>            // 还有另一种复杂的方法<br>            /*<br>            yield return list[0];<br>            yield return list[1];<br>            yield return list[2];<br>            yield return list[3];<br>            yield return list[4];<br>            yield return list[5];<br>            yield return list[6];<br>            yield return list[7];<br>            */<br>        &#125;<br>    &#125;<br>&#125;<br><br>class Program&#123;<br>    static void Main()&#123;<br>        CustomList list2 = new CustomList2();<br>        foreach(int item in list2)&#123;<br>            Console.WriteLine(item);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-用yield-return语法糖为泛型类实现迭代器"><a href="#4-用yield-return语法糖为泛型类实现迭代器" class="headerlink" title="4.用yield return语法糖为泛型类实现迭代器"></a>4.用yield return语法糖为泛型类实现迭代器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C#">class CustomList&lt;T&gt; : IEnumerableP&#123;<br>    private T[] array;<br>    <br>    public CustomList(params T[] array)&#123;<br>        this.array = array;<br>    &#125;<br>    public IEnumerator GetEnumerator()&#123;<br>        for(int i = 0; i &lt; array.Length; i++)&#123;<br>            yield return array[i];<br>        &#125;<br>    &#125;<br>&#125;<br><br>class Program&#123;<br>    staic void Main()&#123;<br>        CustomList&lt;string&gt; list = new CustomList&lt;string&gt;(&quot;123&quot;, &quot;123123&quot;, &quot;123123123&quot;);<br>        foreach(string item in list)&#123;<br>            Console.WriteLine(item);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>迭代器本身就是让我们在外部直接通过foreach遍历对象中元素而不需要了解其结构。</p><p>主要的两种实现迭代器的方式：</p><p>1.传统方式：继承两个接口，实现里面的方法</p><p>2.用语法糖 yield return 去返回内容，只需要继承一个接口即可</p><h3 id="十一-特殊语法"><a href="#十一-特殊语法" class="headerlink" title="十一.特殊语法"></a>十一.特殊语法</h3><h4 id="1-var隐式类型"><a href="#1-var隐式类型" class="headerlink" title="1.var隐式类型"></a>1.var隐式类型</h4><p>var是一种特殊的变量类型，它可以用来表示任意类型的变量。</p><p>注意：</p><p>1.var不能作为类的成员，只能用于临时变量申明时，也就是一般写在函数语句块中。</p><p>2.var必须初始化。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C#">var i = 5;<br>var s = &quot;123&quot;;<br>var array = new intp[]&#123;1, 2, 3, 4&#125;;<br>var list = new List&lt;int&gt;();<br><br>// 温馨提示：一般在协同开发中很少使用var这类隐私类型，因为当别人在阅读自己写的代码的时候，如果遇到了var，我们在没有阅读到后面的初始化值的时候，我们是不知道这个变量的类型的。如果代码中大量的使用了var是很影响阅读效率的。<br></code></pre></td></tr></table></figure><h4 id="2-设置对象初始值"><a href="#2-设置对象初始值" class="headerlink" title="2.设置对象初始值"></a>2.设置对象初始值</h4><p>申明对象时候，可以通过直接写大括号的形式初始化公共成员变量和属性。</p><p>注意：该方法是设置”对象“的初始值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C#">class Person&#123;<br>    private int money;<br>    public bool sex;<br>    public string Name&#123;<br>        get;<br>        set;<br>    &#125;<br>    public int Age&#123;<br>        get;<br>        set;<br>    &#125;<br>&#125;<br><br>class Program&#123;<br>    static void Main()&#123;<br>        //Person p = new Person();这是我们传统的调用构造函数实例化的方法<br>        // 下面是我们通过大括号的形式可以直接给我们对象中&quot;公开&quot;的变量进行初始化<br>        Person p = new Person&#123;sex = true, Age = 19, Name = &quot;小小泽&quot;&#125;;<br>        // 我们也可以单独的为某一个&quot;公开&quot;变量进行初始化<br>        Person p2 = new Person&#123;Age = 18&#125;;<br>        // 完整的写法<br>        // Person p3 = new Person()&#123;&#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-设置集合初始值"><a href="#3-设置集合初始值" class="headerlink" title="3.设置集合初始值"></a>3.设置集合初始值</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C#">// 申明集合对象时，也可以通过大括号直接初始化内部属性<br>int[] array = new int[]&#123;1, 2, 3, 4, 5&#125;;<br>List&lt;int&gt; listInt = new List&lt;int&gt;()&#123;1, 2, 3, 4, 5, 6&#125;;<br><br>List&lt;Person&gt; listPerson = new List&lt;Person&gt;()&#123;<br>    new Person&#123;&#125;,<br>    new Person&#123;Age = 10&#125;,<br>    new Person&#123;sex = true&#125;<br>&#125;;<br><br>Dictionary&lt;int, string&gt; dic = new Dictionary&lt;int, string&gt;()&#123;<br>    &#123;1, &quot;123&quot;&#125;,<br>    &#123;2, &quot;222&quot;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="4-匿名类型"><a href="#4-匿名类型" class="headerlink" title="4.匿名类型"></a>4.匿名类型</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C#">// var变量可以申明为自定义的匿名类型<br>var v = new &#123;age = 10, money = 11, name = &quot;小小泽&quot;&#125;;// 这句代码可以直接复制到Main()语句中不会报错。<br>// 我们甚至可以打印出里面的内容<br>Console.WriteLine(v.age);<br>Console.WriteLine(v.money);<br>Console.WriteLine(v.name);<br>// 匿名类型更像是一种数据集合，它的大括号&quot;&#123;&#125;&quot;中除了成员属性之外的，例如：函数、委托、事件等等是无法写入大括号里面的。<br></code></pre></td></tr></table></figure><h4 id="5-可空类型"><a href="#5-可空类型" class="headerlink" title="*5.可空类型"></a>*5.可空类型</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C#">// 1.值类型是不能赋值为空的<br>//int c = null;会报错<br><br>// 2.申明时在值类型后面加?可以赋值为空<br>int? c = null;<br><br>// 3.判断是否为空<br>if(c.HasValue)&#123;<br>    Console.WriteLine(c);<br>    Console.WriteLine(c.value);<br>&#125;<br><br>// 4.安全获取可空类型值<br>int? value = null;<br>//   4-1.如果为空，默认返回值类型的默认值<br>Console.WriteLine(value.GetValueOrDefault());<br>//   4-2.也可以指定一个默认值<br>Console.WriteLine(value.GetValueOrDefault(100));// 这个方法需要特别注意一下，它并不是去给value赋值(下面一条语句就是为了验证value是否被改变了)，它的作用是判断value是否为空，如果是就打印100，如果不是就打印value的值；<br>Console.WriteLine(value);<br></code></pre></td></tr></table></figure><p><em>*</em>注意：我们的十四种普通类型里面除了引用类型（数组，类，string外）基本都是值类型都可以使用这种变量类型后面加”？“的可空类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C#">// &quot;?&quot;其实就是一种语法糖，我们除了对值类型的声明上使用，也还可以对引用类型的方法执行进行判断<br>// 举例：<br>object 0 = null;<br>// 如果我们去执行下面这句代码的话，编译器是会报错的<br>// o.ToString();<br>// 所以我们一般会进行安全性判断<br>if(o != null)<br>    o.ToString();<br>// 现在有了&quot;?&quot;可空类型，我们可以下面这种渐变写法<br>// 相当于是一种语法糖，能够帮助我们自动取判断o是否为空，如果是null就不会执行tostring也不会报错。<br>o?.ToString();<br><br>int[] arrayInt = null;<br>Console.WriteLine(arrayInt?[0]);<br><br>Action action = null;<br>action?.Invoke();<br></code></pre></td></tr></table></figure><h4 id="6-空合并操作符"><a href="#6-空合并操作符" class="headerlink" title="6.空合并操作符"></a>6.空合并操作符</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C#">// 空合并操作符 ？？<br>// 左边值 ？？ 右边值<br>// 如果左边值为null就返回右边值，否则返回左边值<br>// ***注意：只要是可以为null的类型都能使用(也就是说我们的值类型配合可空类型符合&quot;?&quot;也是可以使用的)<br>int? intValue = null;<br>// 下面这句语法就相当于三目运算符-&gt;int intValue2 = intValue == null ? 100 :intValue.Value;<br>int intValue2 = intV ?? 100;<br>Console.WriteLine(intValue2);<br><br>str = str ?? &quot;hahahaha&quot;;<br>Console.WriteLine(str);<br></code></pre></td></tr></table></figure><h4 id="7-内插字符串"><a href="#7-内插字符串" class="headerlink" title="7.内插字符串"></a>7.内插字符串</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C#">// 关键字符：$<br>// 用$来构造字符串，让字符串中可以拼接变量<br>string name = &quot;小小泽&quot;;<br>Console.WriteLine($&quot;&#123;name&#125;,好好学习!&quot;);<br></code></pre></td></tr></table></figure><h4 id="8-单句逻辑简略写法"><a href="#8-单句逻辑简略写法" class="headerlink" title="8.单句逻辑简略写法"></a>8.单句逻辑简略写法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C#">// 如果我们的语句块内只有一句代码的话是可以省略大括号的<br>if(true)<br>    Console.WriteLine(&quot;小小泽,好好学习！&quot;);<br>for(int i = 0; i &lt; 10; i++)<br>    Console.WriteLine(i);<br>while(true)<br>    Console.WriteLine(&quot;小小泽,好好学习！&quot;);<br><br>// 注意：我们在类里面声明函数和属性也是同样可以的<br>class Person&#123;<br>    public string name;<br>    Public String Name&#123;<br>        // 我们的get方法本来是要return，用&quot;=&gt;&quot;写法会直接帮我们把return都省略了。<br>        get =&gt; &quot;小小泽&quot;;<br>        set =&gt; name = value;<br>    &#125;<br>    <br>    // 我们该方法作用是计算加法，本来是要return一个int类型的，用&quot;=&gt;&quot;的写法会自动的帮我们省略了return。<br>    public int Add(int x, int y) =&gt; x + y;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CSharp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSharp</tag>
      
      <tag>编程语言</tag>
      
      <tag>面对对象编程</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSharp基础</title>
    <link href="/2021/12/23/CSharp%E5%9F%BA%E7%A1%80/"/>
    <url>/2021/12/23/CSharp%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="C-基础"><a href="#C-基础" class="headerlink" title="C#基础"></a>C#基础</h2><h3 id="一-面向对象编程基础概念"><a href="#一-面向对象编程基础概念" class="headerlink" title="一.面向对象编程基础概念"></a>一.面向对象编程基础概念</h3><p>面向对象编程：万物皆对象；用程序来抽象(形容)对象；用面向对象的思想来编程。</p><p>面向对象编程三大特性：封装、继承、多态</p><p>特性总结：</p><p>①封装：用程序语言来形容对象</p><p>②继承：复用封装对象的代码；儿子继承父亲，复用现成代码</p><p>③多态：同样行为的不同表现，儿子继承父亲染色体Y的基因，但是具有与父亲不一样的行为表现</p><p>面向对象编程七大原则：开闭原则、依赖倒转原则、里氏替换原则、单一职责原则、接口隔离原则、合成复用原则、迪米特法则</p><h3 id="二-面向对象三大特性——封装"><a href="#二-面向对象三大特性——封装" class="headerlink" title="二.面向对象三大特性——封装"></a>二.面向对象三大特性——封装</h3><h4 id="2-1访问修饰符"><a href="#2-1访问修饰符" class="headerlink" title="2.1访问修饰符"></a>2.1访问修饰符</h4><p>Public 公开的</p><p>Protected 对继承的子类公开</p><p>Private 私有的</p><h4 id="2-2成员变量的封装"><a href="#2-2成员变量的封装" class="headerlink" title="2.2成员变量的封装"></a>2.2成员变量的封装</h4><p>在类的内部，声明对象的属性</p><p><strong>如果声明的成员变量中，有与自身同名的(同类型)引用类型变量，切记不可初始化(new XXX())。</strong></p><p>例如：错误写法</p><p>Class Person{</p><p>​    Person p1 = new Person():</p><p>}</p><p>这样的声明同名的成员变量，在我们其他其他类中对它进行实例化的时候，会造成无限的循环实例化它，最后造成内存溢出，因为，我们在内的内部初始化了这个类，对于这个成员变量来说，它的内部结构也是：</p><p>Class Person{</p><p>​    Person p1 = new Person();</p><p>}</p><p>所以就会造成无限的实例化这个内部成员变量，最终堆溢出。</p><h4 id="2-3成员方法的封装"><a href="#2-3成员方法的封装" class="headerlink" title="2.3成员方法的封装"></a>2.3成员方法的封装</h4><p>在类的内部，构造对象的行为。</p><h4 id="2-4构造函数与析构函数"><a href="#2-4构造函数与析构函数" class="headerlink" title="2.4构造函数与析构函数"></a>2.4构造函数与析构函数</h4><h5 id="2-4-1构造函数的基本概念"><a href="#2-4-1构造函数的基本概念" class="headerlink" title="2.4.1构造函数的基本概念"></a>2.4.1构造函数的基本概念</h5><p>在实例化对象之前会调用的用于自身初始化的函数，如果不写，会调用系统默认的无参构造函数。</p><h5 id="2-4-2构造函数的写法"><a href="#2-4-2构造函数的写法" class="headerlink" title="2.4.2构造函数的写法"></a>2.4.2构造函数的写法</h5><p>1.没有返回值</p><p>2.函数名与类名必须相同</p><p>3.没有特殊需求时，一般都是Public</p><p>4.构造函数可以被重载</p><p>5.this代表当前被调用该函数的对象自己</p><p>注意:如果自己不是实现无参构造函数而实现了有参构造函数，就会失去系统默认的无参构造函数。</p><p>6.构造函数的特殊用法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c#">Class Person&#123;<br>    string name;<br>    int age;<br>    Public Person()&#123;<br>        name = &quot;xiaoxiaoze&quot;;<br>        age = 18;<br>    &#125;<br>    Public Person(int age)&#123;<br>        this.age = age;<br>    &#125;<br>    public Person(string name)&#123;<br>        this.name = name;<br>    &#125;<br>    // 构造函数的特殊用法<br>    public Person(string name, int age):this()&#123;<br>        Console.WriteLine(&quot;111111&quot;);<br>    &#125;<br>&#125;<br>public Class static main()&#123;<br>    // 这是一个生成的初始化我们自己写的无参构造函数<br>    // 因为我们自己写了带参或者不带参数的构造函数之后，系统就不会在提供默认的无参构造函数了。<br>    Person p = new Person();<br>    // 接下来是调用带this()的构造函数<br>    // 第一步它会先去找this();因为this代表函数对象自身，我们可以把this替换成Person更加方便理解；<br>    //那么第一步会是先去调用无参构造函数Person();<br>    //接着才是调用带参数的构造函数Person(String name, ing age);<br>    Person p = new Person(&quot;xiaoxiaoze&quot;, 18);<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h5 id="结构体与类的区别："><a href="#结构体与类的区别：" class="headerlink" title="结构体与类的区别："></a>结构体与类的区别：</h5><p><strong>类中是允许自己申明无参构造函数的，而结构体不行，结构体的构造函数必须初始化自身所有的成员变量</strong></p><h4 id="2-5-析构函数"><a href="#2-5-析构函数" class="headerlink" title="2.5 析构函数"></a>2.5 析构函数</h4><p>当引用类型的堆内存被回收时，会调用该函数；对于需要手动管理内存的语言(比如C++)，需要在析构函数中做一些内存回收处理；但是C#中存在自动垃圾回收机制GC;所以我们几乎不怎么使用，所以该知识点只是做了解即可。</p><p><strong>注意：在Unity开发中析构函数几乎不会使用，所以该知识点只做了解即可。</strong></p><h5 id="2-5-1-基本语法："><a href="#2-5-1-基本语法：" class="headerlink" title="2.5.1.基本语法："></a>2.5.1.基本语法：</h5><p>~类名（）{</p><p>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C#">class Test&#123;<br>    ~Test()&#123;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-5-2什么是托管代码？什么是非托管代码？什么是托管资源？什么是非托管资源？什么是解释型语言？"><a href="#2-5-2什么是托管代码？什么是非托管代码？什么是托管资源？什么是非托管资源？什么是解释型语言？" class="headerlink" title="2.5.2什么是托管代码？什么是非托管代码？什么是托管资源？什么是非托管资源？什么是解释型语言？"></a>2.5.2什么是托管代码？什么是非托管代码？什么是托管资源？什么是非托管资源？什么是解释型语言？</h5><p><strong>托管代码 (managed code)</strong><br>由公共语言运行库环境（而不是直接由操作系统）执行的代码。托管代码应用程序可以获得公共语言运行库服务，例如自动垃圾回收、运行库类型检查和安全支持等。这些服务帮助提供独立于平台和语言的、统一的托管代码应用程序行为。<br> 如C#</p><p><strong>非托管代码 (unmanaged code)</strong><br>在公共语言运行库环境的外部，由操作系统直接执行的代码。非托管代码必须提供自己的垃圾回收、类型检查、安全支持等服务；它与托管代码不同，后者从公共语言运行库中获得这些服务。如C++,C</p><p><strong>托管资源 (managed Assets) </strong></p><p>托管资源指的是.NET可以自动进行回收的资源，主要是指托管堆上分配的内存资源。托管资源的回收工作是不需要人工干预的，由.NET运行时在适当的时候调用垃圾回收器进行回收。例如程序中分配的对象,作用域内的变量等。但如果我们需要立即进行垃圾回收，则可以使用<code>GC.Collect()</code>来触发。</p><p><strong>非托管资源 (unmanaged Assets)</strong></p><p>非托管资源指的是.NET不知道如何回收的资源，最常见的一类非托管资源如文件，窗口，网络连接，数据库连接，画刷，图标等。这类资源，垃圾回收器在清理的时候会调用<code>Object.Finalize()</code>方法。默认情况下，方法是空的，对于非托管对象，需要在此方法中编写回收非托管资源的代码，以便垃圾回收器正确回收资源。</p><p><strong>解释型语言</strong></p><p>简单的说，如果一门语言主流实现的通常使用方式中没有显式的把这个语言源代码转换成另一种相对来说更低级的语言(字节码，汇编，机器码等等)的过程，就能叫作解释型语言。</p><h5 id="补充："><a href="#补充：" class="headerlink" title="补充："></a><strong>补充：</strong></h5><p><strong>结构体的构造函数需要实现自身所有的成员变量，也就是说我们的有参构造函数需要对自身所有的成员变量进行初始化，而我们的类就明显没有这个特点。(类和结构体的具体区别会放在后面讲解)</strong></p><p><em>需要注意的是，析构函数不需要访问修饰符。结构体和类虽然相似都有构造函数，但是<em>*结构体是没用析构函数</em></em>。</p><h4 id="2-6垃圾回收机制"><a href="#2-6垃圾回收机制" class="headerlink" title="2.6垃圾回收机制"></a>2.6垃圾回收机制</h4><p>垃圾回收机制，简称：GC(Garbage Collector)</p><p>垃圾回收的过程是在遍历堆(Heap)上动态分配的所有对象，通过识别它们是否被引用来确定哪些对象是垃圾，哪些对象仍要被使用，所谓的垃圾就是没有被任何变量，对象引用的内存，垃圾就需要被回收释放。</p><p>垃圾回收有很多种算法，比如：引用计数(Reference Counting)、标记清除(Mark Sweep)、标记整理(Mark Compact)、复制集合(Copy Collection).</p><p>注意：GC只负责堆(Heap)内存的垃圾回收，引用类型都是存在堆(Heap)种的，所以它的分配和释放都是通过垃圾回收机制来管理。</p><p>栈(Stack)上的内存是有系统自动管理的，值类型在栈(Stack)中分配内存的，他们有自己的生命周期，不用对他们进行管理，会自动分配和释放。</p><h5 id="C-内存回收机制原理："><a href="#C-内存回收机制原理：" class="headerlink" title="C#内存回收机制原理："></a>C#内存回收机制原理：</h5><p>内存回收机制存在三代内存：0代内存、1代内存、2代内存；</p><p>代的概念：代是垃圾回收机制中使用的一种算法(分代算法)，每次新分配的对象都会被配置在第0代内存中，每次新分配都可能会进行垃圾回收以释放内存(0代内存满时)；在第一次内存回收过程开始时候，垃圾回收器会认为堆中全是内存，会进行以下两步：</p><p>1.标记对象：从根（静态字段、方法参数）开始检查引用对象，标记后为可达对象，未标记为不可达对象，不可达对象就被认为是垃圾。</p><p>2.搬迁对象压缩堆（挂起执行托管代码线程）释放未标记的对象，搬迁可达对象，修改引用地址。</p><p><strong>大对象总被认为是第二代内存，目的是减少性能损耗，提升性能；不会对大对象进行搬迁，默认85000字节(83kb)以上的对象为大对象。</strong></p><h4 id="2-7成员属性"><a href="#2-7成员属性" class="headerlink" title="2.7成员属性"></a>2.7成员属性</h4><h5 id="2-7-1基本概念："><a href="#2-7-1基本概念：" class="headerlink" title="2.7.1基本概念："></a>2.7.1基本概念：</h5><p>1.用于保护成员变量</p><p>2.为成员属性的获取和赋值添加逻辑处理</p><p>3.解决访问权限的局限性</p><p>​    Public——内外访问</p><p>​    Private——内部访问</p><p>​    Protected——内部和子类访问</p><p><strong>属性可以让成员变量在外部只能获取不能修改或者只能修改不能获取。</strong></p><h5 id="2-7-2成员属性的基本写法"><a href="#2-7-2成员属性的基本写法" class="headerlink" title="2.7.2成员属性的基本写法"></a>2.7.2成员属性的基本写法</h5><p>访问修饰符    属性类型    属性名</p><p>{</p><p>​        get{}</p><p>​        set{}</p><p>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C#">Class Person&#123;<br>    private string name<br>    public string Name&#123;<br>        get&#123;<br>            return name;<br>        &#125;<br>        set&#123;<br>            name = value;<br>        &#125;<br>    &#125;<br>&#125;<br><br>// get与set方法也可以在前面加访问修饰符，不加时候默认为属性的访问修饰符<br>lass Person&#123;<br>    private string name<br>    public string Name&#123;<br>    private get&#123;<br>            return name;<br>        &#125;<br>        set&#123;<br>            name = value;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>1.默认不加会使用属性声明时候的访问权限</p><p>2.加的访问修饰符要低于属性的访问权限</p><p>3.不能让get和set的访问权限都低于属性的权限</p><p>4.get和set可以只有一个，但是不能全部都没有</p><h4 id="2-8索引器"><a href="#2-8索引器" class="headerlink" title="2.8索引器"></a>2.8索引器</h4><h5 id="2-8-1基本概念"><a href="#2-8-1基本概念" class="headerlink" title="2.8.1基本概念"></a>2.8.1基本概念</h5><p>让对象可以像数组一样通过索引访问其中元素，使程序看起来更加直观，更加容易编写。</p><h5 id="2-8-2索引器语法"><a href="#2-8-2索引器语法" class="headerlink" title="2.8.2索引器语法"></a>2.8.2索引器语法</h5><p>访问修饰符    返回值    this[参数类型    参数名， 参数类型    参数名··········]</p><p>{</p><p>​        内部的写法和规则和属性相同</p><p>​        set{}</p><p>​        get{}</p><p>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c#">Class Person&#123;<br>    private string name;<br>    private int age;<br>    private Person[] friends;<br>    <br>    // 索引器的写法<br>    public Person this[int index]&#123;<br>        <br>        set&#123;<br>        friends[index] = value;    <br>        &#125;<br>        <br>        get&#123;<br>            return friends[index];<br>        &#125;<br>    &#125;<br>&#125;<br>Class Programe&#123;<br>    static void main()&#123;<br>        // 索引器的使用<br>        Person p = new Person();<br>        p[0] = new Person();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-8-3索引器里面写逻辑"><a href="#2-8-3索引器里面写逻辑" class="headerlink" title="2.8.3索引器里面写逻辑"></a>2.8.3索引器里面写逻辑</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C#">// 索引器跟属性差不多，所以其内部也是可以写逻辑的<br>Class Person&#123;<br>    private Person[] friends;<br>    Public Person this[int index]&#123;<br>        get&#123;<br>            if(friends == null || friends &lt;= index)&#123;<br>                return null;<br>            &#125;<br>        &#125;<br>        set&#123;<br>            if(friends == null)&#123;<br>friends = new Person()&#123;value&#125;;<br>            &#125;<br>            if(friends.Length &lt;= index)&#123;<br>                return<br>            &#125;<br>            else&#123;<br>                friends[index] = value;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-8-4索引器的重载"><a href="#2-8-4索引器的重载" class="headerlink" title="2.8.4索引器的重载"></a>2.8.4索引器的重载</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs C#">Class Person&#123;<br>    private String name;<br>    private int age;<br>    private Person[] friends;<br>    private Person[,] persons;<br>    <br>    Public Person this[index]&#123;<br>        get&#123;<br>            return friends[index];<br>        &#125;<br>        set&#123;<br>            friends[index] = value;<br>        &#125;<br>    &#125;<br>    // 索引器的重载<br>    Public Person this[int i, int j]&#123;<br> set&#123;<br>            if(person == null)<br>                person = new Person[i,j];<br>        &#125;   <br>        get&#123;<br>            return person[i,j];<br>        &#125;<br>    &#125;<br>    <br>    // 索引器的重载<br>    Public int this[int num]&#123;<br>        set&#123;<br>            age = num;<br>        &#125;<br>        get&#123;<br>            return age;<br>        &#125;<br>    &#125;<br>    <br>    // 索引器的重载<br>    Public String this[string str]&#123;<br>        set&#123;<br>            name = str;<br>        &#125;<br>        get&#123;<br>            switch(str)&#123;<br>                case &quot;name&quot;:<br>                    return name;<br>                default:return &quot;&quot;;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br>Class Programe&#123;<br>    static void main()&#123;<br>Person p = new Person();<br>        p[1,3] = new Person;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：我们通过以上案例可以知道索引器是方便我们像数组一样访问我们对象的成员变量，索引器的参数类型可以是任意的，索引器可以重载。*索引器的用法同样是适用于结构体的。</p><h4 id="2-9静态成员"><a href="#2-9静态成员" class="headerlink" title="2.9静态成员"></a>2.9静态成员</h4><h5 id="2-9-1基本概念"><a href="#2-9-1基本概念" class="headerlink" title="2.9.1基本概念"></a>2.9.1基本概念</h5><p>静态关键字：static</p><p>概念：用static修饰的成员变量、方法、属性等等称为静态成员</p><p>特点：可以直接用类名点(.)出来使用</p><h5 id="2-9-2自定义静态成员"><a href="#2-9-2自定义静态成员" class="headerlink" title="2.9.2自定义静态成员"></a>2.9.2自定义静态成员</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C#">class Test&#123;<br>    // 声明静态成员变量<br>    static Public float PI = 3.14;<br>    public int testInt = 100;<br>    // 定义静态成员方法<br>    public static float CalcCircle(float r)&#123;<br>        return PI * r * r;<br>    &#125;<br>&#125;<br><br>class Program&#123;<br>    void main()&#123;<br>        Test.CalcCircle(10f);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-9-3为什么静态成员和静态成员方法不需要实例化就可以通过类名-出来使用？"><a href="#2-9-3为什么静态成员和静态成员方法不需要实例化就可以通过类名-出来使用？" class="headerlink" title="2.9.3为什么静态成员和静态成员方法不需要实例化就可以通过类名.出来使用？"></a>2.9.3为什么静态成员和静态成员方法不需要实例化就可以通过类名.出来使用？</h5><p><em>*</em>首先，我们知道程序中是不可能无中生有的，在一个普通的类对象中，我们需要对这个对象进行实例化操作之后，让它在堆内存中开辟一块空间，在栈上存储对堆的引用，完成这一步之后，我们才可以通过我们实例化出来的变量通过点(.)使用其中的成员变量或者成员方法。所以，我们明白我们要使用的对象、变量、函数都是要在内存中分配内存空间的，之所要要实例化对象，目的就是分配内存空间，在程序中产生一个抽象的对象。那么回过头来，静态的成员变量或者函数之所以能不需要实例化就可以使用，说明程序是已经为它们分配好了内存空间的。在程序开始运行的时候，就会帮它们分配内存空间，所以我们就能直接使用。静态成员和程序是同生共死的，只要使用了它，直到程序结束时内存空间才会被释放。所以一个静态成员就会有自己的唯一的一个”内存小房间”，这让静态成员就有了唯一性，在任何地方使用都是用的”小房间”里面的内容，改变了它也是改变小房间里的内容。</p><h5 id="2-9-4静态函数中不能使用非静态成员"><a href="#2-9-4静态函数中不能使用非静态成员" class="headerlink" title="2.9.4静态函数中不能使用非静态成员"></a>2.9.4静态函数中不能使用非静态成员</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C#">class Test&#123;<br>    static public float PI = 3.14;<br>    public int testInt = 100;<br>    public static float CalcCircle(float r)&#123;<br>        // 先看错误例子<br>        // 会报错误，因为静态成员变量和静态函数的生命周期跟普通类成员变量和成员方法的声明周期是不一样的，程序运行了之后，静态的成员变量和静态的方法会被分配内存空间，但是普通的类是需要我实例化，手动分配内存空间才能使用，在静态方法中我们是无法调用普通的非静态成员或者方法的因为它们还没被分配内存空间(或实例化)<br>        Console.WriteLine(testInt);<br>        // 正确的方式<br>        // 实例化在使用<br>        Test t = new Test();<br>        Console.WriteLine(t.testInt);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-9-5非静态成员函数中可以直接使用静态成员变量"><a href="#2-9-5非静态成员函数中可以直接使用静态成员变量" class="headerlink" title="2.9.5非静态成员函数中可以直接使用静态成员变量"></a>2.9.5非静态成员函数中可以直接使用静态成员变量</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#">class Test&#123;    static int testInt = 100;    public void Te()&#123;        Console.WriteLine(testInt);    &#125;&#125;<br></code></pre></td></tr></table></figure><p>同理还是因为生命周期不同的原因，当普通类的成员方法使用到了静态成员变量或者静态成员方法的时候，说明已经完成了实例化的操作，在内存空间得到了分配。</p><h5 id="2-9-6静态成员对我们的作用"><a href="#2-9-6静态成员对我们的作用" class="headerlink" title="2.9.6静态成员对我们的作用"></a>2.9.6静态成员对我们的作用</h5><p>静态变量：</p><p>1.常用唯一的变量的申明，例如PI = 3.14f;</p><p>2.方便别人获取的对象申明</p><p>静态方法：</p><p>常用唯一的方法申明，例如相同规则的数学计算相关函数</p><h5 id="2-9-7常量和静态变量"><a href="#2-9-7常量和静态变量" class="headerlink" title="2.9.7常量和静态变量"></a>2.9.7常量和静态变量</h5><p>const(常量)可以理解为特殊的static(静态)。</p><h6 id="Ⅰ-const的特点"><a href="#Ⅰ-const的特点" class="headerlink" title="Ⅰ.const的特点"></a>Ⅰ.const的特点</h6><p>const必须写在访问修饰符的后面，变量声明的前面；</p><p>const必须初始化且初始化之后无法被修改</p><p>const只能修饰变量</p><p>const可以跟static一样，被类名点出来</p><h6 id="Ⅱ-总结"><a href="#Ⅱ-总结" class="headerlink" title="Ⅱ.总结"></a>Ⅱ.<strong>总结</strong></h6><p>概念：用static修饰的成员变量、成员方法、成员属性等就称为静态成员</p><p>特点：直接用类名点出来使用（全局性）</p><p>生命周期：和程序同生共死，程序运行后就会一直存在内存中，直到程序结束后才会释放因此静态成员具有唯一性。</p><p>注意：</p><p>1.静态函数中不能直接使用非静态成员</p><p>2.非静态函数中可以使用静态成员</p><h6 id="Ⅲ-常量和静态变量的比较"><a href="#Ⅲ-常量和静态变量的比较" class="headerlink" title="Ⅲ.常量和静态变量的比较"></a>Ⅲ.常量和静态变量的比较</h6><p>1.相同点：</p><p>它们都可以通过类名点出来使用</p><p>2.不同点：</p><p>2.1const必须初始化且不能被修改，static没有这个规则</p><p>2.2const只能修饰变量，static可以修饰很多</p><p>2.3const不能写在访问修饰符前面一定是写在变量声明前面，static没有这个规则。</p><h4 id="2-10静态类和静态构造函数"><a href="#2-10静态类和静态构造函数" class="headerlink" title="2.10静态类和静态构造函数"></a>2.10静态类和静态构造函数</h4><h5 id="2-10-1静态类"><a href="#2-10-1静态类" class="headerlink" title="2.10.1静态类"></a>2.10.1静态类</h5><p>概念：用statci修饰的类</p><p>特点：只能包含静态成员，不能被实例化</p><p>作用：</p><p>1.将常用的静态成员写在静态类中，方便使用</p><p>2.静态类不能被实例化，更能体现工具类的唯一性，例如Console类就是一个静态类。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#">static class Tools&#123;    static int testInt = 100;    public void static Fun()&#123;            &#125;        public int TestInt&#123;        set;        get;    &#125;&#125;<br></code></pre></td></tr></table></figure><h5 id="2-10-2静态类中的静态构造函数"><a href="#2-10-2静态类中的静态构造函数" class="headerlink" title="2.10.2静态类中的静态构造函数"></a>2.10.2静态类中的静态构造函数</h5><p>概念：在构造函数加上static修饰</p><p>特点：</p><p>1.静态类和普通类都可以有</p><p>2.不能使用访问修饰符</p><p>3.不能有参数</p><p>4.只会自动调用一次</p><p>作用：在静态构造函数中初始化静态变量</p><p>使用：静态类中的静态构造函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#">static class StaticClass&#123;    public static int testInt = 100;    public static int testInt2 = 100;    static StaticClass()&#123;        Console.WriteLine(&quot;静态构造函数&quot;);    &#125;&#125;class Programe&#123;    void main()&#123;        console.WriteLine(StaticClass.testInt);        console.WriteLine(StaticClass.testInt2);        console.WriteLine(StaticClass.testInt);            &#125;&#125;<br></code></pre></td></tr></table></figure><p>结果：运行了上面的代码，我们的构造函数自动调用了一次，先显示了构造函数的内容：”静态构造函数”，接着再打印了三次100；</p><p>结论/总结：静态构造函数只会调用一次，它的作用相当于对我们的静态类中的成员进行初始化的意义。</p><h5 id="2-10-3普通类中的静态构造函数"><a href="#2-10-3普通类中的静态构造函数" class="headerlink" title="2.10.3普通类中的静态构造函数"></a>2.10.3普通类中的静态构造函数</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#">class Test&#123;    public static int testInt = 200;    // 这里先解释一个误区，虽然我们声明了两个Test()构造函数，它们不因该会报错吗？（函数的重载），在这里static修饰的Test()和普通的Test()已经不再遵循函数重载的规则了，所以这里不能称为函数的重载，算是两个不同的函数    static Test()&#123;        Console.WriteLine(&quot;静态构造&quot;);    &#125;    public Test()&#123;        Console.WriteLine(&quot;普通构造&quot;);    &#125;&#125;class Programe&#123;    void main()&#123;        Console.WriteLine(Test.testInt);        Test t = new Test();        Test t2  = new Test();    &#125;&#125;<br></code></pre></td></tr></table></figure><p>结果：运行上面的代码会先显示:”静态构造”，然后打印200，然后再打印两次：”普通构造”。</p><p>结论：说明跟静态类中的静态构造函数相同，当对静态类或者非静态类的内容进行使用的时候，会自动的先调用静态构造函数的内容，再做行为。</p><p><strong>总结：</strong></p><p>静态类：用static修饰的类；</p><p>特点：只能包含静态成员，不能被实例化；</p><p>作用：工具类，拓展方法；</p><p>静态构造函数：用static修饰的构造函数</p><p>特点：静态类和普通类都可以有静态构造函数；不能使用访问修饰符；不能有参数；只会自动调用一次；</p><p>作用：初始化静态成员；</p><h4 id="2-11拓展方法"><a href="#2-11拓展方法" class="headerlink" title="2.11拓展方法"></a>2.11拓展方法</h4><h5 id="2-11-1概念：为现有非静态变量类型添加新方法"><a href="#2-11-1概念：为现有非静态变量类型添加新方法" class="headerlink" title="2.11.1概念：为现有非静态变量类型添加新方法"></a>2.11.1概念：为现有非静态变量类型添加新方法</h5><p>作用：</p><p>1.提升程序的拓展性</p><p>2.不需要再对象中重新写方法</p><p>3.不需要继承来添加方法</p><p>4.为别人封装的类型写额外的方法</p><p>特点：</p><p>1.一定是写在静态类中</p><p>2.一定是个静态函数</p><p>3.第一个参数为拓展目标</p><p>4.第一个参数用this修饰</p><h5 id="2-11-2基本语法"><a href="#2-11-2基本语法" class="headerlink" title="2.11.2基本语法"></a>2.11.2基本语法</h5><p>访问修饰符 static 返回值 函数名(this 拓展类名 参数名，参数类型 参数名，参数类型 参数名……)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#">// 拓展方法一般写在静态的工具类中static class Tools&#123;    // int类型的拓展的无参方法    public static void SpeakInt(this int value)&#123;        console.WriteLine(&quot;这个值为&quot;+value);    &#125;    // string类型的拓展的有两个参数的方法    public static void SpeakStringInfo(this string str, string str2, string str3)&#123;        console.WriteLine(&quot;两个参数：&quot;+str2+str3);    &#125;&#125;class Program&#123;    static void main()&#123;        // 拓展方法的使用        int i = 10;        i.SpeakInt();    &#125;&#125;<br></code></pre></td></tr></table></figure><h5 id="2-11-2自定义自己的拓展方法"><a href="#2-11-2自定义自己的拓展方法" class="headerlink" title="2.11.2自定义自己的拓展方法"></a>2.11.2自定义自己的拓展方法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#">class test&#123;    public void Fun1()&#123;            &#125;    public void Fun2()&#123;            &#125;&#125;static class Tools&#123;    // 为test这个类拓展了一个Fuc3的方法    public static void Fuc3(this test t)&#123;            &#125;    // ***重点    // 如果拓展方法与原类中的方法有同名，则在使用的时候，会调用原类中的方法，不再调用拓展方法    public static void Fun2()&#123;            &#125;&#125;<br></code></pre></td></tr></table></figure><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h5><p>概念：为现有的非静态变量类型添加方法</p><p>作用：</p><p>1.提升程序拓展性</p><p>2.不需要再在对象中重新写方法</p><p>3.不需要继承来添加方法</p><p>4.为别人封装的类型写额外的方法</p><p>特点：</p><p>1.静态类中的静态方法</p><p>2.第一个参数代表拓展的目标类</p><p>3.第一次参数前面必须要加this</p><p>注意：</p><p>1.拓展方法可以有返回值和n个参数</p><p>2.根据需求而定</p><h4 id="2-12运算符重载"><a href="#2-12运算符重载" class="headerlink" title="2.12运算符重载"></a>2.12运算符重载</h4><p>概念：让自定义类和结构体可以使用运算符</p><p>关键字：operator</p><p>特点：</p><p>1.一定是一个公开的静态方法</p><p>2.返回值写在operator前</p><p>3.逻辑处理自定义</p><p>作用：</p><p>1.条件运算符需要成对实现</p><p>2.一个符合可以多个重载</p><p>3.不能使用ref和out</p><p>*基本语法：public static 返回值类型 operator 运算符(参数列表)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#">class Point&#123;    public int x;    public int y;    // 写一个点与点之间的相加    public static Point operator +(Point p1, Point p2)&#123;        Point p = new Point();        p.x = p1.x + p2.x;        p.y = p1.y + p2.y;    &#125;&#125;class Program&#123;    void Main()&#123;        // 运算符重载的使用        Point p = new Point();        p.x = 1;        p.y = 1;        Point p1 = new Point();    p1.x = 2;        p1.y = 2;        Point p2 = p + p1;     &#125;&#125;<br></code></pre></td></tr></table></figure><p><strong>注意</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#">class test&#123;    // ***必须要有两个以上的参数且参数类型中必须存在一个或者多个与该类同类型的参数    // 例如以下就符合，存在一个与类同名的参数，且参数列表必须等于2个    public static void operator +(test t, int i)&#123;            &#125;    // 运算符重载符合函数的重载    // 以下就是对一个加法进行重载    public static void operator +(test t, test t1)&#123;            &#125;&#125;<br></code></pre></td></tr></table></figure><p><strong>注意</strong></p><p>1.可重载的运算符：</p><p>算数运算符：+、-、*、/、++、—；</p><p>逻辑运算符：!</p><p>位运算符：|、&amp;、^、~、&gt;&gt;、&lt;&lt;</p><p>条件运算符：&lt;、&gt;、&gt;=、&lt;=、==、！=</p><p><em>*</em>注意：逻辑运算符中”与””或”是不允许重载的；条件运算符中必须成对出现，有”&gt;”的运算符重载就必须有”&lt;”的运算符重载，有”==”的运算符重载就必须要有”!=”的运算符重载。</p><p>2.不可重载的运算符：</p><p>逻辑与(&amp;&amp;)逻辑或(||)、索引器[]、强转运算符()、特殊运算符（点.、三目运算符？：、赋值符合=）</p><p>总结：</p><p>关键字：operator</p><p>固定语法：public static 返回值 operator 运算符（参数列表）</p><p>作用：让自己定义类或者结构体对象进行运算</p><p>注意：</p><p>1.参数的数量</p><p>2.条件运算符的配对实现</p><p>3.一个符合可以多个重载</p><p>4.不能用ref和out</p><h4 id="2-13内部类和分部类"><a href="#2-13内部类和分部类" class="headerlink" title="2.13内部类和分部类"></a>2.13内部类和分部类</h4><h5 id="2-13-1内部类"><a href="#2-13-1内部类" class="headerlink" title="2.13.1内部类"></a>2.13.1内部类</h5><p>概念：在一个类的内部再申明一个类</p><p>特点：使用时候要包裹者点出自己</p><p>作用：表现亲密关系</p><p>注意：访问修饰符的作用很大</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#">class Person&#123;    public int age;    public string name;    public Body body;    public class Body&#123;        Arm leftArm;        Arm rightArm;        class Arm&#123;                    &#125;    &#125;&#125;<br></code></pre></td></tr></table></figure><h5 id="2-13-2分部类"><a href="#2-13-2分部类" class="headerlink" title="2.13.2分部类"></a>2.13.2分部类</h5><p>概念：把一个类分成几部分申明</p><p>关键字：partial</p><p>作用：分部描述一个类，增加程序的拓展性</p><p>注意：分布类可以写在多个脚本文件中；分布类的访问修饰符要一致；分布类中不能有重复成员；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#">partial class Student&#123;    public bool sex;    public string name;&#125;partial class Student&#123;    public int number;    public void Speak()&#123;            &#125;&#125;<br></code></pre></td></tr></table></figure><h5 id="2-13-分部方法"><a href="#2-13-分部方法" class="headerlink" title="2.13.分部方法"></a>2.13.分部方法</h5><p>特点：我们可以一个分部类中申明这个分部方法，再在另一个分部类中去实现这个分部方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#">partial class Test&#123;    // 声明的方法    partial void Speak();&#125;partial class Test&#123;    partial void Speak()&#123;        // 实现的逻辑    &#125;&#125;<br></code></pre></td></tr></table></figure><h3 id="三-面向对象三大特性——继承"><a href="#三-面向对象三大特性——继承" class="headerlink" title="三.面向对象三大特性——继承"></a>三.面向对象三大特性——继承</h3><h4 id="3-1继承的基本概念"><a href="#3-1继承的基本概念" class="headerlink" title="3.1继承的基本概念"></a>3.1继承的基本概念</h4><p>概念：一个类A继承一个类B，类A将会继承类B的所有成员，A类将拥有B类的所有特征和行为，</p><p>被继承的类称呼为父类、基类、超类，继承的类称为子类、派生类；</p><p>*子类也可以有自己的成员、特征和行为</p><p>特点：</p><p>单根性：子类只能有一个父类；</p><p>传递性：子类可以间接继承父类的父类；</p><p>基本语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#">class A : B&#123;    &#125;<br></code></pre></td></tr></table></figure><p><em>*</em>注意：子类和父类运行存在同名成员，如果存在同名成员，一般使用其自身的成员，就是如果声明的是子类就使用子类的同名成员，如果是父类则是父类的同名成员。强烈不建议子类与父类之间存在同名成员，如果真的需要可以通过多态解决；</p><h4 id="3-2is和as"><a href="#3-2is和as" class="headerlink" title="3.2is和as:"></a>3.2is和as:</h4><p>基本概念：is是判断一个对象是否是指定类对象，返回值：bool,是为真，不是为假；</p><p>as是将一个对象转化为指定对象，成功返回执行类型对象，失败返回null。</p><p>基本语法：</p><p>类对象 is 类名 该语句块会有一个bool返回值；</p><p>类对象 as 类名 该语句块会有一个对象返回值；</p><h4 id="3-3继承中的构造函数"><a href="#3-3继承中的构造函数" class="headerlink" title="3.3继承中的构造函数"></a>3.3继承中的构造函数</h4><h5 id="3-3-1基础概念"><a href="#3-3-1基础概念" class="headerlink" title="3.3.1基础概念"></a>3.3.1基础概念</h5><p>当申明一个子类对象时候，先执行父类的构造函数，再执行子类的构造函数。</p><p>注意：1.父类的无参构造函数很重要；2.子类可以通过base关键字代表父类，调用父类构造函数。</p><h5 id="3-3-2继承中构造函数的执行顺序"><a href="#3-3-2继承中构造函数的执行顺序" class="headerlink" title="3.3.2继承中构造函数的执行顺序"></a>3.3.2继承中构造函数的执行顺序</h5><p>父类的父类的构造函数-&gt;父类的构造函数-&gt;子类的构造函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#">class GameObject&#123;    Console.WriteLine(&quot;父类的父类构造函数&quot;);&#125;class Person:GameObject&#123;    Console.WriteLine(&quot;父类构造函数&quot;);&#125;class Son:Person&#123;    Console.WriteLine(&quot;子类构造函数&quot;);&#125;class Program&#123;    Son s = new Son();&#125;================================结果：    父类的父类构造函数    父类构造函数    子类构造函数// 从结果上可以看出来，我们声明了一个子类，但是都是先从祖宗类开始向下执行其构造函数，最后再调用子类的构造函数<br></code></pre></td></tr></table></figure><h5 id="3-3-3父类的构造函数很重要"><a href="#3-3-3父类的构造函数很重要" class="headerlink" title="*3.3.3父类的构造函数很重要"></a>*3.3.3父类的构造函数很重要</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#">// 先给结论：当子类继承于父类时候，父类中必须有自身的构造函数，且必须存在无参构造函数，除非出现子类的构造函数指定了调用父类中的有参构造函数// 第一种写法// 这样，当我们new Son()的时候不会出现报错，因为当没有写入自定义的构造函数的时候，会调用系统默认的构造函数class Father&#123;    &#125;class Son:Father&#123;    &#125;// 第二种写法// 与第一种一样，不过因为我们自己写了构造函数，所以会顶替掉系统自带的构造函数class Father&#123;    public Father()&#123;    &#125;&#125;class Son:Father&#123;    &#125;// 第三种写法class Father&#123;// 我们声明了一个有参构造函数，这时候我们的父类已经不存在无参构造函数了，如果子类的构造函数种不指定调用父类的有参构造函数，那么我们的IDE是会报错的。    public Father(int i)&#123;            &#125;&#125;class Son:Father&#123;    // 指定调用父类的有参构造函数，base(i)表示调用父类的带参构造函数    public Son(int i):base(i)&#123;            &#125;    // 调用自身！自身！自身！的构造函数，this表示当前类对象，这句代码块表示this的代码重用。    public Son(int i, string str):this(i)&#123;            &#125;&#125;<br></code></pre></td></tr></table></figure><h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a><strong>总结</strong></h5><p>继承中的构造函数的调用遵循的规则是自顶向下，从祖宗类开始执行构造函数，但是，当我们自己在父类中写了自己定义的构造函数且不是无参构造函数的时候，我们就会失去了系统默认的无参构造函数，这时候，我们需要让继承至父类的子类，指定使用其定义的构造函数。</p><h4 id="3-4万物之父与装箱拆箱"><a href="#3-4万物之父与装箱拆箱" class="headerlink" title="3.4万物之父与装箱拆箱"></a>3.4万物之父与装箱拆箱</h4><h5 id="3-4-1万物之父"><a href="#3-4-1万物之父" class="headerlink" title="3.4.1万物之父"></a>3.4.1万物之父</h5><p>关键字：object</p><p>概念：object是所有类型的基类，它是一个类(引用类型)</p><p>作用：</p><p>1.可以利用里氏替换原则，用object容器装所有对象</p><p>2.可以用来表示不确定类型，作为函数参数类型</p><p>3.4.2万物之父的使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#">class Father&#123;    &#125;class Son&#123;    public void Speak()&#123;            &#125;&#125;class Program&#123;Father f = new Son();    if(f is Son)&#123;        (f as Son).Speak();    &#125;// 用万物之父实现装箱    // 引用类型装箱    object o = new Son();    if(o is Son)&#123;       (o as Son).Speak();     &#125;    // 值类型装箱    object o2 = 1f;        float f1 = (float)o2;    // 特殊的string类型    object str = &quot;123123&quot;;    // 第一种转法    string str2 = str.ToString();    // 第二种转法    string str3 = str as string;    // 特殊的数组    object arr  = new int[10];    // 第一种转法    int[] ar = (int[])arr;    // 第二种转法    int[] ar2 = arr as int[];&#125;===============    总结：    装箱拆箱的条件：用object存值类型(装箱)，再把object转为值类型(拆箱)    装箱：    把值类型用引用类型存储，栈内存会迁移到堆内存中。    拆箱：    把引用类型存储的值类型取出来，堆内存会迁移到栈内存中    好处：不确定类型时候可以方便方便参数的存储和传递    坏处：存在内存迁移，增加性能消耗<br></code></pre></td></tr></table></figure><h4 id="3-5密封类"><a href="#3-5密封类" class="headerlink" title="3.5密封类"></a>3.5密封类</h4><p>基本概念：密封类是使用sealed密封关键字修饰的类</p><p>作用：让类无法再被继承</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#">class Father&#123;    &#125;// 这时候这个Son这个类是无法被其他类继承的sealed class Son&#123;    &#125;<br></code></pre></td></tr></table></figure><p>总结：</p><p>在面向对象程序的设计中，密封类的主要作用就是不允许底层子类被继承，可以保证程序的规范性、安全性，以便制作复杂系统和框架的时候更方便；</p><h3 id="四-面向对象三大特性——多态"><a href="#四-面向对象三大特性——多态" class="headerlink" title="四.面向对象三大特性——多态"></a>四.面向对象三大特性——多态</h3><h4 id="4-1多态VOB的知识点"><a href="#4-1多态VOB的知识点" class="headerlink" title="4.1多态VOB的知识点"></a>4.1多态VOB的知识点</h4><h5 id="4-1-1基本概念"><a href="#4-1-1基本概念" class="headerlink" title="4.1.1基本概念"></a>4.1.1基本概念</h5><p>多态按字面的意思就是“多种状态”，让继承同一父类的子类们在执行相同方法时候有不同的表现(状态)，主要目的是同一父类的对象执行相同行为(方法)有不同的表现，主要的解决的问题是让同一对象具有唯一行为的特征。</p><h5 id="4-1-2多态的基本实现"><a href="#4-1-2多态的基本实现" class="headerlink" title="4.1.2多态的基本实现"></a>4.1.2多态的基本实现</h5><p>我们之前学过的函数重载其实就算是一张多态，只不过是编译时候的多态，是开始就写好的。我们现在要学习的多态是运行时多态(vob、抽象函数、接口)。</p><p>v——virtual（虚函数）、o——override（重写）、base（父类）</p><h4 id="4-2抽象类和抽象方法"><a href="#4-2抽象类和抽象方法" class="headerlink" title="4.2抽象类和抽象方法"></a>4.2抽象类和抽象方法</h4><h5 id="4-2-1抽象类"><a href="#4-2-1抽象类" class="headerlink" title="4.2.1抽象类"></a>4.2.1抽象类</h5><p>抽象类概念：被抽象的关键字abstract修饰的类</p><p>特点：</p><p>1.不能被实例化的类</p><p>2.可以包含抽象方法</p><p>3.继承抽象类必须重写其所有的抽象方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#">abstract class T&#123;    // 抽象类中 之前学过的封装的所有的知识点都可以在其中书写    public string name;    // 可以在抽象类中写抽象函数&#125;class A:T&#123;&#125;class Program&#123;    static void Main(string[] args)&#123;        // 抽象类不能被实例化        // T t = t new T();这是不被允许的        // 但是可以遵循里氏替换原则 用父类装子类        T t = new A();    &#125;&#125;==============================    总结：抽象类就相当于普通类+抽象方法，也就是它具备普通类的所有东西(不能被实例化)，并且还能写抽象函数(这是普通类不具备的特点)<br></code></pre></td></tr></table></figure><h5 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h5><p>抽象类更像是一种模板类，让子类继承父类，重写父类的抽象方法</p><h5 id="4-2-2抽象方法"><a href="#4-2-2抽象方法" class="headerlink" title="4.2.2抽象方法"></a>4.2.2抽象方法</h5><p>抽象方法：又叫纯虚方法，用abstract关键字修饰的方法</p><p>特点：</p><p>1.只能在抽象类中申明</p><p>2.没有方法体</p><p>3.不能是私有的</p><p>4.继承后必须实现用override重写</p><h4 id="4-3接口"><a href="#4-3接口" class="headerlink" title="4.3接口"></a>4.3接口</h4><h5 id="4-3-1概念"><a href="#4-3-1概念" class="headerlink" title="4.3.1概念"></a>4.3.1概念</h5><p><em>*</em>基本概念：接口是行为的抽象规范；它也是一种自定义类型。</p><p>关键字：interface</p><p>*接口申明的规范：</p><p>1.不包含成员变量</p><p>2.只包含方法、属性、索引器、事件</p><p>3.成员不能被实现</p><p>4.成员可以不用写访问修饰符，但是不能是私有的</p><p>5.接口不能继承类，但是可以继承另一个接口</p><p>*接口的使用规范：</p><p>1.类可以继承多个接口</p><p>2.类继承接口后，必须实现接口所有成员</p><p>特点：</p><p>1.它和类申明类似</p><p>2.接口是用来继承的</p><p>3.接口不能被实例化</p><h5 id="4-3-2接口的申明"><a href="#4-3-2接口的申明" class="headerlink" title="4.3.2接口的申明"></a>4.3.2接口的申明</h5><p>接口关键字：interface</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#">interface 接口名&#123;&#125;一句话记忆：接口是抽象行为的“基类”接口命名规范 帕斯卡前面加I<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#">interface IFly&#123;    // 不需要方法体(成员不能被实现)，跟抽象类一样，类继承接口后需要实现接口的所有成员    void Fly();    // 属性    string Name&#123;        // 成员不能被实现，所以get、set方法也不能被实现(不能有方法体)        get;        set;    &#125;    // 索引器    int this[int index]&#123;        get;        set;    &#125;    // 事件    event Action doSomething;&#125;<br></code></pre></td></tr></table></figure><h5 id="4-3-3接口的使用"><a href="#4-3-3接口的使用" class="headerlink" title="4.3.3接口的使用"></a>4.3.3接口的使用</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#">interface IFly&#123;    &#125;class Animal&#123;    &#125;class Person:Animal, IFly&#123;    &#125;<br></code></pre></td></tr></table></figure><h5 id="4-3-4接口可以继承接口"><a href="#4-3-4接口可以继承接口" class="headerlink" title="4.3.4接口可以继承接口"></a>4.3.4接口可以继承接口</h5><p>接口继承接口时，不需要去实现父类的成员，当有普通类去继承它时候，就必须实现所有成员。</p><h5 id="4-3-5显示实现接口"><a href="#4-3-5显示实现接口" class="headerlink" title="4.3.5显示实现接口"></a>4.3.5显示实现接口</h5><p>当一个类继承两个接口，但是接口中存在同名方法时，注意：显示实现接口时，不能写访问修饰符。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#">interface IAtk&#123;void Atk();    &#125;interface ISuperAtk&#123;    void Atk();&#125;class Player:IAtk, ISuperAtk&#123;    // 当我们继承两个或者多个接口时候，如果出现同名方法，我们需要使用显示实现接口    void IAtk.Atk()&#123;            &#125;    void ISuperAtk.Atk()&#123;            &#125;&#125;// *******但是用显示实现接口会存在缺点class Program&#123;    IAtk ia = new Player();    ISuperAtk isa = new Player();    ia.Atk();    isa.Atk();    // 缺点：    // 当我们实例化一个Player类的时候，我们无法点.出Atk()方法，因为Player方法继承的两个接口有同名方法，所有我们必须先把它转成指定的接口，再去使用其接口的方法    Player p = new Player();    (p as IAtk).Atk();    &#125;<br></code></pre></td></tr></table></figure><h5 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h5><p>继承类：是对象间的继承，包括特征行为等等</p><p>继承接口：是行为间的继承，继承接口的行为规范，按照规范去实现内容</p><p>由于接口也是遵循里氏替换原则，所有可以用接口容器装对象，那么就可以实现装载各种毫无关系但是却有相同行为的对象</p><p>注意：</p><p>1.接口只包含 成员方法、属性、索引器、事件、并且都不实现，都没有访问修饰符</p><p>2.可以继承多个接口，但是只能继承一个类</p><p>3.接口可以继承接口，但是只能继承一个类</p><p>4.接口可以被显示实现，主要用于实现不同接口中的同名函数的不同表现</p><p>5.实现的接口方法可以加virtual关键字之后子类再去重写</p><h4 id="4-4密封方法"><a href="#4-4密封方法" class="headerlink" title="4.4密封方法"></a>4.4密封方法</h4><p>概念：用密封关键字sealed修饰的重写函数</p><p>作用：让虚方法或者抽象方法之后不能再被重写</p><p>特点：和override一起出现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#">abstract class Animal&#123;    public string name;    public abstract void Eat();    public virtual void Speak()&#123;        Console.WriteLine(&quot;吃&quot;);    &#125;&#125;class Person:Animal&#123;    public override void Eat()&#123;            &#125;    public override void Speak()&#123;            &#125;&#125;class WhitePerson:Peron&#123;    public sealed override void Eat()&#123;            &#125;    public override void Speak()&#123;            &#125;&#125;class Son:WhitePerson&#123;    // 我们会发现无法实现Eat()的方法了，因为父类把Eat()方法用sealed修饰了    &#125;<br></code></pre></td></tr></table></figure><h3 id="五-面向对象面向对象的相关知识点"><a href="#五-面向对象面向对象的相关知识点" class="headerlink" title="五.面向对象面向对象的相关知识点"></a>五.面向对象面向对象的相关知识点</h3><h4 id="5-1命名空间"><a href="#5-1命名空间" class="headerlink" title="5.1命名空间"></a>5.1命名空间</h4><p>基本概念：命名空间是用来组织和重用代码的。</p><p>作用：就像是一个工具包，类就像是一件一件的工具，都是申明在命名空间中的。</p><p>命名空间的使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#">namespace 命名空间名&#123;    类    类&#125;// ***注意命名空间也遵循我们的分布类的规则，也就是我们可以使用同名的命名空间去写，它们是属于同一个命名空间的。// 同一命名空间下不允许存在不同类，但是不同命名空间下面允许同名类的存在// 如果不同命名空间中出现同名类的话，我们需要使用命名空间.出的方式指明使用哪个命名空间下的类namespace MyGame&#123;class T1&#123;            &#125;&#125;namespace MyGame1&#123;    class T1&#123;            &#125;&#125;// 命名空间的引用// 第一种：using + 命名空间名// 第二种：命名空间 + 类名// 不同命名空间中允许有同名类namespace MyGame&#123;    namespace UI&#123;            &#125;    namespace Game&#123;            &#125;&#125;=======================================<br></code></pre></td></tr></table></figure><h5 id="拓展："><a href="#拓展：" class="headerlink" title="拓展："></a>拓展：</h5><p>1.命名空间中的类默认为Public；</p><p>2.Internal只能在该程序集中使用；</p><h4 id="5-2万物之父中的方法"><a href="#5-2万物之父中的方法" class="headerlink" title="5.2万物之父中的方法"></a>5.2万物之父中的方法</h4><h5 id="5-2-1object中的静态方法"><a href="#5-2-1object中的静态方法" class="headerlink" title="5.2.1object中的静态方法"></a>5.2.1object中的静态方法</h5><p>1.object.Equals()判断两个对象是否相等，最终的判断权，交给左侧对象的Equals方法,不管是值类型还是引用类型都会按照左侧对象Equals方法的规则来进行比较。</p><p><em>*</em>注意：值类型判断是否相等是比较它们的数值，引用类型判断是否相等是指它们的地址是否相等，而不是都是同一个类型实例化。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#">class Programe&#123;    Test t = new Test();    Test t2 = t;    Console.WriteLine(object.Equals(t, t2));    =========================    结果：True    这里比较的是地址是否相等，而非比较是否都是Test类型的实例化。       &#125;<br></code></pre></td></tr></table></figure><p>2.object.ReferenceEquals()，这个是专门用于比较引用类型的，如果传入值类型，结果会永远是False,而且两个引用类型比较的也是地址的比较。</p><h5 id="5-2-2object中的成员方法"><a href="#5-2-2object中的成员方法" class="headerlink" title="5.2.2object中的成员方法"></a>5.2.2object中的成员方法</h5><p>1.object.GetType()该方法在反射相关知识点中是非常重要的方法，之后我们会具体的讲解这里返回的Type类型，该方法的主要作用就是获取对象运行时的类型Type,通过Type结合反射相关知识点可以做很多关于对象的操作。</p><p>2.object.MemberwiseClone()该方法用于获取对象的浅拷贝对象，口语化讲解的意思就是会返回一个新的对象，但是新对象中的引用类型变量会和老对象保持一致，而值类型的不会。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#">class Test&#123;    public int i = 1;    public Test t2 = new Test();        public Test Clone()&#123;        return MemberwiseClone() as Test;    &#125;&#125;class Test2&#123;    public int i = 2;&#125;class Programe&#123;    Test t = new Test();    Test t2 = t.Clone();    Console.WriteLine(&quot;克隆对象后&quot;);    Console.WriteLine(&quot;t.i = &quot; + t.i);    Console.WriteLine(&quot;t.t2.i = &quot; + t.t2.i);    Console.WriteLine(&quot;t2.i = &quot; + t2.i);    Console.WriteLine(&quot;t2.t2.i = &quot; + t2.t2.i);        t2.i = 20;    t2.t2.i = 21;        Console.WriteLine(&quot;改变克隆体信息后&quot;);    Console.WriteLine(&quot;t.i = &quot; + t.i);    Console.WriteLine(&quot;t.t2.i = &quot; + t.t2.i);    Console.WriteLine(&quot;t2.i = &quot; + t2.i);    Console.WriteLine(&quot;t2.t2.i = &quot; + t2.t2.i);    ============================================    结果：        克隆对象后        t.i = 1        t.t2.i = 2        t2.i = 1        t2.t2.i = 2        改变克隆体信息后        t.i = 1        t.t2.i = 21        t2.i = 20        t2.t2.i = 21&#125;<br></code></pre></td></tr></table></figure><h5 id="5-2-3object中的虚方法"><a href="#5-2-3object中的虚方法" class="headerlink" title="5.2.3object中的虚方法"></a>5.2.3object中的虚方法</h5><p>1.虚方法Equals():默认实现还是比较两者是否同为一个引用，即相当于ReferenceEquals()。但是微软在所有值类型的基类System.ValueType中重写了该方法，用来比较值相等。我们也可以重写该方法，定义自己的比较相等的规则。</p><p>2.虚方法GetHashCode():该方法是获取对象的哈希码(一种通过算法算出的，表示对象的唯一编码，不同对象的哈希码有可能一样，具体值根据哈希算法决定)，我们可以通过重写该函数来定义自己对象的哈希码算法，正常情况下，我们使用的极少，基本不用。</p><p>3.虚方法ToString():该方法用于返回当前对象代表的字符串，我们可以重写它定义我们自己的对象转字符串规则，该方法非常常用，当我们调用打印方法时候，默认使用的就是对象的ToString方法后打印出来的内容。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#">namespace XXZ&#123;    class Test&#123;            &#125;    class Programe&#123;        void Main()&#123;            Test t = new Test();        Console.WriteLine(t);            =======================            结果：XXZ.Test            我们发现，我们的Test中并没有ToString方法，说明，我们调用了所有的类之父Object中的ToString方法，并且从结果我们可以看出，我们的打印出来的是所属的命名空间下的类。                          Random r = new Random();                Console.WriteLine(r);                ==========================             结果：System.Random        &#125;    &#125;&#125;<br></code></pre></td></tr></table></figure><h4 id="5-3string知识点"><a href="#5-3string知识点" class="headerlink" title="5.3string知识点"></a>5.3string知识点</h4><h5 id="5-3-1字符串指定位置获取"><a href="#5-3-1字符串指定位置获取" class="headerlink" title="5.3.1字符串指定位置获取"></a>5.3.1字符串指定位置获取</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#">// ***C#中一个char类型占2个字节大小，C和C++中一个char类型占一个字节大小// 字符串的本质是char类型数组string str = “小小泽”;Console.WriteLine(str[0]);结果：小char[] chars = str.ToCharArray();Console.WriteLine(char[2]);结果：泽for(int i = 0;i&lt;str.Length;i++)&#123;    Console.WriteLine(str[i]);&#125;结果：小小泽<br></code></pre></td></tr></table></figure><h5 id="5-3-2字符串拼接"><a href="#5-3-2字符串拼接" class="headerlink" title="5.3.2字符串拼接"></a>5.3.2字符串拼接</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#">string str = string.Format(&quot;&#123;0&#125;&#123;1&#125;&quot;,1 ,333);Console.WriteLine(str);<br></code></pre></td></tr></table></figure><h5 id="5-3-3正向查找字符位置"><a href="#5-3-3正向查找字符位置" class="headerlink" title="5.3.3正向查找字符位置"></a>5.3.3正向查找字符位置</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#">string str = &quot;小小泽&quot;;int index = str.IndexOf(&quot;小&quot;);Console.WriteLine(index);结果：0index = str.IndexOf(&quot;泽&quot;);Console.WriteLine(index);结果：2    index = str.IndexOf(&quot;屌&quot;);Console.WriteLine(index);结果：-1==============================结论：str.IndexOf(string str)会返回从头遍历到的第一个字符的索引下标返回出去,找不到就返回-1；<br></code></pre></td></tr></table></figure><h5 id="5-3-4反向查找指定字符串位置"><a href="#5-3-4反向查找指定字符串位置" class="headerlink" title="5.3.4反向查找指定字符串位置"></a>5.3.4反向查找指定字符串位置</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#">string str = &quot;小小泽小小泽&quot;;int index = str.LastIndexOf(&quot;小小泽&quot;);Console.WriteLine(inde);结果：3index = str.LastIndexOf(&quot;泽泽&quot;);Console.WriteLine(index);结果：-1===============================结论：str.LastIndexOf(string str)是从字符串的尾部开始遍历，找到就返回该对象在次数组中的下标，没有就返回-1；<br></code></pre></td></tr></table></figure><h5 id="5-3-5移除指定位置后的字符"><a href="#5-3-5移除指定位置后的字符" class="headerlink" title="5.3.5移除指定位置后的字符"></a>5.3.5移除指定位置后的字符</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#">string str = &quot;我是小小泽小小泽&quot;;// 会把第四个位置(包括第四个)后面的字符全部删除str = str.Remove(4);Console.WriteLine(str);结果：我是小小    // 执行两个参数进行移除// 参数1 开始位置， 参数2 字符个数str  = str.Remove(1,1);Console.WriteLine(str);结果：我小小泽小小泽<br></code></pre></td></tr></table></figure><h5 id="5-3-6替换指定字符串"><a href="#5-3-6替换指定字符串" class="headerlink" title="5.3.6替换指定字符串"></a>5.3.6替换指定字符串</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#">string str = &quot;我是小小泽小小泽&quot;;str = str.Replace(&quot;小小泽&quot;,&quot;大哥大&quot;);Console.WriteLine(str);结果：我是大哥大大哥大<br></code></pre></td></tr></table></figure><h5 id="5-3-7大小写转换"><a href="#5-3-7大小写转换" class="headerlink" title="5.3.7大小写转换"></a>5.3.7大小写转换</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#">string str = &quot;asdawqdasdqwdasdqw&quot;;str = str.ToUpper();Console.WriteLine(str);// 结果就是全部变成大写的，原来的大写不变str = str.ToLower();Console.WriteLine(str);// 结果就是全部变成小写的，原来的小写不变<br></code></pre></td></tr></table></figure><h5 id="5-3-8字符串截取"><a href="#5-3-8字符串截取" class="headerlink" title="5.3.8字符串截取"></a>5.3.8字符串截取</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#">string str = &quot;小小泽小小泽&quot;;// 截取从指定位置开始之后的字符串str = str.Substring(2);Console.WriteLine(str);结果：泽小小泽    // 参数1 开始的位置， 参数2 指定个数str = str.Substring(2, 2);<br></code></pre></td></tr></table></figure><h5 id="5-3-9-字符串切割"><a href="#5-3-9-字符串切割" class="headerlink" title="5.3.9*字符串切割"></a>5.3.9<em>*</em>字符串切割</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#">string str = &quot;1, 2, 3, 4, 5, 6, 7, 8&quot;;// 以逗号切割字符串string[] strs = str.Split(&#x27;,&#x27;);<br></code></pre></td></tr></table></figure><h4 id="5-4StringBuilder知识点"><a href="#5-4StringBuilder知识点" class="headerlink" title="5.4StringBuilder知识点"></a>5.4StringBuilder知识点</h4><p>StringBuilder是C#提供的一个用于处理字符串的公共类。</p><p>主要解决的问题是：修改字符串而不创建新的对象，需要频繁修改和拼接的字符串可以使用它，可以提升性能。使用前，需要引用命名空间。</p><p>初始化：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#">// StringBuilder自身是有许多构造方法的，这里举一个例子：我们直接传值StringBuilder str = new StringBuilder(&quot;123123123&quot;);// 默认的StringBuilder的大小是16，每次超过容量大小就自动扩容两倍// 获取容量Conosle.WriteLine(str.Capacity);// 我们也可以在初始化的时候直接给予一个初始容量大小StringBuilder str1 = new StringBuilder(&quot;123123&quot;,100);// ***注意，我们得到的长度是它自身存储的字符串长度Console.WriteLine(str1.Length);结果：6    // 增删改查// 增// 这个是直接从尾部插入str.Append(&quot;44444&quot;);// 这个是在尾部插入str.AppendFormat(&quot;&#123;0&#125;&#123;1&#125;&quot;, 100, 999);// 这个是在指定位置是插入// 参数1 指定位置， 参数2 插入的字符串str.Insert(0, &quot;1231233&quot;);// 删// 参数1 起始位置(从哪里开始删除), 参数2 删除的个数(删多少个)str.Remove(0, 10);// 表示从最开始位置开始删除，删除10个长度大小// 清空str.Clear();// 查Console.WriteLine(str[0]);// 改// 在string当中，我们这种中括号的形式是无法修改的，因为string默认是只读的，但是在StringBuilder中，我们是可以修改的str[0] = &#x27;A&#x27;;// 替换// 参数1 要被替换的字符, 参数2 替换后的字符str.Replace(&quot;1&quot;, &quot;2&quot;);<br></code></pre></td></tr></table></figure><p>结论：StringBuilder也会产生垃圾——当我们要存储的内容超过了它的容量的时候，为了扩容，StringBuilder会重新创建一个比之前大两倍的容量的内存，而之前的那个则作为垃圾被遗弃了，但是它会因为不断的扩容造成的垃圾是越来越少，而且，StringBuilder比String最大的优势是，它的增删改查替换都是基于它自身的索引器改变自身的值的，不像String，修改之后还要作为右值返回给原来的字符串，然后每次操作之后就会产生垃圾，而StringBuilder的每次操作则不会产生垃圾。</p><h4 id="5-5结构体和类的区别"><a href="#5-5结构体和类的区别" class="headerlink" title="5.5结构体和类的区别"></a>5.5结构体和类的区别</h4><p>区别概述：结构体和类最大的区别是存储空间上的区别，因为结构体是值类型，类是引用类型，因此它们在存储位置是不同的，一个在栈上，一个在堆上；结构体和类在使用上很类似，结构体甚至可以用面向对象的思想来形容一类对象。结构体具备着面向对象思想中的封装特性，但是它不具备继承和多态的特性，因此大大减少了它的使用频录。由于结构体不具备继承的特性，所以它不能够使用protected保护访问修饰符。</p><h6 id="细节区别"><a href="#细节区别" class="headerlink" title="细节区别"></a>细节区别</h6><p>1.结构体是值类型，类是引用类型</p><p>2.结构体存在栈中，类存在堆中</p><p>3.结构体成员不能使用protected访问修饰符，而类可以</p><p>4.结构体成员变量申明不能指定初始值，而类可以</p><p>5.结构体不能申明无参的构造函数，而类可以</p><p>6.结构体申明有参构造函数后，无参构造函数不会被顶替</p><p>7.结构体不能申明析构函数，而类可以</p><p>8.结构体不能被继承，而类可以</p><p>9.结构体需要在构造函数中初始化所有成员变量，而类随意</p><p>10.结构体不能被静态static修饰(不存在静态结构体)，而类可以</p><p>11.结构体不能在自己内部申明和自己一样的结构体变量，而类可以</p><h6 id="结构体的特别之处"><a href="#结构体的特别之处" class="headerlink" title="结构体的特别之处"></a>结构体的特别之处</h6><p><strong>结构体可以继承接口，因为接口是行为的抽象</strong></p><h6 id="如何选择结构体和类"><a href="#如何选择结构体和类" class="headerlink" title="如何选择结构体和类"></a>如何选择结构体和类</h6><p>1.想要用继承和多态时候，直接淘汰结构体，比如玩家、怪物等等</p><p>2.对象数据集合时，优先考虑结构体，比如位置、坐标等等</p><p>3.从值类型和引用类型赋值时的区别上去考虑，比如经常被赋值传递的对象，并且改变赋值对象，原对象不想跟着变化时，就用结构体。比如坐标、向量、旋转等等。</p><h4 id="5-6抽象类和接口的区别"><a href="#5-6抽象类和接口的区别" class="headerlink" title="5.6抽象类和接口的区别"></a>5.6抽象类和接口的区别</h4><h6 id="知识回顾"><a href="#知识回顾" class="headerlink" title="知识回顾"></a>知识回顾</h6><p>抽象类和抽象方法：abstract修饰的类和方法，抽象类不能实例化，抽象方法只能在抽象类中申明，是个纯虚方法，必须在子类中实现</p><p>接口：interface自定义类型，是行为的抽象，不包含成员变量，仅包含方法、属性、索引器、事件、成员都不能实现，建议不写访问修饰符，默认public。</p><h6 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h6><p>1.都可以被继承</p><p>2.都不能被直接实例化</p><p>3.都可以包含方法申明</p><p>4.子类必须实现未实现的方法</p><p>5.都遵循里氏替换原则</p><h6 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h6><p>1.抽象类中可以有构造函数；接口不行</p><p>2.抽象类只能被单一继承；接口可以被继承多个</p><p>3.抽象类中可以有成员变量；接口不能</p><p>4.抽象类中可以申明成员方法，虚方法，抽象方法，静态方法；接口中只能申明没有实现的抽象方法</p><p>5.抽象类方法可以使用访问修饰符；接口中建议不写，默认public</p><p>如何选择抽象类和接口：</p><p>表示对象的用抽象类，表示拓展的用接口，不同对象拥有的共同行为，我们往往可以使用接口来实现。</p><p>举个例子：</p><p>动物是一类对象，我们自然会选择抽象类；而飞翔是一个行为，我们自然会选择接口。</p>]]></content>
    
    
    <categories>
      
      <category>CSharp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSharp</tag>
      
      <tag>编程语言</tag>
      
      <tag>面对对象编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>粘包和拆包</title>
    <link href="/2021/12/23/%E7%B2%98%E5%8C%85%E5%92%8C%E6%8B%86%E5%8C%85/"/>
    <url>/2021/12/23/%E7%B2%98%E5%8C%85%E5%92%8C%E6%8B%86%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h1 id="粘包和拆包-解决方法"><a href="#粘包和拆包-解决方法" class="headerlink" title="粘包和拆包 解决方法"></a>粘包和拆包 解决方法</h1><h2 id="拆包-粘包"><a href="#拆包-粘包" class="headerlink" title="拆包 粘包"></a>拆包 粘包</h2><p>当客户端向服务器连续发送两个数据包后，服务端接收数据可以分成三种情况</p><p>一、服务端正常的收到这两个数据包 没有发生粘包和拆包的情况</p><p>二、服务端只接收到一个数据包 ，而TCP是不会发生丢包的情况的，所以这一个数据包就包含了客户端发送的两个数据包 这就被称为粘包。</p><p>发送的时候，数据是有一个数据缓冲区的，比如数据缓冲区是200，我们一个包是100 就会把缓冲区填满，填满之后呢 我们数据缓冲区就会把这个包发送出去，这两个包呢就会被粘在一起，合并成了一个发送。相当于我们人发快递，发送两根笔，一根笔是一份快递钱，那么我们就会把两根笔合成一份快递发送。而缓冲区呢，当第一次没有填满，那么它就会等到填满了，一块往服务端发送，这样就出现粘包的问题。</p><p>三、服务端接收到了两个数据包，但是这两个数据包，会出现要么不完整，或者多出来一部分的情况，这种情况呢就是发生了拆包和粘包。</p><p>就相当于在数据缓冲区中，我们数据缓冲区是200，而我们一个包的长度呢是150 这时候进入缓冲区，而缓冲区没有被填满，就会等待填满，而缓冲区填满后就出现了另外一个数据包不全的情况 一个数据包多出了一部分 这就是发生了拆包和粘包</p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>粘包、拆包发生原因 （常见几种）</p><ol><li><p>要发送的数据大于TCP发送缓冲区剩余空间大小，将会发生拆包。</p></li><li><p>待发送数据大于最大报文长度，TCP在传输前将进行拆包。</p></li><li><p>要发送的数据小于TCP发送缓冲区的大小，TCP将多次写入缓冲区的数据一次发送出去，将会发生粘包。</p></li><li><p>接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包。</p></li></ol><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>发送端给每一个数据包构造一个包头与包尾，包头内包含了数据包的长度，包尾才是真正的数据包 当接收端接收到数据包后，首先先读取数据包的前四个字节（int值只占四个字节）拿到数据包的长度后，再往后依次读取我们的数据包。</p><h2 id="构造包和解析包"><a href="#构造包和解析包" class="headerlink" title="构造包和解析包"></a>构造包和解析包</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs c#">using System;<br>using System.Collections.Generic;<br>using System.IO;<br>using System.Linq;<br>using System.Text;<br>using System.Threading.Tasks;<br><br>namespace MyServer<br>&#123;<br>    /// &lt;summary&gt;<br>    /// /构造包 包头+包尾<br>    /// &lt;/summary&gt;<br>   public class EncodeTool<br>    &#123;<br>        public static byte[] EncodePacket(byte[] data)<br>        &#123;<br>            using (MemoryStream ms = new MemoryStream())<br>            &#123;<br>                using (BinaryWriter bw=new BinaryWriter(ms))<br>                &#123;<br>                    //写入包头（数据的长度）<br>                    bw.Write(data.Length);<br>                    //写入包尾（数据）<br>                    bw.Write(data);<br>                    byte[] packet = new byte[ms.Length];<br>                    Buffer.BlockCopy(ms.GetBuffer(), 0, packet, 0, (int)ms.Length);<br>                    return packet;<br>                &#125;<br>            &#125;<br>        &#125;<br>        /// &lt;summary&gt;<br>        /// /解析包，从缓冲区里取出一个完整的包<br>        /// &lt;/summary&gt;<br>        /// &lt;param name=&quot;cache&quot;&gt;&lt;/param&gt;<br>        /// &lt;returns&gt;&lt;/returns&gt;<br><br>        public static byte[] DecodePacket(ref List&lt;byte&gt; cache)<br>        &#123;<br>            //如果数据长度小于四个字节，说明没有包<br>            if (cache.Count &lt; 4)<br>            &#123;<br>                return null;<br>            &#125;<br>            using (MemoryStream ms=new MemoryStream(cache.ToArray()))<br>            &#123;<br>                using(BinaryReader br=new BinaryReader(ms))<br>                &#123;<br>                    //读取包的长度<br>                    int length = br.ReadInt32();<br>                    //当前的长度减去，读取字节后游标的长度，就是包的数据 <br>                    int remainLength = (int)(ms.Length - ms.Position);<br>                    if (length &gt; remainLength)<br>                    &#123;<br>                        //如果大于减去后的长度麻将构不能一个包<br>                        return null;<br>                    &#125;<br>                    byte[] data = br.ReadBytes(length);<br>                    //更新缓冲数据<br>                    cache.Clear();<br>                    cache.AddRange(br.ReadBytes(remainLength));<br>                    return data;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CSharp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>花里胡哨</tag>
      
      <tag>计算机网络</tag>
      
      <tag>Socket</tag>
      
      <tag>CSharp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C#Socket连接</title>
    <link href="/2021/12/23/C-Socket%E8%BF%9E%E6%8E%A5/"/>
    <url>/2021/12/23/C-Socket%E8%BF%9E%E6%8E%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="C-实现Socket连接"><a href="#C-实现Socket连接" class="headerlink" title="C#实现Socket连接"></a>C#实现Socket连接</h1><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><ol><li><p>建立Socket</p><p>AddressFamily.InterNetwork内网，SocketType.Stream以流来通信，Tcp为协议</p></li><li><p>电脑主机和端口和ip地址进行绑定</p></li><li><p>监听客户端连接</p></li><li><p>阻塞方法  生成Socket 接受客户端连接</p></li><li><p>声明数组，存放聊天的缓冲区。</p></li><li><p>使用while方法 , 接收数据并存放在数组中 实现多次接消息</p></li><li><p>还原接收信息为明文</p></li><li><p>实现客服给客户发消息</p></li></ol><h3 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c#">using System;<br>using System.Net;<br>using System.Net.Sockets;<br>using System.Text;<br><br>namespace SocketDemo<br>&#123;<br>    class Program<br>    &#123;<br>        static void Main(string[] args)<br>        &#123;<br>            //创建Socket 相当于是通信的主机<br>            //监听打进来的电话，并转接给客服<br>            Socket serverSocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);<br><br>            //绑定ip和端口<br>            EndPoint iped = IPEndPoint.Parse(&quot;192.168.43.227:1234&quot;);<br>            serverSocket.Bind(iped);<br><br>            //监听有没有电话连接，顺便规划客服人数,如果是0就是无限个客服<br>            serverSocket.Listen(100);<br><br>            //接电话<br>            //分配客服和客户进行一对一通信<br>            //阻塞方法 没有电话打进来，那么代码就执行到这里 Accept<br>            Socket kefuScoket = serverSocket.Accept();<br>            System.Console.WriteLine(&quot;客户的本地端口是：&quot; + kefuScoket.LocalEndPoint.ToString());<br>            System.Console.WriteLine(&quot;打电话进来的客户端是：&quot; + kefuScoket.RemoteEndPoint.ToString());<br><br>            //接消息，需要一个消息的缓冲区<br>            byte[] readBuff = new byte[1024];<br><br>            while (true)<br>            &#123;<br>                //消息拿到，并存放在缓冲区，并记住消息的长度<br>                int receiveCount = kefuScoket.Receive(readBuff);<br>                string receiveMessage = Encoding.UTF8.GetString(readBuff, 0, receiveCount);<br>                System.Console.WriteLine(&quot;客户端发过来的消息：&quot; + receiveMessage);<br><br>                //string backMessage = &quot;我是你的专属客服，有什么可以帮助你的&quot;;<br>                kefuScoket.Send(Encoding.UTF8.GetBytes(&quot;服务器已经接到你发来的消息：&quot; + receiveMessage));<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><ol><li>建立Socket</li><li>Connect连接服务端</li><li>try catch语句 捕捉异常</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c#">using System;<br>using System.Net;<br>using System.Net.Sockets;<br>using System.Text;<br><br>namespace clientSocket<br>&#123;<br>    class Program<br>    &#123;<br>        static void Main(string[] args)<br>        &#123;<br>            Console.WriteLine(&quot;Hello World!&quot;);<br><br>            Socket clientSocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);<br>            //接收服务器的回馈<br>            byte[] readBuff = new byte[1024];<br><br>            //连接服务器<br>            clientSocket.Connect(&quot;192.168.43.227&quot;, 1234);<br><br>            //连接上服务器，就能发消息<br>            string sendMessage;<br><br>            //计数器<br>            int num = 0;<br><br>            while (true)<br>            &#123;<br>                if (num == 0)<br>                &#123;<br>                    sendMessage = &quot;你好，我是192用户&quot;;<br>                    num++;<br>                &#125;<br>                else<br>                &#123;<br>                    sendMessage = Console.ReadLine();<br>                &#125;<br><br>                //转码，转成0101010的格式<br>                byte[] sendBytes = Encoding.UTF8.GetBytes(sendMessage);<br><br>                //把二进制的消息发出去<br>                clientSocket.Send(sendBytes);<br>                int count = clientSocket.Receive(readBuff);<br>                System.Console.WriteLine(&quot;服务器发送的消息是：&quot; + Encoding.UTF8.GetString(readBuff, 0, count));<br><br>            &#125;<br><br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="C-Socket各种类"><a href="#C-Socket各种类" class="headerlink" title="C#Socket各种类"></a>C#Socket各种类</h4><p>一、IP地址操作类</p><p>1、IPAddress类</p><p>在该类中有一个Parse()方法，可以把点分的十进制转换成IPAddress类，方法1如下：IPAddress address=IPAddress.Parse(“192.168.0.1”);</p><p>IPAddress 提供4个只读字段</p><ol><li>Any 用于代表本地系统可用的任何IP地址 常用来表示本机所有的IP地址 方便于对Socket服务进行监听，</li><li>Broadcase用于代表本地网络的IP广播地址 UDP的IP广播</li><li>Loopback用于代表系统的回送地址</li><li>None用于代表系统是没有网络接口</li></ol><p>2、IPEndPoint类</p><p>我们可以通过二种构造方法创建IPEndPoint类   就是一个IP地址端口的绑定 可以代表一个服务，用来Socket通讯</p><p>a、IPEndPoint(long address,int port)</p><p>b、IPEndPoint(IPAddress address,int port)</p><p>四种属性：Address  AddressFamily Port MaxPort  MinPort</p><p>二、DNS相关类</p><p>DNS类有四个静态方法，来获取主机DNS相关信息</p><ol><li>GetHostName（） 通过DNS.GetHostName()可以获得本地计算机的主机名</li><li>GetHostByName() 根据主机名称，返回一个IPHostEntry对象：IPHostEntry GetHostByName(string hostName) 其中IPHostEntry 把一个DNS主机名与一个别名和IP地址的数组相关联，包括三个属性：AddressList：一个IPAddress对象的数组   Aliases：一个字符串对象数组 HostName一个用于主机名的字符串对象</li><li>GetHostByAddress() 类似于GetHostByName(),只不过这里的参数是IP地址，而不是主机名，返回一个IPHostEntry对象。  IPHostEntry GetHostByAddress(IPAddress address)   IPHostEntry GetHostByAddress(string address)</li><li>Resolve()   当我们不知道输入的主机的地址是哪种格式时，用以上两种方法来实现，我们可能还要通过判断客户输入的格式，才能正确使用，但DNS类提供更简单的方法Resolve（），该方法可以接收或者是主机名格式或者是IP地址格式的任何一种地址，并返回IPHostEntry对象</li></ol>]]></content>
    
    
    <categories>
      
      <category>CSharp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>花里胡哨</tag>
      
      <tag>计算机网络</tag>
      
      <tag>Socket</tag>
      
      <tag>CSharp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络知识点</title>
    <link href="/2021/12/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <url>/2021/12/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h2 id="计算机网络知识点（一）"><a href="#计算机网络知识点（一）" class="headerlink" title="计算机网络知识点（一）"></a>计算机网络知识点（一）</h2><h4 id="三种常见的计算机体系结构"><a href="#三种常见的计算机体系结构" class="headerlink" title="三种常见的计算机体系结构"></a>三种常见的计算机体系结构</h4><ul><li>OSI分层（7层）：物理层 数据链路层 网络层 传输层 会话层 表示层 应用层</li><li>TCP/IP分层（4层）：网络接口层 网际层  运输层 应用层</li><li>五层协议（5层）：物理层 数据链路层 网络层 运输层 ‘应用层</li></ul><h4 id="每一层的协议如下"><a href="#每一层的协议如下" class="headerlink" title="每一层的协议如下"></a>每一层的协议如下</h4><ul><li>物理层：RJ45、CLOCK、IEEE802.3 （中继器，集线器，网关）</li><li>数据链路：PPP、FR、HDLC、VLAN、MAC （网桥，交换机）</li><li>网络层：IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP、 （路由器） </li><li>传输层：==TCP、UDP==、SPX</li><li>会话层：NFS、SQL、NETBIOS、RPC </li><li>表示层：JPEG、MPEG、ASII </li><li>应用层：FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS</li></ul><h4 id="每一层的作用如下"><a href="#每一层的作用如下" class="headerlink" title="每一层的作用如下"></a>每一层的作用如下</h4><ul><li><p>物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）</p></li><li><p>数据链路层：将比特组装成帧和点到点的传递（帧Frame） </p></li><li><p>网络层：负责数据包从源到宿的传递和网际互连（包PackeT）</p></li><li><p>传输层：提供端到端的可靠报文传递和错误恢复（段Segment） </p></li><li><p>会话层：建立、管理和终止会话（会话协议数据单元SPDU） </p></li><li><p>表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）</p></li><li><p>应用层：允许访问OSI环境的手段（应用协议数据单元APDU）</p></li></ul><h4 id="IP地址的分类"><a href="#IP地址的分类" class="headerlink" title="IP地址的分类"></a>IP地址的分类</h4><p> IP地址由32位组成，前面16位为网络号，后面16位为主机号</p><ul><li>A类地址：以0开头， 第一个字节范围：0~127（1.0.0.0 - 126.255.255.255）；</li><li>B类地址：以10开头， 第一个字节范围：128~191（128.0.0.0 - 191.255.255.255）； </li><li>C类地址：以110开头， 第一个字节范围：192~223（192.0.0.0 - 223.255.255.255）； </li><li>==IP地址与子网掩码相与得到主机号==</li></ul><h4 id="ARP-amp-RAPR-ARP是地址解析协议，-工作原理"><a href="#ARP-amp-RAPR-ARP是地址解析协议，-工作原理" class="headerlink" title="ARP &amp; RAPR ARP是地址解析协议，(工作原理)"></a>ARP &amp; RAPR ARP是地址解析协议，(工作原理)</h4><p>每一个主机中都会在ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址之间的对应关系。 2. 源地址发送数据时，首先查表，有则发包，无则广播，向本网段的所有主机发送ARP数据包。 3. 本网段其他主机收到时，检查包内IP地址是否为自己的IP地址，如果是，写入或者覆盖ARP列表， 然后将自己的MAC地址写入ARP响应包，告诉源地址 4. 源主机找到ARP响应包。根据ARP地址解析协议工作</p><h4 id="针对不同包的解决方式"><a href="#针对不同包的解决方式" class="headerlink" title="针对不同包的解决方式"></a>针对不同包的解决方式</h4><ol><li>已知包，直接发</li><li>广播包 广播发 ，每一个主机都响应（255.255.255.255）</li><li>未知包 广播查找 查找到后 目标地址响应</li></ol><h4 id="描述RARP"><a href="#描述RARP" class="headerlink" title="描述RARP"></a>描述RARP</h4><p>RARP是逆地址解析协议，作用是完成硬件地址到IP地址的映射，主要用于无盘工作站，因为给无盘工作 站配置的IP地址不能保存。工作流程：在网络中配置一台RARP服务器，里面保存着IP地址和MAC地址的 映射关系，当无盘工作站启动后，就封装一个RARP数据包，里面有其MAC地址，然后广播到网络上 去，当服务器收到请求包后，就查找对应的MAC地址的IP地址装入响应报文中发回给请求者。因为需要 广播请求报文，因此RARP只能用于具有广播能力的网络</p><h4 id="各种协议"><a href="#各种协议" class="headerlink" title="各种协议"></a>各种协议</h4><ul><li>ICMP协议：因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间 传递控制消息 </li><li>TFTP协议：是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不 复杂、开销不大的文件传输服务</li><li>HTTP协议：超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的方式， 适用于分布式超媒体信息系统 </li><li>DHCP协议：动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置参数手段 NAT协议：网络地址转换属接入广域网(WAN)技术，是一种将私有（保留）地址转化为合法IP地址 的转换技术 </li><li>DHCP协议：一个局域网的网络协议，使用UDP协议工作，用途：给内部网络或网络服务供应商自 动分配IP地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>花里胡哨</tag>
      
      <tag>计算机网络</tag>
      
      <tag>Socket</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络基础</title>
    <link href="/2021/12/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
    <url>/2021/12/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机网络基础"><a href="#计算机网络基础" class="headerlink" title="计算机网络基础"></a>计算机网络基础</h1><h2 id="OSI-TCP-UDP"><a href="#OSI-TCP-UDP" class="headerlink" title="OSI TCP UDP"></a>OSI TCP UDP</h2><p><img src="https://cdn.jsdelivr.net/gh/xichujn/image/img/image-20210320171236732.png" alt="osi"></p><p>OSI七层协议除了最高层，下面每一层都给上面一层提供服务。</p><p>TCP面向连接（如打电话要先拨号建立连接）；UDP是无连接的既发送数据之前不需要建立连接</p><p>TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达；UDP尽最大努力交付，既不保证可靠交付。（QQ和微信通话就是UDP，因为不需要保证可靠的交付，服务器是TCP，因为要保证客户数据无差错的 不丢失的）</p><p>TCP面向 字节流，实际上是TCP把数据看成一连串无结构的字节流；UDP是面向报文</p><p>每一条TCP连接只能是点到点的；UDP支持一对一，一对多，多对一和多对多的交互通信</p><h2 id="IP-端口号"><a href="#IP-端口号" class="headerlink" title="IP 端口号"></a>IP 端口号</h2><p>主机是有一个IP地址的，主机与主机之间想要互相通信，联系的话，就需要通过IP地址，服务器要给客户端发送一个消息的话，服务器如果想要识别到客户端在我们主机上的哪一个位置的话，就需要用到端口号 端口号相当于人的姓名一样。</p><p><img src="https://cdn.jsdelivr.net/gh/xichujn/image/img/image-20210320173102455.png" alt="ipdk"></p><p>应用层-套接字Socket</p><p>应用程序和网络之间的应用程序接口API，是在网络是建立网络应用程序的可编程接口</p><p>应用层-进程</p><p><img src="https://cdn.jsdelivr.net/gh/xichujn/image/img/image-20210320173421707.png" alt="jc"></p><p>进程类似房子 套接字是进程的门 </p><p>进程通过套接字在网络上发送和接收报文</p><p>发送进程；把报文退出门（套接字）</p><p>传送报文；通过下面网络把报文传送到目的进程门口</p><p>接收进程：通过门（套接字）接收报文</p><p><img src="https://cdn.jsdelivr.net/gh/xichujn/image/img/image-20210320173349762.png" alt="image-20210320173349762"></p><p>Socket编程</p><p>服务端</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c#">using System;<br>using System.Net;<br>using System.Net.Sockets;<br>using System.Text;<br>using System.Threading;<br>using System.Threading.Tasks;<br><br>namespace SocketServerTest<br>&#123;<br>    class Program<br>    &#123;<br>        static Socket serverSocket;<br>        static void Main(string[] args)<br>        &#123;<br>            serverSocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);<br><br>            //绑定端口和ip 端口在0-65535之间<br>            serverSocket.Bind(new IPEndPoint(IPAddress.Parse(&quot;127.0.0.1&quot;), 6666));<br>            serverSocket.Listen(10);<br>            Console.WriteLine(&quot;服务器启动成功&quot;);<br>            Thread thread = new Thread(AcceptClient);<br>            //启动<br>            thread.Start();<br><br>            Console.ReadKey();<br>        &#125;<br><br>        private static void AcceptClient()<br>        &#123;<br>            Socket clientSocket = serverSocket.Accept();<br>            byte[] data = Encoding.Default.GetBytes(&quot;服务器告诉你连接成功了&quot;);<br>            clientSocket.Send(data);<br>            //生成方法<br>            Thread thread = new Thread(ReveiveMsg);<br>            thread.Start(clientSocket);<br>        &#125;<br><br>        private static void ReveiveMsg(object clientSocket)<br>        &#123;<br>            byte[] data = new byte[1024];<br>            int length = (clientSocket as Socket).Receive(data);<br>            Console.WriteLine(Encoding.Default.GetString(data, 0, length));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c#">using System;<br>using System.Net;<br>using System.Net.Sockets;<br>using System.Text;<br>using System.Threading;<br><br>namespace SocketClientTest<br>&#123;<br>    class Program<br>    &#123;<br>        private static Socket clientScoket;<br>        static void Main(string[] args)<br>        &#123;<br>            clientScoket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);<br>            clientScoket.Connect(new IPEndPoint(IPAddress.Parse(&quot;127.0.0.1&quot;), 6666));<br>            Console.WriteLine(&quot;与服务器建立了连接&quot;);<br>            clientScoket.Send(Encoding.Default.GetBytes(&quot;客户端发送的一条消息&quot;));<br>            Thread thread = new Thread(Receive);<br>            thread.Start();<br><br>            Console.ReadKey();<br>        &#125;<br><br>        private static void Receive()<br>        &#123;<br>            byte[] data = new byte[1024];<br>            int length = clientScoket.Receive(data);<br>            Console.WriteLine(Encoding.Default.GetString(data, 0, length));<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>花里胡哨</tag>
      
      <tag>计算机网络</tag>
      
      <tag>Socket</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AOI</title>
    <link href="/2021/12/23/AOI/"/>
    <url>/2021/12/23/AOI/</url>
    
    <content type="html"><![CDATA[<h2 id="AOI"><a href="#AOI" class="headerlink" title="AOI"></a>AOI</h2><h4 id="概念-广播的类型"><a href="#概念-广播的类型" class="headerlink" title="概念-广播的类型"></a>概念-广播的类型</h4><p>广播范围</p><ol><li>全服广播 特点：每一个玩家都能接收，频率不会太高，15帧左右</li><li>地图广播 特点：频率越高越好 ，玩家同步，地图同步类型 实时同步给身边的人</li><li>社交关系 特点：频率不会特别高，根据社交定</li><li>交互目标 特点：和别人进行的一对一的，点对点的，PVP的 频率低</li><li>玩家自身 特点：严格不能算广播，客户端与服务器的广播。大部分行为只需要自身知道的</li></ol><h5 id="地图消息同步"><a href="#地图消息同步" class="headerlink" title="地图消息同步"></a>地图消息同步</h5><p><img src="https://cdn.jsdelivr.net/gh/ShyHeart/Photo/photo/image-20211206092201838.png" alt="image-20211206092201838"></p><p>将上面比作一个地图，点比作玩家，每一个点动了，应该把他的行为同步给身边的玩家（100X100 1s同步10次 1s=10000次消息处理 ~3.mb/s=24mb/s ），频率过高，性能越差</p><p>而不是所有玩家范围都需要接受到你的的同步，只针对一个兴趣范围</p><ul><li>建立兴趣范围清单</li><li>只对兴趣兴趣范围内的目标广播</li><li>极大的降低消息处理压力和网络负载</li></ul><h5 id="AOI的设计-设计原则"><a href="#AOI的设计-设计原则" class="headerlink" title="AOI的设计-设计原则"></a>AOI的设计-设计原则</h5><ol><li>分析核心需求：减少压力消耗 降低带宽 提高负载</li><li>明确设计目标 对象 数据 算法</li><li>不为设计而设计 优化思想 忘记技术</li></ol><h5 id="设计目标"><a href="#设计目标" class="headerlink" title="设计目标"></a>设计目标</h5><ol><li>兴趣范围规划方案</li><li>对象与数据结构</li><li>高性能算法</li></ol><h5 id="场景分析与方案设计-一"><a href="#场景分析与方案设计-一" class="headerlink" title="场景分析与方案设计 (一)"></a>场景分析与方案设计 (一)</h5><h6 id="区域划分"><a href="#区域划分" class="headerlink" title="区域划分 "></a>区域划分 <img src="C:\Users\18296\AppData\Roaming\Typora\typora-user-images\image-20211206210040034.png" alt="image-20211206210040034"></h6><h6 id="级别设定"><a href="#级别设定" class="headerlink" title="级别设定"></a>级别设定</h6><p><img src="https://cdn.jsdelivr.net/gh/ShyHeart/Photo/photo/image-20211206210243018.png" alt="image-20211206210243018"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c#">void OnEntityMove(who)&#123;<br>    foreach (var entity in entities)<br>    &#123;<br>        if (who==entity)continue;<br>        bool nowinAOI=who.Distance(entity)&lt;who.AOIRange;<br>        bool alreadyInAOI=who.AOI.contains(entity);<br>        if (alreadyInAOI&amp;&amp;!nowinAOI)<br>        &#123;<br>            who.OnLeaveAOI(entity);<br>            entity.OnLeaveAOI(who);<br>        &#125;  <br>        if (!alreadyInAOI&amp;&amp;nowinAOI)<br>        &#123;<br>            who.onEnterAOI(entity);<br>            entity.onEnterAOI(who);<br>        &#125;<br>     &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>优点</p><ul><li>不需要特殊的数据结构</li><li>易于实现</li></ul><p>缺点</p><ul><li>计算成本较高（1+n）*n/2</li><li>1000人=500500次</li></ul><p>改善方案</p><ul><li>多线程 并行计算，提升计算效率</li><li>延迟计算 减少计算间隔</li><li>分批计算 100/Frame</li></ul><h5 id="场景分析与方案设计-二"><a href="#场景分析与方案设计-二" class="headerlink" title="场景分析与方案设计 (二)"></a>场景分析与方案设计 (二)</h5><p>区域划分</p><p><img src="https://cdn.jsdelivr.net/gh/ShyHeart/Photo/photo/image-20211206212501192.png" alt="image-20211206212501192"></p><p>将区域划分为一个一个格子 如8X8</p><p>代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c#">void OnEntityMove(who)&#123;   <br>int new_x=(int)(who.position.x/size);<br>    int new_y=(int)(who.position.y/size);<br>    if(new_x!=who.grid_X||new_y!=who.grid_y)&#123;<br>        who.LeaveGrid(who.grid_x,who.grid_y);<br>        who.EnterGrid(new_x,new_y);<br>        this.grid_x=new_x;<br>        this.grid_y=new_y;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>优点</p><ul><li>计算速度快</li></ul><p>缺点</p><ul><li>需要额外数据结构存储格子信息</li><li>需要额外的格子管理逻辑</li><li>实现复杂度高</li><li><strong>格子边界问题</strong></li></ul><h6 id="场景分析与方案设计-三"><a href="#场景分析与方案设计-三" class="headerlink" title="场景分析与方案设计 (三)"></a>场景分析与方案设计 (三)</h6><p>基于方案二做优化</p><p><img src="https://cdn.jsdelivr.net/gh/ShyHeart/Photo/photo/image-20211206213228669.png" alt="image-20211206213228669"></p><p>九宫格，一个格子一个格子广播</p><p>进一步的优化思考</p><p>算法优化</p><ul><li>优化数据结构</li><li>降低运算消耗</li></ul><p>ECS架构</p><ul><li>采用面向数据概念优化架构，提升运算性能</li></ul><p>并行运算与GPU加速</p><ul><li>采用并行计算提升性能</li><li>采用GPU加速减少CPU消耗</li></ul><h5 id="优化性价比曲线"><a href="#优化性价比曲线" class="headerlink" title="优化性价比曲线"></a>优化性价比曲线</h5><p><img src="https://cdn.jsdelivr.net/gh/ShyHeart/Photo/photo/image-20211206213733619.png" alt="image-20211206213733619"></p><h6 id="优化方案参考"><a href="#优化方案参考" class="headerlink" title="优化方案参考"></a>优化方案参考</h6><p>背景</p><p>由于正在开发的游戏涉及到10万个移动角色，如果单服10000玩家的话，采用双向循环查找，那就是10亿的量级，太恐怖了，不得不对算法做优化</p><p>场景：1000*1000的地图，10000客户端角色两个角色间的距离是10时，有效</p><p>优化前</p><p>随机生成10000角色的位置信息，然后计算那些角色的信息需要发给范围的客户端。原始：使用最简单的双向循环查找算法，两重for循环，每找到一个时数量+1结果如下，找到40030个有效值，耗时880ms</p><p>优化一</p><p>位置是双向的，也就是A在B的范围内，B在A的范围内，因此只需要循环N<em>（N-1）/2次，优化结果耗时<em>*416ms</em></em></p><p>优化二</p><p>由于大部分的角色位置相距较远，因此对地图进行分区，以100为单位，整个地图被分成100个区域，创建区域数组Player[100][]，然后计算每个客户端的更新范围所在的区域，并将客户端加入到区域中，注意客户端的四个顶点可能在不同的区域上，此时在几个区域就要加入几个区域。最后计算角色所在区域，并和区域内的Player计算距离。此算法得到的结果是<strong>22.5ms</strong></p><p>优化三</p><p>区域大小用2AN来表示，从而在计算角色所在<br>区域时可以用移位来处理，使用64作为区域大<br>小，优化后平均耗时是：<strong>15.5ms</strong></p><p>优化四</p><p>从算法的耗时来看，区域小一些，则区域数量<br>变多，但每个区域内的角色数量就少了，需要<br>计算的量也会变少，使用32作为区域大小后，<br>耗时为：<strong>9.5ms</strong></p><p>优化五</p><p>如果地图变大一些，角色更加稀疏，则计算量<br>会更少，使用10000<em>10000的地图后， 同样64<br>大小的区域，耗时是：<em>*1.8ms</em></em></p><p>其他案例</p><p><a href="http://cppblog.com/jaxe/archive/2011/06/20/148998.html">http://cppblog.com/jaxe/archive/2011/06/20/148998.html</a></p>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
      <tag>花里胡哨</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity-资源优化</title>
    <link href="/2021/12/23/Unity-%E8%B5%84%E6%BA%90%E4%BC%98%E5%8C%96/"/>
    <url>/2021/12/23/Unity-%E8%B5%84%E6%BA%90%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h3 id="资源优化"><a href="#资源优化" class="headerlink" title="资源优化"></a>资源优化</h3><p>目标： 一般从两个方面 性能 品质</p><p>内存占用 大小/容量 运行效率（帧率高不高）</p><p>先考虑资源</p><p>基础资源类型</p><p>模型 动作 纹理 声音 字体</p><p>综合资源类型</p><p>场景（地形 光源）UI（图集）粒子系统</p><p><strong>游戏资源的制作规范</strong></p><p>模型：三角形数量 UV LOD</p><p>动作：时长 帧率</p><p>贴图：尺寸 格式</p><p><img src="https://cdn.jsdelivr.net/gh/ShyHeart/Photo/photo/image-20211209094742121.png" alt="image-20211209094742121"></p><p><strong>模型导入优化</strong></p><p>模型压缩 网格优化 可读写 Lightmap UV</p><p>动作导入 动画压缩 Rig-优化游戏对象</p><p>纹理格式 POT 纹理大小 压缩选项</p><p><strong>场景优化</strong></p><p>资源的组织 引用及依赖 资源复用</p><p><strong>优化流程自动化</strong></p><p>Unity MeshCompression 网格优化</p><p><img src="https://cdn.jsdelivr.net/gh/ShyHeart/Photo/photo/image-20211209100212083.png" alt="image-20211209100212083"></p><p><img src="https://cdn.jsdelivr.net/gh/ShyHeart/Photo/photo/image-20211209100358273.png" alt="image-20211209100358273"></p><p>模型的Optimize GameObject开启后 ，模型的子节点将压缩成一个节点</p><p>资源后处理 代码</p><p>Unity AssetPostProcessor</p><p><a href="https://docs.unity3d.com/2019.2/Documentation/ScriptReference/AssetPostprocessor.OnPreprocessTexture.html">https://docs.unity3d.com/2019.2/Documentation/ScriptReference/AssetPostprocessor.OnPreprocessTexture.html</a></p>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
      <tag>花里胡哨</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity性能优化</title>
    <link href="/2021/12/23/Unity-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <url>/2021/12/23/Unity-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><h4 id="性能优化-CPU"><a href="#性能优化-CPU" class="headerlink" title="性能优化-CPU"></a>性能优化-CPU</h4><p><strong>干扰 内部与外部</strong></p><p>内部：Profiler，Vertical Sync（垂直同步），Log output 凹操作性能耗费很高</p><p>外部：CPU 内存 IO</p><p><strong>工具</strong></p><p><strong>Unity Profiler</strong></p><p><img src="https://cdn.jsdelivr.net/gh/ShyHeart/Photo/photo/image-20211213161040737.png" alt="image20211213161040737"></p><p><strong>Custom Profiler</strong>（自定义的Profiler）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c#">private void Update()<br>&#123;<br>    CustomProfrile();<br>&#125;<br><br>void CustomProfrile()<br>&#123;<br>    UnityEngine.Profiling.Profiler.BeginSample(&quot;CustomProfrile&quot;);<br>    for (int i = 0; i &lt; 100; i++)<br>    &#123;<br>        CustomFunction();<br>    &#125;<br>    UnityEngine.Profiling.Profiler.EndSample();<br>&#125;<br><br>private void CustomFunction()<br>&#123;<br>    UnityEngine.Profiling.Profiler.BeginSample(&quot;CustomFunction&quot;);<br>    for (int i = 0; i &lt; 100; i++)<br>    &#123;<br>        CustomCale();<br>    &#125;<br>    UnityEngine.Profiling.Profiler.EndSample();<br>&#125;<br><br>private void CustomCale()<br>&#123;<br>    UnityEngine.Profiling.Profiler.BeginSample(&quot;CustomCale&quot;);<br>    float t = 100, f = 0f;<br>    for (int i = 0; i &lt; 100; i++)<br>    &#123;<br>        f += Mathf.Pow(Mathf.Sin(i), t);<br>    &#125;<br>    UnityEngine.Profiling.Profiler.EndSample();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Timer&amp;Log</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c#">public class ProTimer :IDisposable<br>&#123;<br>    private string name;<br>   private int times;<br>   private Stopwatch watch;<br><br>    public ProTimer(string name):this(name,0)&#123;<br><br>    &#125;<br>    public ProTimer(string name,int times)<br>    &#123;<br>        this.name=name;<br>        this.times=times;<br>        if(this.times&lt;=0)<br>            this.times=1;<br>        watch=Stopwatch.StartNew();<br>    &#125;<br><br>    public void Dispose()&#123;<br>        watch.Stop();<br>        float ms=watch.ElapsedMinlliseconds;<br>        if(times&gt;1)&#123;<br>            Debug.Debug.Log(string.Format(&quot;ProTimer : [&#123;0&#125;] finished: [&#123;1:0.00&#125;ms] total, [&#123;2:0.000000&#125;ms] per peroid for [&#123;3&#125;] times&quot;<br>            ,name ,ms,ms/timer,times));<br>        &#125;<br>        else<br>            Debug.Debug.Log(string.Format(&quot;ProTimer : [&#123;0&#125;] finished: [&#123;1:0.00&#125;ms] total&quot;,name,ms ));<br><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="CPU优化要点"><a href="#CPU优化要点" class="headerlink" title="CPU优化要点"></a>CPU优化要点</h5><p>CPU优化要点：Unity脚本最佳做法 数据结构优化 算法优化</p><p><strong>Unity脚本最佳做法</strong></p><ul><li>Component的缓冲与获取</li><li><strong>移除空声明</strong></li><li>避免Find和SendMessage(大概比直接函数调用慢2000倍)</li><li>禁止未使用的游戏脚本与对象 （生存周期 可见性 距离）</li><li>对象池</li></ul><p>Component获取的三种方式</p><ul><li>(CompTest)Component(“Testcomponent”)</li><li>GetComponent<CompTest>();</li><li>(CompTest)GetComponent(typeof(CompTest))</li></ul><p>性能消耗</p><p><img src="https://cdn.jsdelivr.net/gh/ShyHeart/Photo/photo/image-20211213202822084.png" alt="image20211213202822084"></p><p>避免Find和SendMessage-替代方案</p><ul><li>直接引用游戏对象</li><li>静态类</li><li>单例组件</li><li>自定义消息系统</li></ul><p>性能分析注意事项</p><ul><li>分析第一，优化第二</li><li>分析要透彻，避免一知半解盲目优化</li><li>避免为性能分析增加过多临时代码</li><li>增加的日志在头花完成及时移除</li><li>尽量通过DeBug发现问题</li></ul><h4 id="性能优化-GPU"><a href="#性能优化-GPU" class="headerlink" title="性能优化-GPU"></a>性能优化-GPU</h4><p><strong>原理</strong></p><p><img src="https://cdn.jsdelivr.net/gh/ShyHeart/Photo/photo/image-20211213204405189.png" alt="image20211213204405189"></p><h6 id="工具"><a href="#工具" class="headerlink" title="工具"></a><strong>工具</strong></h6><p>Unity Profiler Frame Debug GPU Profiler</p><h6 id="GPU优化要点"><a href="#GPU优化要点" class="headerlink" title="GPU优化要点"></a><strong>GPU优化要点</strong></h6><ul><li>Drawcall</li><li>Batching</li><li>图集</li><li>移动设备优化</li></ul><p>渲染对象关系</p><p><img src="https://cdn.jsdelivr.net/gh/ShyHeart/Photo/photo/image-20211213205858211.png" alt="image20211213205858211"></p><p>Dynamic Batching</p><ul><li>所有Mesh实例具有相同的材质引用</li><li>只有Partucle System和MeshRenderer可以动态批*（随Unity版本不同）</li><li>Vertex Attribute总数必须小于900</li><li>所有实例必须采用Uniform Scale或所有Mesh都采用Nonuniform Scale，不能混合使用。</li><li>必须引用相同的LightMap</li><li>材质Shader不用使用Multiple Passes</li><li>Mesh实例不能接受实时阴影</li><li>每个Batch最大300Mesh</li><li>最多32000Mesh可以Batch</li></ul><p>Static Batching</p><ul><li>所有Mesh实例具有相同的材质引用</li><li>所有Mesh必须标记为Static</li><li>额外的内存占用</li><li>静态对象无法通过原始的Transform移动</li><li>任何一点可见，全部渲染</li></ul><p>移动设备优化要点</p><ul><li>最小的Drawcall</li><li>最小的材质数量</li><li>最小的纹理尺寸</li><li>方形&amp;POT纹理</li><li>Shader中使用尽可能低的数据类型</li><li>避免Alpha测试</li></ul><h4 id="性能优化-内存"><a href="#性能优化-内存" class="headerlink" title="性能优化-内存"></a>性能优化-内存</h4><h6 id="内存占用优化"><a href="#内存占用优化" class="headerlink" title="内存占用优化"></a>内存占用优化</h6><p>分析工具 <strong>Unity Profiler</strong></p><p><img src="https://cdn.jsdelivr.net/gh/ShyHeart/Photo/photo/image-20211216194107133.png" alt="image20211216194107133"></p><p>除此之外，unity还有另外一个更加直观的工具</p><p><strong>Memory Profiler</strong> (开源库之中)</p><p><img src="https://cdn.jsdelivr.net/gh/ShyHeart/Photo/photo/image-20211216194721571.png" alt="image20211216194721571"></p><h6 id="Unity占用组成"><a href="#Unity占用组成" class="headerlink" title="Unity占用组成"></a><strong>Unity占用组成</strong></h6><ul><li><p>Unity</p></li><li><p>Mono</p></li><li><p>GfxDriver(显卡驱动消耗的内存)</p></li><li><p>FMOD（音频引擎）</p></li><li><p>细分(Texture Mesh Animation Shader Font)</p><p><img src="https://cdn.jsdelivr.net/gh/ShyHeart/Photo/photo/image-20211216211225511.png" alt="image20211216211225511"></p><p><img src="https://cdn.jsdelivr.net/gh/ShyHeart/Photo/photo/image-20211216212601027.png" alt="image20211216212601027"></p><p><img src="https://cdn.jsdelivr.net/gh/ShyHeart/Photo/photo/image-20211216212655362.png" alt="image20211216212655362"></p></li></ul><h6 id="GC优化"><a href="#GC优化" class="headerlink" title="GC优化"></a>GC优化</h6><p>GC 内存堆栈 垃圾回收</p><p><a href="https://zhuanlan.zhihu.com/p/265217138">https://zhuanlan.zhihu.com/p/265217138</a></p><p><img src="https://cdn.jsdelivr.net/gh/ShyHeart/Photo/photo/image-20211216213311223.png" alt="image20211216213311223"></p><p>优化要点</p><ul><li>减少频繁的对象创建</li><li>避免装箱</li><li>善用缓存<br><img src="https://cdn.jsdelivr.net/gh/ShyHeart/Photo/photo/image-20211216213529292.png" alt="image-20211216213529292"></li></ul>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
      <tag>花里胡哨</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
