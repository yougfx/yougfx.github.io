<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>粘包和拆包</title>
    <link href="/2021/12/23/%E7%B2%98%E5%8C%85%E5%92%8C%E6%8B%86%E5%8C%85/"/>
    <url>/2021/12/23/%E7%B2%98%E5%8C%85%E5%92%8C%E6%8B%86%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h1 id="粘包和拆包-解决方法"><a href="#粘包和拆包-解决方法" class="headerlink" title="粘包和拆包 解决方法"></a>粘包和拆包 解决方法</h1><h2 id="拆包-粘包"><a href="#拆包-粘包" class="headerlink" title="拆包 粘包"></a>拆包 粘包</h2><p>当客户端向服务器连续发送两个数据包后，服务端接收数据可以分成三种情况</p><p>一、服务端正常的收到这两个数据包 没有发生粘包和拆包的情况</p><p>二、服务端只接收到一个数据包 ，而TCP是不会发生丢包的情况的，所以这一个数据包就包含了客户端发送的两个数据包 这就被称为粘包。</p><p>发送的时候，数据是有一个数据缓冲区的，比如数据缓冲区是200，我们一个包是100 就会把缓冲区填满，填满之后呢 我们数据缓冲区就会把这个包发送出去，这两个包呢就会被粘在一起，合并成了一个发送。相当于我们人发快递，发送两根笔，一根笔是一份快递钱，那么我们就会把两根笔合成一份快递发送。而缓冲区呢，当第一次没有填满，那么它就会等到填满了，一块往服务端发送，这样就出现粘包的问题。</p><p>三、服务端接收到了两个数据包，但是这两个数据包，会出现要么不完整，或者多出来一部分的情况，这种情况呢就是发生了拆包和粘包。</p><p>就相当于在数据缓冲区中，我们数据缓冲区是200，而我们一个包的长度呢是150 这时候进入缓冲区，而缓冲区没有被填满，就会等待填满，而缓冲区填满后就出现了另外一个数据包不全的情况 一个数据包多出了一部分 这就是发生了拆包和粘包</p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>粘包、拆包发生原因 （常见几种）</p><ol><li><p>要发送的数据大于TCP发送缓冲区剩余空间大小，将会发生拆包。</p></li><li><p>待发送数据大于最大报文长度，TCP在传输前将进行拆包。</p></li><li><p>要发送的数据小于TCP发送缓冲区的大小，TCP将多次写入缓冲区的数据一次发送出去，将会发生粘包。</p></li><li><p>接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包。</p></li></ol><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>发送端给每一个数据包构造一个包头与包尾，包头内包含了数据包的长度，包尾才是真正的数据包 当接收端接收到数据包后，首先先读取数据包的前四个字节（int值只占四个字节）拿到数据包的长度后，再往后依次读取我们的数据包。</p><h2 id="构造包和解析包"><a href="#构造包和解析包" class="headerlink" title="构造包和解析包"></a>构造包和解析包</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs c#">using System;<br>using System.Collections.Generic;<br>using System.IO;<br>using System.Linq;<br>using System.Text;<br>using System.Threading.Tasks;<br><br>namespace MyServer<br>&#123;<br>    /// &lt;summary&gt;<br>    /// /构造包 包头+包尾<br>    /// &lt;/summary&gt;<br>   public class EncodeTool<br>    &#123;<br>        public static byte[] EncodePacket(byte[] data)<br>        &#123;<br>            using (MemoryStream ms = new MemoryStream())<br>            &#123;<br>                using (BinaryWriter bw=new BinaryWriter(ms))<br>                &#123;<br>                    //写入包头（数据的长度）<br>                    bw.Write(data.Length);<br>                    //写入包尾（数据）<br>                    bw.Write(data);<br>                    byte[] packet = new byte[ms.Length];<br>                    Buffer.BlockCopy(ms.GetBuffer(), 0, packet, 0, (int)ms.Length);<br>                    return packet;<br>                &#125;<br>            &#125;<br>        &#125;<br>        /// &lt;summary&gt;<br>        /// /解析包，从缓冲区里取出一个完整的包<br>        /// &lt;/summary&gt;<br>        /// &lt;param name=&quot;cache&quot;&gt;&lt;/param&gt;<br>        /// &lt;returns&gt;&lt;/returns&gt;<br><br>        public static byte[] DecodePacket(ref List&lt;byte&gt; cache)<br>        &#123;<br>            //如果数据长度小于四个字节，说明没有包<br>            if (cache.Count &lt; 4)<br>            &#123;<br>                return null;<br>            &#125;<br>            using (MemoryStream ms=new MemoryStream(cache.ToArray()))<br>            &#123;<br>                using(BinaryReader br=new BinaryReader(ms))<br>                &#123;<br>                    //读取包的长度<br>                    int length = br.ReadInt32();<br>                    //当前的长度减去，读取字节后游标的长度，就是包的数据 <br>                    int remainLength = (int)(ms.Length - ms.Position);<br>                    if (length &gt; remainLength)<br>                    &#123;<br>                        //如果大于减去后的长度麻将构不能一个包<br>                        return null;<br>                    &#125;<br>                    byte[] data = br.ReadBytes(length);<br>                    //更新缓冲数据<br>                    cache.Clear();<br>                    cache.AddRange(br.ReadBytes(remainLength));<br>                    return data;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CSharp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>花里胡哨</tag>
      
      <tag>计算机网络</tag>
      
      <tag>Socket</tag>
      
      <tag>CSharp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C#Socket连接</title>
    <link href="/2021/12/23/C-Socket%E8%BF%9E%E6%8E%A5/"/>
    <url>/2021/12/23/C-Socket%E8%BF%9E%E6%8E%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="C-实现Socket连接"><a href="#C-实现Socket连接" class="headerlink" title="C#实现Socket连接"></a>C#实现Socket连接</h1><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><ol><li><p>建立Socket</p><p>AddressFamily.InterNetwork内网，SocketType.Stream以流来通信，Tcp为协议</p></li><li><p>电脑主机和端口和ip地址进行绑定</p></li><li><p>监听客户端连接</p></li><li><p>阻塞方法  生成Socket 接受客户端连接</p></li><li><p>声明数组，存放聊天的缓冲区。</p></li><li><p>使用while方法 , 接收数据并存放在数组中 实现多次接消息</p></li><li><p>还原接收信息为明文</p></li><li><p>实现客服给客户发消息</p></li></ol><h3 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c#">using System;<br>using System.Net;<br>using System.Net.Sockets;<br>using System.Text;<br><br>namespace SocketDemo<br>&#123;<br>    class Program<br>    &#123;<br>        static void Main(string[] args)<br>        &#123;<br>            //创建Socket 相当于是通信的主机<br>            //监听打进来的电话，并转接给客服<br>            Socket serverSocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);<br><br>            //绑定ip和端口<br>            EndPoint iped = IPEndPoint.Parse(&quot;192.168.43.227:1234&quot;);<br>            serverSocket.Bind(iped);<br><br>            //监听有没有电话连接，顺便规划客服人数,如果是0就是无限个客服<br>            serverSocket.Listen(100);<br><br>            //接电话<br>            //分配客服和客户进行一对一通信<br>            //阻塞方法 没有电话打进来，那么代码就执行到这里 Accept<br>            Socket kefuScoket = serverSocket.Accept();<br>            System.Console.WriteLine(&quot;客户的本地端口是：&quot; + kefuScoket.LocalEndPoint.ToString());<br>            System.Console.WriteLine(&quot;打电话进来的客户端是：&quot; + kefuScoket.RemoteEndPoint.ToString());<br><br>            //接消息，需要一个消息的缓冲区<br>            byte[] readBuff = new byte[1024];<br><br>            while (true)<br>            &#123;<br>                //消息拿到，并存放在缓冲区，并记住消息的长度<br>                int receiveCount = kefuScoket.Receive(readBuff);<br>                string receiveMessage = Encoding.UTF8.GetString(readBuff, 0, receiveCount);<br>                System.Console.WriteLine(&quot;客户端发过来的消息：&quot; + receiveMessage);<br><br>                //string backMessage = &quot;我是你的专属客服，有什么可以帮助你的&quot;;<br>                kefuScoket.Send(Encoding.UTF8.GetBytes(&quot;服务器已经接到你发来的消息：&quot; + receiveMessage));<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><ol><li>建立Socket</li><li>Connect连接服务端</li><li>try catch语句 捕捉异常</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c#">using System;<br>using System.Net;<br>using System.Net.Sockets;<br>using System.Text;<br><br>namespace clientSocket<br>&#123;<br>    class Program<br>    &#123;<br>        static void Main(string[] args)<br>        &#123;<br>            Console.WriteLine(&quot;Hello World!&quot;);<br><br>            Socket clientSocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);<br>            //接收服务器的回馈<br>            byte[] readBuff = new byte[1024];<br><br>            //连接服务器<br>            clientSocket.Connect(&quot;192.168.43.227&quot;, 1234);<br><br>            //连接上服务器，就能发消息<br>            string sendMessage;<br><br>            //计数器<br>            int num = 0;<br><br>            while (true)<br>            &#123;<br>                if (num == 0)<br>                &#123;<br>                    sendMessage = &quot;你好，我是192用户&quot;;<br>                    num++;<br>                &#125;<br>                else<br>                &#123;<br>                    sendMessage = Console.ReadLine();<br>                &#125;<br><br>                //转码，转成0101010的格式<br>                byte[] sendBytes = Encoding.UTF8.GetBytes(sendMessage);<br><br>                //把二进制的消息发出去<br>                clientSocket.Send(sendBytes);<br>                int count = clientSocket.Receive(readBuff);<br>                System.Console.WriteLine(&quot;服务器发送的消息是：&quot; + Encoding.UTF8.GetString(readBuff, 0, count));<br><br>            &#125;<br><br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="C-Socket各种类"><a href="#C-Socket各种类" class="headerlink" title="C#Socket各种类"></a>C#Socket各种类</h4><p>一、IP地址操作类</p><p>1、IPAddress类</p><p>在该类中有一个Parse()方法，可以把点分的十进制转换成IPAddress类，方法1如下：IPAddress address=IPAddress.Parse(“192.168.0.1”);</p><p>IPAddress 提供4个只读字段</p><ol><li>Any 用于代表本地系统可用的任何IP地址 常用来表示本机所有的IP地址 方便于对Socket服务进行监听，</li><li>Broadcase用于代表本地网络的IP广播地址 UDP的IP广播</li><li>Loopback用于代表系统的回送地址</li><li>None用于代表系统是没有网络接口</li></ol><p>2、IPEndPoint类</p><p>我们可以通过二种构造方法创建IPEndPoint类   就是一个IP地址端口的绑定 可以代表一个服务，用来Socket通讯</p><p>a、IPEndPoint(long address,int port)</p><p>b、IPEndPoint(IPAddress address,int port)</p><p>四种属性：Address  AddressFamily Port MaxPort  MinPort</p><p>二、DNS相关类</p><p>DNS类有四个静态方法，来获取主机DNS相关信息</p><ol><li>GetHostName（） 通过DNS.GetHostName()可以获得本地计算机的主机名</li><li>GetHostByName() 根据主机名称，返回一个IPHostEntry对象：IPHostEntry GetHostByName(string hostName) 其中IPHostEntry 把一个DNS主机名与一个别名和IP地址的数组相关联，包括三个属性：AddressList：一个IPAddress对象的数组   Aliases：一个字符串对象数组 HostName一个用于主机名的字符串对象</li><li>GetHostByAddress() 类似于GetHostByName(),只不过这里的参数是IP地址，而不是主机名，返回一个IPHostEntry对象。  IPHostEntry GetHostByAddress(IPAddress address)   IPHostEntry GetHostByAddress(string address)</li><li>Resolve()   当我们不知道输入的主机的地址是哪种格式时，用以上两种方法来实现，我们可能还要通过判断客户输入的格式，才能正确使用，但DNS类提供更简单的方法Resolve（），该方法可以接收或者是主机名格式或者是IP地址格式的任何一种地址，并返回IPHostEntry对象</li></ol>]]></content>
    
    
    <categories>
      
      <category>CSharp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>花里胡哨</tag>
      
      <tag>计算机网络</tag>
      
      <tag>Socket</tag>
      
      <tag>CSharp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络知识点</title>
    <link href="/2021/12/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <url>/2021/12/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h2 id="计算机网络知识点（一）"><a href="#计算机网络知识点（一）" class="headerlink" title="计算机网络知识点（一）"></a>计算机网络知识点（一）</h2><h4 id="三种常见的计算机体系结构"><a href="#三种常见的计算机体系结构" class="headerlink" title="三种常见的计算机体系结构"></a>三种常见的计算机体系结构</h4><ul><li>OSI分层（7层）：物理层 数据链路层 网络层 传输层 会话层 表示层 应用层</li><li>TCP/IP分层（4层）：网络接口层 网际层  运输层 应用层</li><li>五层协议（5层）：物理层 数据链路层 网络层 运输层 ‘应用层</li></ul><h4 id="每一层的协议如下"><a href="#每一层的协议如下" class="headerlink" title="每一层的协议如下"></a>每一层的协议如下</h4><ul><li>物理层：RJ45、CLOCK、IEEE802.3 （中继器，集线器，网关）</li><li>数据链路：PPP、FR、HDLC、VLAN、MAC （网桥，交换机）</li><li>网络层：IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP、 （路由器） </li><li>传输层：==TCP、UDP==、SPX</li><li>会话层：NFS、SQL、NETBIOS、RPC </li><li>表示层：JPEG、MPEG、ASII </li><li>应用层：FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS</li></ul><h4 id="每一层的作用如下"><a href="#每一层的作用如下" class="headerlink" title="每一层的作用如下"></a>每一层的作用如下</h4><ul><li><p>物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）</p></li><li><p>数据链路层：将比特组装成帧和点到点的传递（帧Frame） </p></li><li><p>网络层：负责数据包从源到宿的传递和网际互连（包PackeT）</p></li><li><p>传输层：提供端到端的可靠报文传递和错误恢复（段Segment） </p></li><li><p>会话层：建立、管理和终止会话（会话协议数据单元SPDU） </p></li><li><p>表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）</p></li><li><p>应用层：允许访问OSI环境的手段（应用协议数据单元APDU）</p></li></ul><h4 id="IP地址的分类"><a href="#IP地址的分类" class="headerlink" title="IP地址的分类"></a>IP地址的分类</h4><p> IP地址由32位组成，前面16位为网络号，后面16位为主机号</p><ul><li>A类地址：以0开头， 第一个字节范围：0~127（1.0.0.0 - 126.255.255.255）；</li><li>B类地址：以10开头， 第一个字节范围：128~191（128.0.0.0 - 191.255.255.255）； </li><li>C类地址：以110开头， 第一个字节范围：192~223（192.0.0.0 - 223.255.255.255）； </li><li>==IP地址与子网掩码相与得到主机号==</li></ul><h4 id="ARP-amp-RAPR-ARP是地址解析协议，-工作原理"><a href="#ARP-amp-RAPR-ARP是地址解析协议，-工作原理" class="headerlink" title="ARP &amp; RAPR ARP是地址解析协议，(工作原理)"></a>ARP &amp; RAPR ARP是地址解析协议，(工作原理)</h4><p>每一个主机中都会在ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址之间的对应关系。 2. 源地址发送数据时，首先查表，有则发包，无则广播，向本网段的所有主机发送ARP数据包。 3. 本网段其他主机收到时，检查包内IP地址是否为自己的IP地址，如果是，写入或者覆盖ARP列表， 然后将自己的MAC地址写入ARP响应包，告诉源地址 4. 源主机找到ARP响应包。根据ARP地址解析协议工作</p><h4 id="针对不同包的解决方式"><a href="#针对不同包的解决方式" class="headerlink" title="针对不同包的解决方式"></a>针对不同包的解决方式</h4><ol><li>已知包，直接发</li><li>广播包 广播发 ，每一个主机都响应（255.255.255.255）</li><li>未知包 广播查找 查找到后 目标地址响应</li></ol><h4 id="描述RARP"><a href="#描述RARP" class="headerlink" title="描述RARP"></a>描述RARP</h4><p>RARP是逆地址解析协议，作用是完成硬件地址到IP地址的映射，主要用于无盘工作站，因为给无盘工作 站配置的IP地址不能保存。工作流程：在网络中配置一台RARP服务器，里面保存着IP地址和MAC地址的 映射关系，当无盘工作站启动后，就封装一个RARP数据包，里面有其MAC地址，然后广播到网络上 去，当服务器收到请求包后，就查找对应的MAC地址的IP地址装入响应报文中发回给请求者。因为需要 广播请求报文，因此RARP只能用于具有广播能力的网络</p><h4 id="各种协议"><a href="#各种协议" class="headerlink" title="各种协议"></a>各种协议</h4><ul><li>ICMP协议：因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间 传递控制消息 </li><li>TFTP协议：是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不 复杂、开销不大的文件传输服务</li><li>HTTP协议：超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的方式， 适用于分布式超媒体信息系统 </li><li>DHCP协议：动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置参数手段 NAT协议：网络地址转换属接入广域网(WAN)技术，是一种将私有（保留）地址转化为合法IP地址 的转换技术 </li><li>DHCP协议：一个局域网的网络协议，使用UDP协议工作，用途：给内部网络或网络服务供应商自 动分配IP地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>花里胡哨</tag>
      
      <tag>计算机网络</tag>
      
      <tag>Socket</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络基础</title>
    <link href="/2021/12/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
    <url>/2021/12/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机网络基础"><a href="#计算机网络基础" class="headerlink" title="计算机网络基础"></a>计算机网络基础</h1><h2 id="OSI-TCP-UDP"><a href="#OSI-TCP-UDP" class="headerlink" title="OSI TCP UDP"></a>OSI TCP UDP</h2><p><img src="https://cdn.jsdelivr.net/gh/xichujn/image/img/image-20210320171236732.png" alt="osi"></p><p>OSI七层协议除了最高层，下面每一层都给上面一层提供服务。</p><p>TCP面向连接（如打电话要先拨号建立连接）；UDP是无连接的既发送数据之前不需要建立连接</p><p>TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达；UDP尽最大努力交付，既不保证可靠交付。（QQ和微信通话就是UDP，因为不需要保证可靠的交付，服务器是TCP，因为要保证客户数据无差错的 不丢失的）</p><p>TCP面向 字节流，实际上是TCP把数据看成一连串无结构的字节流；UDP是面向报文</p><p>每一条TCP连接只能是点到点的；UDP支持一对一，一对多，多对一和多对多的交互通信</p><h2 id="IP-端口号"><a href="#IP-端口号" class="headerlink" title="IP 端口号"></a>IP 端口号</h2><p>主机是有一个IP地址的，主机与主机之间想要互相通信，联系的话，就需要通过IP地址，服务器要给客户端发送一个消息的话，服务器如果想要识别到客户端在我们主机上的哪一个位置的话，就需要用到端口号 端口号相当于人的姓名一样。</p><p><img src="https://cdn.jsdelivr.net/gh/xichujn/image/img/image-20210320173102455.png" alt="ipdk"></p><p>应用层-套接字Socket</p><p>应用程序和网络之间的应用程序接口API，是在网络是建立网络应用程序的可编程接口</p><p>应用层-进程</p><p><img src="https://cdn.jsdelivr.net/gh/xichujn/image/img/image-20210320173421707.png" alt="jc"></p><p>进程类似房子 套接字是进程的门 </p><p>进程通过套接字在网络上发送和接收报文</p><p>发送进程；把报文退出门（套接字）</p><p>传送报文；通过下面网络把报文传送到目的进程门口</p><p>接收进程：通过门（套接字）接收报文</p><p><img src="https://cdn.jsdelivr.net/gh/xichujn/image/img/image-20210320173349762.png" alt="image-20210320173349762"></p><p>Socket编程</p><p>服务端</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c#">using System;<br>using System.Net;<br>using System.Net.Sockets;<br>using System.Text;<br>using System.Threading;<br>using System.Threading.Tasks;<br><br>namespace SocketServerTest<br>&#123;<br>    class Program<br>    &#123;<br>        static Socket serverSocket;<br>        static void Main(string[] args)<br>        &#123;<br>            serverSocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);<br><br>            //绑定端口和ip 端口在0-65535之间<br>            serverSocket.Bind(new IPEndPoint(IPAddress.Parse(&quot;127.0.0.1&quot;), 6666));<br>            serverSocket.Listen(10);<br>            Console.WriteLine(&quot;服务器启动成功&quot;);<br>            Thread thread = new Thread(AcceptClient);<br>            //启动<br>            thread.Start();<br><br>            Console.ReadKey();<br>        &#125;<br><br>        private static void AcceptClient()<br>        &#123;<br>            Socket clientSocket = serverSocket.Accept();<br>            byte[] data = Encoding.Default.GetBytes(&quot;服务器告诉你连接成功了&quot;);<br>            clientSocket.Send(data);<br>            //生成方法<br>            Thread thread = new Thread(ReveiveMsg);<br>            thread.Start(clientSocket);<br>        &#125;<br><br>        private static void ReveiveMsg(object clientSocket)<br>        &#123;<br>            byte[] data = new byte[1024];<br>            int length = (clientSocket as Socket).Receive(data);<br>            Console.WriteLine(Encoding.Default.GetString(data, 0, length));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c#">using System;<br>using System.Net;<br>using System.Net.Sockets;<br>using System.Text;<br>using System.Threading;<br><br>namespace SocketClientTest<br>&#123;<br>    class Program<br>    &#123;<br>        private static Socket clientScoket;<br>        static void Main(string[] args)<br>        &#123;<br>            clientScoket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);<br>            clientScoket.Connect(new IPEndPoint(IPAddress.Parse(&quot;127.0.0.1&quot;), 6666));<br>            Console.WriteLine(&quot;与服务器建立了连接&quot;);<br>            clientScoket.Send(Encoding.Default.GetBytes(&quot;客户端发送的一条消息&quot;));<br>            Thread thread = new Thread(Receive);<br>            thread.Start();<br><br>            Console.ReadKey();<br>        &#125;<br><br>        private static void Receive()<br>        &#123;<br>            byte[] data = new byte[1024];<br>            int length = clientScoket.Receive(data);<br>            Console.WriteLine(Encoding.Default.GetString(data, 0, length));<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>花里胡哨</tag>
      
      <tag>计算机网络</tag>
      
      <tag>Socket</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AOI</title>
    <link href="/2021/12/23/AOI/"/>
    <url>/2021/12/23/AOI/</url>
    
    <content type="html"><![CDATA[<h2 id="AOI"><a href="#AOI" class="headerlink" title="AOI"></a>AOI</h2><h4 id="概念-广播的类型"><a href="#概念-广播的类型" class="headerlink" title="概念-广播的类型"></a>概念-广播的类型</h4><p>广播范围</p><ol><li>全服广播 特点：每一个玩家都能接收，频率不会太高，15帧左右</li><li>地图广播 特点：频率越高越好 ，玩家同步，地图同步类型 实时同步给身边的人</li><li>社交关系 特点：频率不会特别高，根据社交定</li><li>交互目标 特点：和别人进行的一对一的，点对点的，PVP的 频率低</li><li>玩家自身 特点：严格不能算广播，客户端与服务器的广播。大部分行为只需要自身知道的</li></ol><h5 id="地图消息同步"><a href="#地图消息同步" class="headerlink" title="地图消息同步"></a>地图消息同步</h5><p><img src="https://cdn.jsdelivr.net/gh/ShyHeart/Photo/photo/image-20211206092201838.png" alt="image-20211206092201838"></p><p>将上面比作一个地图，点比作玩家，每一个点动了，应该把他的行为同步给身边的玩家（100X100 1s同步10次 1s=10000次消息处理 ~3.mb/s=24mb/s ），频率过高，性能越差</p><p>而不是所有玩家范围都需要接受到你的的同步，只针对一个兴趣范围</p><ul><li>建立兴趣范围清单</li><li>只对兴趣兴趣范围内的目标广播</li><li>极大的降低消息处理压力和网络负载</li></ul><h5 id="AOI的设计-设计原则"><a href="#AOI的设计-设计原则" class="headerlink" title="AOI的设计-设计原则"></a>AOI的设计-设计原则</h5><ol><li>分析核心需求：减少压力消耗 降低带宽 提高负载</li><li>明确设计目标 对象 数据 算法</li><li>不为设计而设计 优化思想 忘记技术</li></ol><h5 id="设计目标"><a href="#设计目标" class="headerlink" title="设计目标"></a>设计目标</h5><ol><li>兴趣范围规划方案</li><li>对象与数据结构</li><li>高性能算法</li></ol><h5 id="场景分析与方案设计-一"><a href="#场景分析与方案设计-一" class="headerlink" title="场景分析与方案设计 (一)"></a>场景分析与方案设计 (一)</h5><h6 id="区域划分"><a href="#区域划分" class="headerlink" title="区域划分 "></a>区域划分 <img src="C:\Users\18296\AppData\Roaming\Typora\typora-user-images\image-20211206210040034.png" alt="image-20211206210040034"></h6><h6 id="级别设定"><a href="#级别设定" class="headerlink" title="级别设定"></a>级别设定</h6><p><img src="https://cdn.jsdelivr.net/gh/ShyHeart/Photo/photo/image-20211206210243018.png" alt="image-20211206210243018"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c#">void OnEntityMove(who)&#123;<br>    foreach (var entity in entities)<br>    &#123;<br>        if (who==entity)continue;<br>        bool nowinAOI=who.Distance(entity)&lt;who.AOIRange;<br>        bool alreadyInAOI=who.AOI.contains(entity);<br>        if (alreadyInAOI&amp;&amp;!nowinAOI)<br>        &#123;<br>            who.OnLeaveAOI(entity);<br>            entity.OnLeaveAOI(who);<br>        &#125;  <br>        if (!alreadyInAOI&amp;&amp;nowinAOI)<br>        &#123;<br>            who.onEnterAOI(entity);<br>            entity.onEnterAOI(who);<br>        &#125;<br>     &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>优点</p><ul><li>不需要特殊的数据结构</li><li>易于实现</li></ul><p>缺点</p><ul><li>计算成本较高（1+n）*n/2</li><li>1000人=500500次</li></ul><p>改善方案</p><ul><li>多线程 并行计算，提升计算效率</li><li>延迟计算 减少计算间隔</li><li>分批计算 100/Frame</li></ul><h5 id="场景分析与方案设计-二"><a href="#场景分析与方案设计-二" class="headerlink" title="场景分析与方案设计 (二)"></a>场景分析与方案设计 (二)</h5><p>区域划分</p><p><img src="https://cdn.jsdelivr.net/gh/ShyHeart/Photo/photo/image-20211206212501192.png" alt="image-20211206212501192"></p><p>将区域划分为一个一个格子 如8X8</p><p>代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c#">void OnEntityMove(who)&#123;   <br>int new_x=(int)(who.position.x/size);<br>    int new_y=(int)(who.position.y/size);<br>    if(new_x!=who.grid_X||new_y!=who.grid_y)&#123;<br>        who.LeaveGrid(who.grid_x,who.grid_y);<br>        who.EnterGrid(new_x,new_y);<br>        this.grid_x=new_x;<br>        this.grid_y=new_y;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>优点</p><ul><li>计算速度快</li></ul><p>缺点</p><ul><li>需要额外数据结构存储格子信息</li><li>需要额外的格子管理逻辑</li><li>实现复杂度高</li><li><strong>格子边界问题</strong></li></ul><h6 id="场景分析与方案设计-三"><a href="#场景分析与方案设计-三" class="headerlink" title="场景分析与方案设计 (三)"></a>场景分析与方案设计 (三)</h6><p>基于方案二做优化</p><p><img src="https://cdn.jsdelivr.net/gh/ShyHeart/Photo/photo/image-20211206213228669.png" alt="image-20211206213228669"></p><p>九宫格，一个格子一个格子广播</p><p>进一步的优化思考</p><p>算法优化</p><ul><li>优化数据结构</li><li>降低运算消耗</li></ul><p>ECS架构</p><ul><li>采用面向数据概念优化架构，提升运算性能</li></ul><p>并行运算与GPU加速</p><ul><li>采用并行计算提升性能</li><li>采用GPU加速减少CPU消耗</li></ul><h5 id="优化性价比曲线"><a href="#优化性价比曲线" class="headerlink" title="优化性价比曲线"></a>优化性价比曲线</h5><p><img src="https://cdn.jsdelivr.net/gh/ShyHeart/Photo/photo/image-20211206213733619.png" alt="image-20211206213733619"></p><h6 id="优化方案参考"><a href="#优化方案参考" class="headerlink" title="优化方案参考"></a>优化方案参考</h6><p>背景</p><p>由于正在开发的游戏涉及到10万个移动角色，如果单服10000玩家的话，采用双向循环查找，那就是10亿的量级，太恐怖了，不得不对算法做优化</p><p>场景：1000*1000的地图，10000客户端角色两个角色间的距离是10时，有效</p><p>优化前</p><p>随机生成10000角色的位置信息，然后计算那些角色的信息需要发给范围的客户端。原始：使用最简单的双向循环查找算法，两重for循环，每找到一个时数量+1结果如下，找到40030个有效值，耗时880ms</p><p>优化一</p><p>位置是双向的，也就是A在B的范围内，B在A的范围内，因此只需要循环N<em>（N-1）/2次，优化结果耗时<em>*416ms</em></em></p><p>优化二</p><p>由于大部分的角色位置相距较远，因此对地图进行分区，以100为单位，整个地图被分成100个区域，创建区域数组Player[100][]，然后计算每个客户端的更新范围所在的区域，并将客户端加入到区域中，注意客户端的四个顶点可能在不同的区域上，此时在几个区域就要加入几个区域。最后计算角色所在区域，并和区域内的Player计算距离。此算法得到的结果是<strong>22.5ms</strong></p><p>优化三</p><p>区域大小用2AN来表示，从而在计算角色所在<br>区域时可以用移位来处理，使用64作为区域大<br>小，优化后平均耗时是：<strong>15.5ms</strong></p><p>优化四</p><p>从算法的耗时来看，区域小一些，则区域数量<br>变多，但每个区域内的角色数量就少了，需要<br>计算的量也会变少，使用32作为区域大小后，<br>耗时为：<strong>9.5ms</strong></p><p>优化五</p><p>如果地图变大一些，角色更加稀疏，则计算量<br>会更少，使用10000<em>10000的地图后， 同样64<br>大小的区域，耗时是：<em>*1.8ms</em></em></p><p>其他案例</p><p><a href="http://cppblog.com/jaxe/archive/2011/06/20/148998.html">http://cppblog.com/jaxe/archive/2011/06/20/148998.html</a></p>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
      <tag>花里胡哨</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity-资源优化</title>
    <link href="/2021/12/23/Unity-%E8%B5%84%E6%BA%90%E4%BC%98%E5%8C%96/"/>
    <url>/2021/12/23/Unity-%E8%B5%84%E6%BA%90%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h3 id="资源优化"><a href="#资源优化" class="headerlink" title="资源优化"></a>资源优化</h3><p>目标： 一般从两个方面 性能 品质</p><p>内存占用 大小/容量 运行效率（帧率高不高）</p><p>先考虑资源</p><p>基础资源类型</p><p>模型 动作 纹理 声音 字体</p><p>综合资源类型</p><p>场景（地形 光源）UI（图集）粒子系统</p><p><strong>游戏资源的制作规范</strong></p><p>模型：三角形数量 UV LOD</p><p>动作：时长 帧率</p><p>贴图：尺寸 格式</p><p><img src="https://cdn.jsdelivr.net/gh/ShyHeart/Photo/photo/image-20211209094742121.png" alt="image-20211209094742121"></p><p><strong>模型导入优化</strong></p><p>模型压缩 网格优化 可读写 Lightmap UV</p><p>动作导入 动画压缩 Rig-优化游戏对象</p><p>纹理格式 POT 纹理大小 压缩选项</p><p><strong>场景优化</strong></p><p>资源的组织 引用及依赖 资源复用</p><p><strong>优化流程自动化</strong></p><p>Unity MeshCompression 网格优化</p><p><img src="https://cdn.jsdelivr.net/gh/ShyHeart/Photo/photo/image-20211209100212083.png" alt="image-20211209100212083"></p><p><img src="https://cdn.jsdelivr.net/gh/ShyHeart/Photo/photo/image-20211209100358273.png" alt="image-20211209100358273"></p><p>模型的Optimize GameObject开启后 ，模型的子节点将压缩成一个节点</p><p>资源后处理 代码</p><p>Unity AssetPostProcessor</p><p><a href="https://docs.unity3d.com/2019.2/Documentation/ScriptReference/AssetPostprocessor.OnPreprocessTexture.html">https://docs.unity3d.com/2019.2/Documentation/ScriptReference/AssetPostprocessor.OnPreprocessTexture.html</a></p>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
      <tag>花里胡哨</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity性能优化</title>
    <link href="/2021/12/23/Unity-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <url>/2021/12/23/Unity-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><h4 id="性能优化-CPU"><a href="#性能优化-CPU" class="headerlink" title="性能优化-CPU"></a>性能优化-CPU</h4><p><strong>干扰 内部与外部</strong></p><p>内部：Profiler，Vertical Sync（垂直同步），Log output 凹操作性能耗费很高</p><p>外部：CPU 内存 IO</p><p><strong>工具</strong></p><p><strong>Unity Profiler</strong></p><p><img src="https://cdn.jsdelivr.net/gh/ShyHeart/Photo/photo/image-20211213161040737.png" alt="image20211213161040737"></p><p><strong>Custom Profiler</strong>（自定义的Profiler）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c#">private void Update()<br>&#123;<br>    CustomProfrile();<br>&#125;<br><br>void CustomProfrile()<br>&#123;<br>    UnityEngine.Profiling.Profiler.BeginSample(&quot;CustomProfrile&quot;);<br>    for (int i = 0; i &lt; 100; i++)<br>    &#123;<br>        CustomFunction();<br>    &#125;<br>    UnityEngine.Profiling.Profiler.EndSample();<br>&#125;<br><br>private void CustomFunction()<br>&#123;<br>    UnityEngine.Profiling.Profiler.BeginSample(&quot;CustomFunction&quot;);<br>    for (int i = 0; i &lt; 100; i++)<br>    &#123;<br>        CustomCale();<br>    &#125;<br>    UnityEngine.Profiling.Profiler.EndSample();<br>&#125;<br><br>private void CustomCale()<br>&#123;<br>    UnityEngine.Profiling.Profiler.BeginSample(&quot;CustomCale&quot;);<br>    float t = 100, f = 0f;<br>    for (int i = 0; i &lt; 100; i++)<br>    &#123;<br>        f += Mathf.Pow(Mathf.Sin(i), t);<br>    &#125;<br>    UnityEngine.Profiling.Profiler.EndSample();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Timer&amp;Log</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c#">public class ProTimer :IDisposable<br>&#123;<br>    private string name;<br>   private int times;<br>   private Stopwatch watch;<br><br>    public ProTimer(string name):this(name,0)&#123;<br><br>    &#125;<br>    public ProTimer(string name,int times)<br>    &#123;<br>        this.name=name;<br>        this.times=times;<br>        if(this.times&lt;=0)<br>            this.times=1;<br>        watch=Stopwatch.StartNew();<br>    &#125;<br><br>    public void Dispose()&#123;<br>        watch.Stop();<br>        float ms=watch.ElapsedMinlliseconds;<br>        if(times&gt;1)&#123;<br>            Debug.Debug.Log(string.Format(&quot;ProTimer : [&#123;0&#125;] finished: [&#123;1:0.00&#125;ms] total, [&#123;2:0.000000&#125;ms] per peroid for [&#123;3&#125;] times&quot;<br>            ,name ,ms,ms/timer,times));<br>        &#125;<br>        else<br>            Debug.Debug.Log(string.Format(&quot;ProTimer : [&#123;0&#125;] finished: [&#123;1:0.00&#125;ms] total&quot;,name,ms ));<br><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="CPU优化要点"><a href="#CPU优化要点" class="headerlink" title="CPU优化要点"></a>CPU优化要点</h5><p>CPU优化要点：Unity脚本最佳做法 数据结构优化 算法优化</p><p><strong>Unity脚本最佳做法</strong></p><ul><li>Component的缓冲与获取</li><li><strong>移除空声明</strong></li><li>避免Find和SendMessage(大概比直接函数调用慢2000倍)</li><li>禁止未使用的游戏脚本与对象 （生存周期 可见性 距离）</li><li>对象池</li></ul><p>Component获取的三种方式</p><ul><li>(CompTest)Component(“Testcomponent”)</li><li>GetComponent<CompTest>();</li><li>(CompTest)GetComponent(typeof(CompTest))</li></ul><p>性能消耗</p><p><img src="https://cdn.jsdelivr.net/gh/ShyHeart/Photo/photo/image-20211213202822084.png" alt="image20211213202822084"></p><p>避免Find和SendMessage-替代方案</p><ul><li>直接引用游戏对象</li><li>静态类</li><li>单例组件</li><li>自定义消息系统</li></ul><p>性能分析注意事项</p><ul><li>分析第一，优化第二</li><li>分析要透彻，避免一知半解盲目优化</li><li>避免为性能分析增加过多临时代码</li><li>增加的日志在头花完成及时移除</li><li>尽量通过DeBug发现问题</li></ul><h4 id="性能优化-GPU"><a href="#性能优化-GPU" class="headerlink" title="性能优化-GPU"></a>性能优化-GPU</h4><p><strong>原理</strong></p><p><img src="https://cdn.jsdelivr.net/gh/ShyHeart/Photo/photo/image-20211213204405189.png" alt="image20211213204405189"></p><h6 id="工具"><a href="#工具" class="headerlink" title="工具"></a><strong>工具</strong></h6><p>Unity Profiler Frame Debug GPU Profiler</p><h6 id="GPU优化要点"><a href="#GPU优化要点" class="headerlink" title="GPU优化要点"></a><strong>GPU优化要点</strong></h6><ul><li>Drawcall</li><li>Batching</li><li>图集</li><li>移动设备优化</li></ul><p>渲染对象关系</p><p><img src="https://cdn.jsdelivr.net/gh/ShyHeart/Photo/photo/image-20211213205858211.png" alt="image20211213205858211"></p><p>Dynamic Batching</p><ul><li>所有Mesh实例具有相同的材质引用</li><li>只有Partucle System和MeshRenderer可以动态批*（随Unity版本不同）</li><li>Vertex Attribute总数必须小于900</li><li>所有实例必须采用Uniform Scale或所有Mesh都采用Nonuniform Scale，不能混合使用。</li><li>必须引用相同的LightMap</li><li>材质Shader不用使用Multiple Passes</li><li>Mesh实例不能接受实时阴影</li><li>每个Batch最大300Mesh</li><li>最多32000Mesh可以Batch</li></ul><p>Static Batching</p><ul><li>所有Mesh实例具有相同的材质引用</li><li>所有Mesh必须标记为Static</li><li>额外的内存占用</li><li>静态对象无法通过原始的Transform移动</li><li>任何一点可见，全部渲染</li></ul><p>移动设备优化要点</p><ul><li>最小的Drawcall</li><li>最小的材质数量</li><li>最小的纹理尺寸</li><li>方形&amp;POT纹理</li><li>Shader中使用尽可能低的数据类型</li><li>避免Alpha测试</li></ul><h4 id="性能优化-内存"><a href="#性能优化-内存" class="headerlink" title="性能优化-内存"></a>性能优化-内存</h4><h6 id="内存占用优化"><a href="#内存占用优化" class="headerlink" title="内存占用优化"></a>内存占用优化</h6><p>分析工具 <strong>Unity Profiler</strong></p><p><img src="https://cdn.jsdelivr.net/gh/ShyHeart/Photo/photo/image-20211216194107133.png" alt="image20211216194107133"></p><p>除此之外，unity还有另外一个更加直观的工具</p><p><strong>Memory Profiler</strong> (开源库之中)</p><p><img src="https://cdn.jsdelivr.net/gh/ShyHeart/Photo/photo/image-20211216194721571.png" alt="image20211216194721571"></p><h6 id="Unity占用组成"><a href="#Unity占用组成" class="headerlink" title="Unity占用组成"></a><strong>Unity占用组成</strong></h6><ul><li><p>Unity</p></li><li><p>Mono</p></li><li><p>GfxDriver(显卡驱动消耗的内存)</p></li><li><p>FMOD（音频引擎）</p></li><li><p>细分(Texture Mesh Animation Shader Font)</p><p><img src="https://cdn.jsdelivr.net/gh/ShyHeart/Photo/photo/image-20211216211225511.png" alt="image20211216211225511"></p><p><img src="https://cdn.jsdelivr.net/gh/ShyHeart/Photo/photo/image-20211216212601027.png" alt="image20211216212601027"></p><p><img src="https://cdn.jsdelivr.net/gh/ShyHeart/Photo/photo/image-20211216212655362.png" alt="image20211216212655362"></p></li></ul><h6 id="GC优化"><a href="#GC优化" class="headerlink" title="GC优化"></a>GC优化</h6><p>GC 内存堆栈 垃圾回收</p><p><a href="https://zhuanlan.zhihu.com/p/265217138">https://zhuanlan.zhihu.com/p/265217138</a></p><p><img src="https://cdn.jsdelivr.net/gh/ShyHeart/Photo/photo/image-20211216213311223.png" alt="image20211216213311223"></p><p>优化要点</p><ul><li>减少频繁的对象创建</li><li>避免装箱</li><li>善用缓存<br><img src="https://cdn.jsdelivr.net/gh/ShyHeart/Photo/photo/image-20211216213529292.png" alt="image-20211216213529292"></li></ul>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
      <tag>花里胡哨</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
